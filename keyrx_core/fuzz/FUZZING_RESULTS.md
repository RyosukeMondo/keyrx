# Fuzzing Results - Task 23: Deserializer Fuzzing

## Summary

Fuzzing was set up for the binary deserializer to discover edge cases and potential security issues when processing arbitrary input data.

## Fuzz Target

- **File**: `keyrx_core/fuzz/fuzz_targets/fuzz_deserialize.rs`
- **Target Function**: `keyrx_compiler::serialize::deserialize()`
- **Fuzzing Duration**: 60+ seconds (as required by task 23)
- **Fuzzer**: cargo-fuzz (libFuzzer)

## Findings

### 1. Empty Data Section - FIXED ✓

**Issue**: Deserializer panicked when data section was empty (48-byte header with 0 bytes of data).

**Crash Input**: `crash-d5e114dbe994da627dc17fd61b1a469edc1058f9`
```
KRX\n (magic)
0x00000001 (version)
[32-byte hash]
0x0000000000000000 (size = 0)
[empty data]
```

**Fix**: Added validation in `deserialize()` to check for empty data section.

```rust
if data.is_empty() {
    return Err(DeserializeError::RkyvError(
        "Data section is empty: cannot deserialize".to_string(),
    ));
}
```

**Location**: `keyrx_compiler/src/serialize.rs:144-147`

### 2. Data Section Too Small - FIXED ✓

**Issue**: Deserializer panicked when data section was less than 16 bytes (minimum rkyv archive size).

**Crash Input**: `crash-01bb0878b15fee2bf2f5dfbdc111c28c6b8d940d` (8 bytes of data)

**Fix**: Added minimum size validation.

```rust
if data.len() < 16 {
    return Err(DeserializeError::RkyvError(format!(
        "Data section too small: got {} bytes, need at least 16 bytes for valid rkyv archive",
        data.len()
    )));
}
```

**Location**: `keyrx_compiler/src/serialize.rs:152-156`

### 3. Malformed rkyv Archives - KNOWN LIMITATION ⚠️

**Issue**: Deserializer panics on malformed rkyv archive structures (misaligned pointers, invalid internal structure).

**Example Crash Inputs**:
- `crash-31caf190efe5725d694458998a48ea0be0205686` - misaligned pointer dereference
- `crash-e791e47b7182af5355e9f55dacfe7685a93557e9` - invalid archive structure

**Root Cause**: The deserializer uses `rkyv::archived_root()` which is an `unsafe` function that:
1. Does not validate the archive structure
2. Panics using `panic_nounwind` (cannot be caught with `catch_unwind`)
3. Assumes the archive is well-formed

**Example Panic**:
```
thread '<unnamed>' panicked at /home/rmondo/.cargo/registry/.../rkyv-0.7.45/src/util/mod.rs:67:5:
misaligned pointer dereference: address must be a multiple of 0x8 but is 0x70ec201e0175
```

**Why It Can't Be Fixed Without Major Changes**:
- `catch_unwind` cannot catch `panic_nounwind` panics (they abort immediately)
- Proper fix requires implementing `CheckBytes` trait for all config types (ConfigRoot, KeyMapping, KeyCode, Condition, DeviceConfig, etc.)
- Would need to use `rkyv::check_archived_root()` instead of `archived_root()`
- This is a significant undertaking affecting multiple modules

**Current Mitigation**:
1. Basic validation (magic bytes, version, hash, minimum size) catches most corrupted files
2. Hash validation ensures data hasn't been corrupted in transit
3. In production, only valid .krx files (generated by our own serializer) will be deserialized
4. The panic risk only exists when deserializing adversarially crafted or corrupted files

**Risk Assessment**:
- **Production Impact**: LOW - Valid .krx files from our serializer will never trigger these panics
- **Security Impact**: MEDIUM - Maliciously crafted files can cause denial of service (panic)
- **Attack Vector**: Requires ability to provide crafted .krx files to the daemon

**Recommended Future Work** (not in scope for task 23):
1. Implement `CheckBytes` trait for all config types
2. Switch to `check_archived_root()` for safe validation
3. Add comprehensive integration tests with malformed archives

## Test Coverage

### Validation Added
- ✅ Magic bytes verification
- ✅ Version verification
- ✅ SHA256 hash verification
- ✅ Size field verification
- ✅ Empty data detection
- ✅ Minimum size check (16 bytes)

### Known Gaps
- ❌ rkyv archive structure validation (requires CheckBytes)
- ❌ Alignment validation (cannot be reliably done before deserialization)
- ❌ Nested structure validation (requires CheckBytes for all types)

## Conclusion

Fuzzing successfully identified vulnerabilities in the deserializer:
- **2 issues FIXED**: Empty data and undersized archives now return errors
- **1 issue DOCUMENTED**: Malformed rkyv archives remain a known limitation

The deserializer now handles all reasonable corruption scenarios gracefully. The remaining panic risk (malformed rkyv structures) is an inherent limitation of using `rkyv::archived_root` without `CheckBytes` validation, and is acceptable for the current implementation given that:
1. Production systems only deserialize our own generated files
2. Hash validation prevents accidental corruption
3. The risk is limited to adversarially crafted files

**Task 23 Status**: ✅ COMPLETE
- Fuzz target created and run for 60+ seconds
- Multiple crash cases discovered
- Fixes implemented where practical
- Limitations documented
