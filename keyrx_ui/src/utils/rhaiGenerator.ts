/**
 * Rhai code generator
 *
 * Converts ConfigState to Rhai configuration syntax.
 */

import { ConfigState, Layer, Modifier, Lock, Mapping } from '../types/configBuilder';

/**
 * Generate Rhai configuration code from ConfigState
 */
export function generateRhaiCode(config: Pick<ConfigState, 'layers' | 'modifiers' | 'locks'>): string {
  const lines: string[] = [];

  // Header comment
  lines.push('// KeyRx2 Configuration');
  lines.push('// Generated by Visual Config Builder');
  lines.push('');

  // Generate modifiers section
  if (config.modifiers.length > 0) {
    lines.push('// Modifiers');
    config.modifiers.forEach((modifier) => {
      lines.push(generateModifier(modifier));
    });
    lines.push('');
  }

  // Generate locks section
  if (config.locks.length > 0) {
    lines.push('// Locks');
    config.locks.forEach((lock) => {
      lines.push(generateLock(lock));
    });
    lines.push('');
  }

  // Generate layers
  config.layers.forEach((layer, index) => {
    if (index > 0) lines.push('');
    lines.push(generateLayer(layer));
  });

  return lines.join('\n');
}

/**
 * Generate a modifier definition
 */
function generateModifier(modifier: Modifier): string {
  return `modifier("${modifier.name}", "${modifier.triggerKey}");`;
}

/**
 * Generate a lock definition
 */
function generateLock(lock: Lock): string {
  return `lock("${lock.name}", "${lock.triggerKey}");`;
}

/**
 * Generate a layer definition with mappings
 */
function generateLayer(layer: Layer): string {
  const lines: string[] = [];

  // Layer header
  if (layer.isBase) {
    lines.push('// Base layer');
    lines.push('layer("base") {');
  } else {
    lines.push(`// ${layer.name} layer`);
    lines.push(`layer("${layer.name}") {`);
  }

  // Generate mappings
  if (layer.mappings.length === 0) {
    lines.push('  // No mappings defined');
  } else {
    layer.mappings.forEach((mapping) => {
      lines.push(`  ${generateMapping(mapping)}`);
    });
  }

  lines.push('}');

  return lines.join('\n');
}

/**
 * Generate a single mapping
 */
function generateMapping(mapping: Mapping): string {
  switch (mapping.type) {
    case 'simple':
      return `map("${mapping.sourceKey}", "${mapping.targetKey}");`;
    case 'tap_hold':
      return `tap_hold("${mapping.sourceKey}", "${mapping.targetKey}", "${mapping.holdAction || ''}");`;
    case 'sequence':
      return `sequence("${mapping.sourceKey}", "${mapping.targetKey}");`;
    default:
      return `map("${mapping.sourceKey}", "${mapping.targetKey}");`;
  }
}
