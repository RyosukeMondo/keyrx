/**
 * Rhai code generator
 *
 * Converts ConfigState to Rhai configuration syntax.
 */

import { ConfigState, Layer, Modifier, Lock, Mapping, RhaiGenerateOptions } from '../types/configBuilder';

/**
 * Generate Rhai configuration code from ConfigState
 */
export function generateRhaiCode(
  config: Pick<ConfigState, 'layers' | 'modifiers' | 'locks'>,
  options: RhaiGenerateOptions = {}
): string {
  const { includeComments = true, indent = '    ', pretty = true } = options;
  const lines: string[] = [];

  // Header comment
  if (includeComments) {
    lines.push('// KeyRx2 Configuration');
    lines.push('// Generated by Visual Config Builder');
    lines.push('//');
    lines.push('// Prefix system:');
    lines.push('//   VK_ = Virtual Key (standard key output)');
    lines.push('//   MD_ = Custom Modifier (custom modifier state, MD_00 through MD_FE)');
    lines.push('//   LK_ = Custom Lock (toggle state, LK_00 through LK_FE)');
    lines.push('');
  }

  // Start device block (matches all devices)
  lines.push('device_start("*");');
  if (pretty) lines.push('');

  // Generate modifier mappings
  if (config.modifiers.length > 0 && includeComments) {
    lines.push(indent + '// Custom Modifiers');
  }
  config.modifiers.forEach((modifier, index) => {
    const modifierId = `MD_${index.toString(16).padStart(2, '0').toUpperCase()}`;
    const mapping = generateModifier(modifier, modifierId);
    if (mapping) {
      lines.push(indent + mapping);
    }
  });
  if (config.modifiers.length > 0 && pretty) lines.push('');

  // Generate lock mappings
  if (config.locks.length > 0 && includeComments) {
    lines.push(indent + '// Custom Locks');
  }
  config.locks.forEach((lock, index) => {
    const lockId = `LK_${index.toString(16).padStart(2, '0').toUpperCase()}`;
    const mapping = generateLock(lock, lockId);
    if (mapping) {
      lines.push(indent + mapping);
    }
  });
  if (config.locks.length > 0 && pretty) lines.push('');

  // Generate base layer mappings (no conditional wrapper)
  const baseLayer = config.layers.find(l => l.isBase);
  if (baseLayer) {
    if (includeComments) {
      lines.push(indent + '// Base Layer Mappings');
    }
    baseLayer.mappings.forEach((mapping) => {
      lines.push(indent + generateMapping(mapping, config));
    });
    if (baseLayer.mappings.length > 0 && pretty) lines.push('');
  }

  // Generate conditional layer mappings (using when() blocks)
  const nonBaseLayers = config.layers.filter(l => !l.isBase);
  nonBaseLayers.forEach((layer, layerIndex) => {
    if (layer.mappings.length === 0) return;

    // Find the modifier that activates this layer
    const layerModifierIndex = layerIndex; // Simple approach: layer index maps to modifier index
    const modifierId = `MD_${layerModifierIndex.toString(16).padStart(2, '0').toUpperCase()}`;

    if (includeComments) {
      lines.push(indent + `// ${layer.name} Layer (active when ${modifierId} is held)`);
    }

    lines.push(indent + `when("${modifierId}", [`);
    layer.mappings.forEach((mapping, idx) => {
      const mappingStr = generateMapping(mapping, config);
      const isLast = idx === layer.mappings.length - 1;
      lines.push(indent + indent + mappingStr + (isLast ? '' : ','));
    });
    lines.push(indent + ']);');
    if (pretty) lines.push('');
  });

  // End device block
  lines.push('device_end();');

  return lines.join('\n');
}

/**
 * Generate a modifier mapping
 * Maps the trigger key to a custom modifier ID (MD_XX)
 */
function generateModifier(modifier: Modifier, modifierId: string): string | null {
  if (!modifier.triggerKey) {
    return null; // Skip modifiers without trigger keys
  }
  return `map("${normalizeKeyCode(modifier.triggerKey)}", "${modifierId}");`;
}

/**
 * Generate a lock mapping
 * Maps the trigger key to a custom lock ID (LK_XX)
 */
function generateLock(lock: Lock, lockId: string): string | null {
  if (!lock.triggerKey) {
    return null; // Skip locks without trigger keys
  }
  return `map("${normalizeKeyCode(lock.triggerKey)}", "${lockId}");`;
}

/**
 * Generate a single mapping
 */
function generateMapping(mapping: Mapping, config: Pick<ConfigState, 'modifiers' | 'locks'>): string {
  const sourceKey = normalizeKeyCode(mapping.sourceKey);

  switch (mapping.type) {
    case 'simple':
      // Simple key remapping with VK_ prefix
      return `map("${sourceKey}", "${addVKPrefix(mapping.targetKey)}")`;

    case 'modifier_trigger':
      // Map to a custom modifier
      if (mapping.modifierId) {
        const modifierIndex = config.modifiers.findIndex(m => m.id === mapping.modifierId);
        if (modifierIndex >= 0) {
          const modifierId = `MD_${modifierIndex.toString(16).padStart(2, '0').toUpperCase()}`;
          return `map("${sourceKey}", "${modifierId}")`;
        }
      }
      // Fallback if modifier not found
      return `map("${sourceKey}", "${addVKPrefix(mapping.targetKey)}")`;

    case 'layer_switch':
      // Map to a layer modifier (same as modifier_trigger in this implementation)
      if (mapping.targetLayerId) {
        const layerIndex = config.modifiers.findIndex(m => m.name === mapping.targetLayerId);
        if (layerIndex >= 0) {
          const modifierId = `MD_${layerIndex.toString(16).padStart(2, '0').toUpperCase()}`;
          return `map("${sourceKey}", "${modifierId}")`;
        }
      }
      return `map("${sourceKey}", "${addVKPrefix(mapping.targetKey)}")`;

    default:
      return `map("${sourceKey}", "${addVKPrefix(mapping.targetKey)}")`;
  }
}

/**
 * Normalize key code by removing KEY_ prefix if present
 * Input keys should not have prefixes in Rhai
 */
function normalizeKeyCode(keyCode: string | undefined | null | any): string {
  if (!keyCode || typeof keyCode !== 'string') {
    return '';
  }
  if (keyCode.startsWith('KEY_')) {
    return keyCode.substring(4);
  }
  if (keyCode.startsWith('VK_')) {
    return keyCode.substring(3);
  }
  return keyCode;
}

/**
 * Add VK_ prefix to output key if not already present
 * Output keys must have VK_ prefix (or MD_/LK_ for modifiers/locks)
 */
function addVKPrefix(keyCode: string | undefined | null | any): string {
  if (!keyCode || typeof keyCode !== 'string') {
    return 'VK_UNKNOWN';
  }
  // Already has a prefix (VK_, MD_, LK_)
  if (keyCode.startsWith('VK_') || keyCode.startsWith('MD_') || keyCode.startsWith('LK_')) {
    return keyCode;
  }
  // Remove KEY_ prefix if present, then add VK_
  const normalized = normalizeKeyCode(keyCode);
  return `VK_${normalized}`;
}
