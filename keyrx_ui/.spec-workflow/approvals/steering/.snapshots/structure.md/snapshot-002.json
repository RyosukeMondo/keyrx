{
  "id": "snapshot_1766291191972_m6efcttgg",
  "approvalId": "approval_1766290981485_tl6ufmn63",
  "approvalTitle": "Codebase structure and coding standards",
  "version": 2,
  "timestamp": "2025-12-21T04:26:31.972Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Project Structure\n\n## Directory Organization\n\n```\nkeyrx/\n├── Cargo.toml              # Workspace root (4 crates)\n├── Makefile                # Top-level orchestration\n├── .github/workflows/      # CI/CD (clippy, tests, coverage, release)\n│\n├── crates/\n│   ├── keyrx_core/         # Platform-agnostic logic (no_std)\n│   ├── keyrx_compiler/     # Rhai → .krx compiler (CLI)\n│   ├── keyrx_daemon/       # OS-specific daemon + embedded web server\n│   └── keyrx_ui/           # React + WASM frontend\n│\n├── docs/                   # Architecture & API documentation\n├── examples/               # Rhai configuration examples\n└── scripts/                # AI-friendly build/test/launch scripts\n```\n\n### Crate-Level Organization\n\n**keyrx_core/** (Platform-agnostic, no_std):\n```\nkeyrx_core/\n├── Cargo.toml              # no_std, minimal dependencies\n├── src/\n│   ├── lib.rs              # Public API exports\n│   ├── config.rs           # rkyv-serialized config structures\n│   ├── lookup.rs           # MPHF-based O(1) key lookup\n│   ├── dfa.rs              # Deterministic Finite Automaton (Tap/Hold)\n│   ├── state.rs            # 255-bit modifier/lock state (fixedbitset)\n│   └── simulator.rs        # Deterministic Simulation Testing (DST)\n├── benches/                # Criterion benchmarks\n│   ├── lookup_bench.rs\n│   └── dfa_bench.rs\n├── fuzz/                   # cargo-fuzz targets\n│   └── fuzz_targets/\n│       └── event_stream.rs\n└── tests/                  # Integration tests\n    └── dfa_tests.rs\n```\n\n**keyrx_compiler/** (Standalone CLI tool):\n```\nkeyrx_compiler/\n├── Cargo.toml\n├── src/\n│   ├── main.rs             # CLI entry point (clap args)\n│   ├── parser.rs           # Rhai AST evaluation\n│   ├── mphf_gen.rs         # MPHF generation (boomphf)\n│   ├── dfa_gen.rs          # DFA compilation from Tap/Hold configs\n│   └── serialize.rs        # rkyv binary output (.krx files)\n└── tests/\n    └── integration/\n        ├── basic.rs        # Simple config compilation\n        └── complex.rs      # 255 modifiers test\n```\n\n**keyrx_daemon/** (OS-specific daemon + web server):\n```\nkeyrx_daemon/\n├── Cargo.toml              # Platform-specific dependencies, features\n├── src/\n│   ├── main.rs             # Daemon entry point, CLI args\n│   ├── platform/\n│   │   ├── mod.rs          # Platform trait abstraction\n│   │   ├── linux.rs        # evdev/uinput implementation\n│   │   └── windows.rs      # Low-Level Hooks + Raw Input\n│   ├── web/                # Embedded web server (feature-gated)\n│   │   ├── mod.rs          # axum server setup\n│   │   ├── api.rs          # REST API (config upload, status)\n│   │   ├── ws.rs           # WebSocket handler (real-time events)\n│   │   └── static_files.rs # Serve embedded UI (include_dir!)\n│   ├── loader.rs           # Memory-mapped .krx loading\n│   └── logger.rs           # Structured JSON logging\n├── ui_dist/                # Embedded UI (from keyrx_ui build)\n│   ├── index.html\n│   ├── keyrx_core_bg.wasm\n│   └── assets/\n└── tests/\n    └── e2e/                # OS-specific integration tests\n        ├── linux_test.rs\n        └── windows_test.rs\n```\n\n**keyrx_ui/** (React + WASM frontend):\n```\nkeyrx_ui/\n├── package.json\n├── vite.config.ts          # Vite bundler config\n├── src/\n│   ├── App.tsx             # Root component\n│   ├── components/\n│   │   ├── KeyboardVisualizer.tsx  # SVG keyboard with state\n│   │   ├── DFADiagram.tsx          # State transition graph\n│   │   ├── ConfigEditor.tsx        # Rhai script editor\n│   │   └── DeviceSelector.tsx      # Serial number picker\n│   ├── wasm/\n│   │   └── core.ts         # TypeScript bindings for WASM\n│   └── hooks/\n│       ├── useSimulator.ts # WASM simulation hook\n│       └── useDaemon.ts    # WebSocket connection to daemon\n└── public/\n    └── fonts/\n```\n\n## Naming Conventions\n\n### Files (Rust)\n- **Modules**: `snake_case.rs` (e.g., `mphf_gen.rs`, `static_files.rs`)\n- **Tests**: `[module_name]_test.rs` or `tests/[feature].rs`\n- **Benchmarks**: `[feature]_bench.rs` (e.g., `lookup_bench.rs`)\n- **Binary crates**: Match project name (e.g., `keyrx_daemon`, `keyrx_compiler`)\n\n### Files (TypeScript/React)\n- **Components**: `PascalCase.tsx` (e.g., `KeyboardVisualizer.tsx`)\n- **Hooks**: `use[Feature].ts` (e.g., `useSimulator.ts`)\n- **Utils**: `camelCase.ts` (e.g., `wasmBindings.ts`)\n- **Tests**: `[Component].test.tsx`\n\n### Code (Rust)\n- **Structs/Enums/Traits**: `PascalCase` (e.g., `ExtendedState`, `EventStream`)\n- **Functions/Methods**: `snake_case` (e.g., `load_config`, `process_event`)\n- **Constants**: `UPPER_SNAKE_CASE` (e.g., `MAX_MODIFIERS`, `DEFAULT_PORT`)\n- **Variables**: `snake_case` (e.g., `modifier_state`, `event_queue`)\n- **Type parameters**: Single uppercase letter or `PascalCase` (e.g., `T`, `EventType`)\n\n### Code (TypeScript/React)\n- **Components**: `PascalCase` (e.g., `KeyboardVisualizer`)\n- **Functions/Hooks**: `camelCase` (e.g., `useSimulator`, `connectToDaemon`)\n- **Constants**: `UPPER_SNAKE_CASE` (e.g., `WS_PORT`, `MAX_RETRIES`)\n- **Interfaces/Types**: `PascalCase` (e.g., `DaemonState`, `KeyEvent`)\n\n## Import Patterns\n\n### Import Order (Rust)\n```rust\n// 1. Standard library\nuse std::collections::HashMap;\n\n// 2. External dependencies (alphabetically)\nuse rkyv::{Archive, Serialize};\nuse serde::Deserialize;\n\n// 3. Internal workspace crates\nuse keyrx_core::{EventStream, State};\n\n// 4. Current crate modules (relative)\nuse crate::config::Config;\nuse super::utils;\n```\n\n### Import Order (TypeScript)\n```typescript\n// 1. React and framework\nimport React, { useState, useEffect } from 'react';\n\n// 2. External dependencies\nimport { WebSocket } from 'ws';\n\n// 3. Internal modules (absolute from src/)\nimport { WasmCore } from '@/wasm/core';\n\n// 4. Relative imports\nimport { Button } from './Button';\n\n// 5. Types (if not inline)\nimport type { KeyEvent } from '@/types';\n\n// 6. Styles (last)\nimport './App.css';\n```\n\n### Module Organization\n- **Absolute imports**: Use workspace-relative imports between crates\n  - `use keyrx_core::config::Config;` (not relative paths)\n- **Re-exports**: `lib.rs` or `mod.rs` re-exports public API\n  ```rust\n  // keyrx_core/src/lib.rs\n  pub use self::config::Config;\n  pub use self::dfa::DFA;\n  ```\n- **Feature gates**: Use `#[cfg(feature = \"web\")]` for optional dependencies\n  ```rust\n  #[cfg(feature = \"web\")]\n  pub mod web;\n  ```\n\n## Code Structure Patterns\n\n### Module/File Organization (Rust)\n\n**Standard file structure**:\n```rust\n// 1. Module documentation\n//! Module-level documentation explaining purpose.\n\n// 2. Imports (see Import Order above)\nuse std::collections::HashMap;\nuse keyrx_core::State;\n\n// 3. Constants\nconst MAX_RETRIES: usize = 3;\nconst TIMEOUT_MS: u64 = 1000;\n\n// 4. Type definitions\npub struct EventProcessor {\n    state: State,\n}\n\npub enum EventType {\n    KeyDown,\n    KeyUp,\n}\n\n// 5. Main implementation\nimpl EventProcessor {\n    pub fn new() -> Self { /* ... */ }\n    pub fn process(&mut self) { /* ... */ }\n}\n\n// 6. Helper functions (private)\nfn validate_input(data: &[u8]) -> bool { /* ... */ }\n\n// 7. Tests (same file, feature-gated)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_process() { /* ... */ }\n}\n```\n\n### Function/Method Organization\n\n**Standard function structure** (per CLAUDE.md requirements):\n```rust\n/// Public API documentation\npub fn process_event(event: KeyEvent) -> Result<Action, Error> {\n    // 1. Input validation (fail-fast)\n    if !event.is_valid() {\n        return Err(Error::InvalidInput);\n    }\n\n    // 2. Core logic (SLAP - Single Level of Abstraction)\n    let state = load_state()?;\n    let action = compute_action(&state, &event)?;\n\n    // 3. Side effects (logging, mutations)\n    log::debug!(\"Processed event: {:?}\", event);\n\n    // 4. Return result\n    Ok(action)\n}\n\n// Helper functions extracted for SLAP compliance\nfn load_state() -> Result<State, Error> { /* ... */ }\nfn compute_action(state: &State, event: &KeyEvent) -> Result<Action, Error> { /* ... */ }\n```\n\n**Key principles**:\n- **Max 50 lines per function** (per CLAUDE.md)\n- **SLAP**: Each function operates at single level of abstraction\n- **Early returns**: Fail-fast validation at the top\n- **No nested callbacks**: Use `?` operator, extract functions\n\n### Component Organization (React)\n\n**Standard React component structure**:\n```typescript\nimport React, { useState, useEffect } from 'react';\nimport type { Props } from './types';\n\n/**\n * Component documentation\n */\nexport function KeyboardVisualizer({ config }: Props) {\n  // 1. Hooks (useState, useEffect, custom hooks)\n  const [state, setState] = useState(initialState);\n  const daemon = useDaemon();\n\n  // 2. Event handlers\n  const handleKeyPress = (key: string) => {\n    // ...\n  };\n\n  // 3. Render helpers (if needed)\n  const renderKey = (key: string) => <div>{key}</div>;\n\n  // 4. Effects\n  useEffect(() => {\n    // ...\n  }, []);\n\n  // 5. Return JSX\n  return (\n    <div>{/* ... */}</div>\n  );\n}\n\n// 6. Helper components (local to file)\nfunction KeyButton({ label }: { label: string }) {\n  return <button>{label}</button>;\n}\n```\n\n## Code Organization Principles\n\n### 1. Single Responsibility Principle (SRP)\n- Each file has **one clear purpose**\n- Example: `lookup.rs` handles MPHF lookup only, not DFA logic\n- Example: `KeyboardVisualizer.tsx` renders keyboard only, not WebSocket logic\n\n### 2. Dependency Injection (DI)\n- **All external dependencies injected** (per CLAUDE.md):\n  ```rust\n  // Good: Testable, mockable\n  pub fn process_events<S: EventStream>(stream: &mut S) { /* ... */ }\n\n  // Bad: Hard-coded dependency\n  pub fn process_events() {\n      let stream = evdev::open(); // NOT testable\n  }\n  ```\n- Platform-specific code abstracted via traits:\n  ```rust\n  pub trait Platform {\n      fn capture_input(&mut self) -> Result<KeyEvent>;\n      fn inject_output(&mut self, event: KeyEvent) -> Result<()>;\n  }\n  ```\n\n### 3. SSOT (Single Source of Truth)\n- **Configuration**: `.krx` binary file is the ONLY source\n  - Daemon, UI, tests all read same `.krx` file\n  - No duplication in JSON, TOML, or other formats\n- **State**: `ExtendedState` struct is the ONLY state representation\n  - No shadow copies, no stale caches\n\n### 4. Modularity & Testability\n- **no_std core**: `keyrx_core` compiles without OS dependencies\n  - Enables WASM compilation\n  - Forces pure logic (no hidden I/O)\n- **Trait abstractions**: Platform-specific code behind traits\n  - `EventStream` trait for Linux/Windows/Test doubles\n  - Mockable in tests\n\n### 5. Consistency\n- **Follow Rust API guidelines**: https://rust-lang.github.io/api-guidelines/\n- **Follow React best practices**: Hooks, functional components\n\n## Module Boundaries\n\n### Core vs Platform-Specific\n- **keyrx_core** (no_std):\n  - Pure logic: DFA, MPHF lookup, state management\n  - No OS dependencies (no `std::fs`, `std::net`)\n  - Compilable to WASM\n- **keyrx_daemon** (platform-specific):\n  - OS hooks (evdev, Windows Low-Level Hooks)\n  - File I/O, networking, threading\n  - Platform code isolated in `platform/` module\n\n**Dependency direction**: daemon → core (never core → daemon)\n\n### Public API vs Internal\n- **Public API**: Exposed via `pub use` in `lib.rs`\n  ```rust\n  // keyrx_core/src/lib.rs\n  pub use config::Config;\n  pub use dfa::DFA;\n  // Internal: state::ExtendedState (not pub re-exported)\n  ```\n- **Internal**: Not re-exported, can change freely\n  - Example: `state::ExtendedState` implementation details\n\n### Stable vs Experimental\n- **Stable**: Public API in `keyrx_core` (semver guarantees)\n- **Experimental**: Feature-gated behind `#[cfg(feature = \"unstable\")]`\n  - Breaking changes allowed\n  - Not included in releases by default\n\n### Optional Features\n- **Web server**: `#[cfg(feature = \"web\")]` in `keyrx_daemon`\n  - Headless daemon possible without web dependencies\n- **Debug UI**: `#[cfg(feature = \"debug_ui\")]` for development tools\n\n## Code Size Guidelines\n\nPer CLAUDE.md requirements:\n\n### File Size\n- **Maximum 500 lines per file** (excluding comments/blank lines)\n- If exceeded:\n  - Extract helper modules\n  - Split into `[module]/mod.rs` + sub-modules\n\n### Function/Method Size\n- **Maximum 50 lines per function**\n- If exceeded:\n  - Extract helper functions\n  - Apply SLAP (Single Level of Abstraction Principle)\n\n### Complexity Limits\n- **Test coverage**: 80% minimum, 90% for critical paths (keyrx_core)\n- **Cyclomatic complexity**: Aim for <10 per function (use `cargo clippy`)\n- **Nesting depth**: Maximum 3 levels\n  ```rust\n  // Bad: 4 levels of nesting\n  if x {\n      if y {\n          if z {\n              if w { /* ... */ }\n          }\n      }\n  }\n\n  // Good: Early returns, flattened\n  if !x { return; }\n  if !y { return; }\n  if !z { return; }\n  if w { /* ... */ }\n  ```\n\n### Enforcement\n- **Pre-commit hooks**: clippy, rustfmt, tests (mandatory per CLAUDE.md)\n- **CI checks**: Fail build if limits exceeded\n- **cargo clippy**: Enforced with `-D warnings` (treat warnings as errors)\n\n## Dashboard/Monitoring Structure\n\n### Web UI Organization\n```\nkeyrx_daemon/src/web/\n├── mod.rs              # axum server setup, routes\n├── api.rs              # REST API handlers\n│   ├── GET /status     # Daemon health, config hash\n│   ├── POST /config    # Upload new .krx config\n│   └── GET /devices    # List input devices\n├── ws.rs               # WebSocket handler\n│   ├── Event stream    # Real-time key events (debug mode)\n│   └── State updates   # Modifier/lock state changes\n└── static_files.rs     # Serve embedded UI (include_dir!)\n```\n\n### Separation of Concerns\n- **Web module is optional**: `#[cfg(feature = \"web\")]`\n- **Can be disabled**: Headless daemon for servers\n- **Minimal coupling**: Web module only depends on public daemon API\n- **Independent port**: Web server on :9876, doesn't interfere with input processing\n\n### Frontend-Backend Contract\n- **API spec**: Documented in `docs/api.md`\n- **WebSocket events**: JSON schema with versioning\n  ```json\n  {\n    \"version\": \"1.0\",\n    \"type\": \"key_event\",\n    \"data\": { \"key\": \"A\", \"state\": \"down\" }\n  }\n  ```\n- **Type safety**: TypeScript types generated from Rust (future: use typeshare)\n\n## Documentation Standards\n\n### Rust Documentation\n- **All public APIs must have doc comments**:\n  ```rust\n  /// Processes a key event through the remapping engine.\n  ///\n  /// # Arguments\n  /// * `event` - The input key event\n  ///\n  /// # Returns\n  /// The remapped action or an error\n  ///\n  /// # Examples\n  /// ```\n  /// let action = process_event(KeyEvent::new(Key::A))?;\n  /// ```\n  pub fn process_event(event: KeyEvent) -> Result<Action, Error> { /* ... */ }\n  ```\n- **Module-level docs**: `//! Module purpose`\n- **Complex logic**: Inline `// comments` explaining \"why\", not \"what\"\n\n### TypeScript Documentation\n- **TSDoc for public APIs**:\n  ```typescript\n  /**\n   * Connects to the keyrx daemon via WebSocket.\n   * @param url - WebSocket URL (default: ws://localhost:9876)\n   * @returns Connection handle\n   */\n  export function connectToDaemon(url?: string): Connection { /* ... */ }\n  ```\n\n### README Files\n- Each major module has `README.md`:\n  - `crates/keyrx_core/README.md`\n  - `crates/keyrx_daemon/README.md`\n  - `scripts/README.md` (or `scripts/CLAUDE.md` for AI agents)\n\n### AI-Friendly Documentation\n- **scripts/CLAUDE.md**: Machine-readable script documentation\n  - Usage examples\n  - Expected output formats\n  - Failure scenarios and exit codes\n- **Consistent log markers**: `=== accomplished ===` for AI parsing\n- **Structured errors**: JSON error output with `--json` flag\n\n## Testing Structure\n\n### Test Organization\n```\nkeyrx_core/\n├── src/\n│   ├── lib.rs\n│   ├── dfa.rs          # Module code\n│   └── dfa_tests.rs    # Unit tests (if complex)\n└── tests/\n    ├── integration/    # Integration tests (cross-module)\n    │   └── dfa_integration.rs\n    └── fixtures/       # Test data\n        └── test_config.krx\n```\n\n### Test Naming\n- **Unit tests**: `#[cfg(test)] mod tests` in same file\n- **Integration tests**: `tests/[feature].rs`\n- **Test functions**: `test_[scenario]_[expected_outcome]`\n  ```rust\n  #[test]\n  fn test_tap_hold_timeout_triggers_hold() { /* ... */ }\n  ```\n\n### Test Data\n- **Fixtures**: `tests/fixtures/` for shared test data\n- **Deterministic**: Use seeded RNG, virtual clock (no wall-clock time)\n- **AI-verifiable**: Tests output structured logs for AI agents to parse\n",
  "fileStats": {
    "size": 16935,
    "lines": 543,
    "lastModified": "2025-12-21T04:22:44.671Z"
  },
  "comments": []
}