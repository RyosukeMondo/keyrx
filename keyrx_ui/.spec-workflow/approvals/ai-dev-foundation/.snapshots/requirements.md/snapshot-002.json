{
  "id": "snapshot_1766293114648_sodxkwyvw",
  "approvalId": "approval_1766292917226_jwpk9axdk",
  "approvalTitle": "Requirements for AI development foundation",
  "version": 2,
  "timestamp": "2025-12-21T04:58:34.648Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe **AI-Dev-Foundation** spec establishes the critical infrastructure that enables fully autonomous AI-driven development of the keyrx project. This foundation includes:\n- **4-crate workspace initialization** (keyrx_core, keyrx_compiler, keyrx_daemon, keyrx_ui)\n- **AI-friendly build/test/launch scripts** with machine-parseable output\n- **CLAUDE.md documentation** for AI agent guidance\n- **Pre-commit hooks and CI/CD** for automated quality enforcement\n\nWithout this foundation, AI agents cannot work autonomously—they would lack:\n- Consistent, parseable feedback from build/test operations\n- Clear rules and patterns for code organization\n- Automated verification of code quality standards\n- Deterministic, reproducible development workflows\n\nThis spec is the **prerequisite for all other feature development**, as it creates the environment where AI agents can confidently implement, test, and verify their work without human intervention.\n\n## Alignment with Product Vision\n\nThis spec directly implements the **\"AI Coding Agent First\"** product principle (product.md):\n\n**From Product Principles**:\n> \"keyrx is designed to be verified, modified, and deployed by AI agents without human intervention.\"\n\n**Key Alignments**:\n\n1. **SSOT (Single Source of Truth)**:\n   - Scripts output consistent markers (`=== accomplished ===`, `=== failed ===`)\n   - AI agents can verify build/test results by parsing structured output\n   - No ambiguity in success/failure states\n\n2. **Structured Logging**:\n   - All scripts emit JSON-formatted logs when `--json` flag is used\n   - Epoch-timestamped log files enable correlation and audit trails\n   - AI agents can programmatically analyze failures without human interpretation\n\n3. **Observability & Controllability**:\n   - CLAUDE.md documents all scripts, patterns, and conventions\n   - AI agents can discover rules/patterns by reading a single source\n   - Every operation has clear success criteria\n\n4. **Zero Manual Testing**:\n   - Pre-commit hooks enforce clippy, rustfmt, tests automatically\n   - CI/CD fails builds that violate quality standards\n   - AI agents get immediate, deterministic feedback\n\n**Quality Metrics Enabled**:\n- 80% minimum test coverage (enforced by pre-commit hook)\n- Max 500 lines/file, max 50 lines/function (enforced by clippy)\n- Consistent code formatting (rustfmt)\n\n## Requirements\n\n### Requirement 1: Workspace Initialization\n\n**User Story:** As an **AI coding agent**, I want **all 4 crates initialized with proper structure**, so that **I can immediately start implementing features without scaffolding overhead**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN the workspace is initialized THEN the system SHALL create a root `Cargo.toml` with workspace configuration for 4 crates: `keyrx_core`, `keyrx_compiler`, `keyrx_daemon`, `keyrx_ui`\n\n2. WHEN the workspace is initialized THEN the system SHALL create each crate with:\n   - `Cargo.toml` with correct dependencies (per tech.md specifications)\n   - `src/` directory with entry point (`lib.rs` for libraries, `main.rs` for binaries)\n   - `README.md` with crate purpose and basic usage\n   - Placeholder modules matching structure.md specifications\n\n3. WHEN `keyrx_core` is initialized THEN it SHALL:\n   - Be configured as `no_std` (enables WASM compilation)\n   - Include dependencies: rkyv, boomphf, fixedbitset, arrayvec\n   - Have placeholder modules: `config.rs`, `lookup.rs`, `dfa.rs`, `state.rs`, `simulator.rs`\n   - Include `benches/` directory with Criterion setup\n   - Include `fuzz/` directory with cargo-fuzz setup\n\n4. WHEN `keyrx_compiler` is initialized THEN it SHALL:\n   - Be a binary crate with CLI argument parsing (clap)\n   - Include dependencies: rhai, serde, clap\n   - Have placeholder modules: `parser.rs`, `mphf_gen.rs`, `dfa_gen.rs`, `serialize.rs`\n   - Include `tests/integration/` directory\n\n5. WHEN `keyrx_daemon` is initialized THEN it SHALL:\n   - Be a binary crate with platform-specific features (`linux`, `windows`, `web`)\n   - Include Linux dependencies (feature-gated): evdev, uinput, nix\n   - Include Windows dependencies (feature-gated): windows-sys\n   - Include web server dependencies (feature-gated): axum, tower-http, tokio\n   - Have platform-specific modules: `platform/linux.rs`, `platform/windows.rs`\n   - Have web server modules: `web/mod.rs`, `web/api.rs`, `web/ws.rs`, `web/static_files.rs`\n   - Include `ui_dist/` directory for embedded UI files\n\n6. WHEN `keyrx_ui` is initialized THEN it SHALL:\n   - Have `package.json` with React 18+, TypeScript 5+, Vite dependencies\n   - Have `vite.config.ts` configured for WASM integration\n   - Include `src/` with `App.tsx`, `components/`, `wasm/`, `hooks/` directories\n   - Include `.gitignore` for node_modules, dist\n\n7. WHEN the workspace is initialized THEN it SHALL create a root `.gitignore` with:\n   - Rust build artifacts (`target/`, `Cargo.lock`)\n   - Node.js artifacts (`node_modules/`, `dist/`)\n   - Log files (`scripts/logs/*.log`)\n   - OS-specific files (`.DS_Store`, `Thumbs.db`)\n\n### Requirement 2: AI-Friendly Build Scripts\n\n**User Story:** As an **AI coding agent**, I want **consistent, parseable build/test scripts**, so that **I can autonomously verify my work without human interpretation**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN a script is executed THEN it SHALL output consistent status markers:\n   - `=== accomplished ===` on successful completion\n   - `=== failed ===` on failure\n   - `=== warning ===` for non-critical issues\n\n2. WHEN a script is executed THEN it SHALL:\n   - Write timestamped logs to `scripts/logs/[script]_$(date +%s).log`\n   - Use epoch timestamp in filename (e.g., `build_1766294000.log`)\n   - Output structured logs in format: `[YYYY-MM-DD HH:MM:SS] [LEVEL] message`\n\n3. WHEN a script is executed with `--error` flag THEN it SHALL:\n   - Output ONLY error-level messages\n   - Filter out INFO and DEBUG messages\n   - Enable AI agents to focus on failures without noise\n\n4. WHEN a script is executed with `--json` flag THEN it SHALL:\n   - Output machine-readable JSON format\n   - Include fields: `timestamp`, `level`, `message`, `context`\n   - Exit with JSON summary: `{\"status\": \"success|failed\", \"duration_ms\": 1234}`\n\n5. WHEN a script is executed with `--quiet` flag THEN it SHALL:\n   - Suppress all output except final status marker\n   - Enable silent CI/CD execution\n\n6. WHEN a script is executed with `--log-file <path>` THEN it SHALL:\n   - Write logs to the specified path instead of default location\n   - Create parent directories if they don't exist\n\n7. WHEN `build.sh` is executed THEN it SHALL:\n   - Run `cargo build --workspace`\n   - Support `--release` flag for optimized builds\n   - Support `--watch` flag for continuous builds (using `cargo-watch`)\n   - Output success marker on clean build, failure marker on errors\n\n8. WHEN `verify.sh` is executed THEN it SHALL:\n   - Run `cargo clippy -- -D warnings` (treat warnings as errors)\n   - Run `cargo fmt --check`\n   - Run `cargo test --workspace`\n   - Run `cargo tarpaulin` to check test coverage (80% minimum)\n   - Fail if any check fails\n   - Output summary of all checks with pass/fail status\n\n9. WHEN `test.sh` is executed THEN it SHALL:\n   - Support `--unit` flag: run only unit tests\n   - Support `--integration` flag: run only integration tests\n   - Support `--fuzz` flag: run fuzzing for specified duration (default 60s)\n   - Run all tests by default\n   - Output test results with pass/fail counts\n\n10. WHEN `launch.sh` is executed THEN it SHALL:\n    - Support `--headless` flag: start daemon without web UI\n    - Support `--debug` flag: enable debug logging\n    - Start daemon with default config (or specified config via `--config` flag)\n    - Output daemon PID and listening ports\n\n11. WHEN any script exits THEN it SHALL:\n    - Return exit code 0 on success\n    - Return exit code 1 on error\n    - Return exit code 2 on warnings (non-critical)\n\n### Requirement 3: CLAUDE.md Documentation\n\n**User Story:** As an **AI coding agent**, I want **comprehensive, structured documentation**, so that **I can discover rules, patterns, and conventions without asking humans**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN `scripts/CLAUDE.md` is created THEN it SHALL document:\n   - Purpose of each script (`build.sh`, `verify.sh`, `test.sh`, `launch.sh`)\n   - All supported flags and their effects\n   - Expected output format (status markers, log format)\n   - Example usage for common scenarios\n\n2. WHEN `scripts/CLAUDE.md` is created THEN it SHALL include:\n   - **Script Reference Table**: Script name, purpose, common flags, exit codes\n   - **Output Format Specification**: Status markers, log structure, JSON schema\n   - **Example Commands**: At least 3 examples per script\n   - **Failure Scenarios**: Common errors and how to interpret them\n\n3. WHEN `scripts/CLAUDE.md` is created THEN it SHALL be:\n   - **Structured**: Use markdown headers for easy navigation\n   - **Minimal**: Focus on actionable information, avoid prose\n   - **Examples-first**: Show examples before explaining\n\n4. WHEN `.claude/CLAUDE.md` (root) is created THEN it SHALL document:\n   - **Project Structure**: 4-crate workspace overview\n   - **Code Quality Rules**: Max 500 lines/file, max 50 lines/function, 80% coverage\n   - **Architecture Patterns**: SOLID, DI, SSOT, KISS (from structure.md)\n   - **Naming Conventions**: Rust (snake_case), TypeScript (camelCase/PascalCase)\n   - **Import Patterns**: Rust module structure, TypeScript import order\n\n5. WHEN `.claude/CLAUDE.md` is created THEN it SHALL include:\n   - **AI-Agent Quick Start**: Steps to verify environment, run first build, run tests\n   - **Common Tasks**: How to add a new module, add a test, run specific tests\n   - **Troubleshooting**: Common errors and fixes\n\n### Requirement 4: Pre-Commit Hooks\n\n**User Story:** As an **AI coding agent**, I want **automated quality enforcement**, so that **I get immediate feedback before committing code**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN pre-commit hooks are installed THEN they SHALL run before every `git commit`\n\n2. WHEN pre-commit hooks are executed THEN they SHALL:\n   - Run `cargo clippy -- -D warnings` (treat warnings as errors)\n   - Run `cargo fmt --check` (fail if code is not formatted)\n   - Run `cargo test --workspace` (fail if tests fail)\n   - Abort commit if any check fails\n\n3. WHEN pre-commit hooks are installed THEN the system SHALL create `.git/hooks/pre-commit` with:\n   - Executable permissions (`chmod +x`)\n   - Calls to `scripts/verify.sh --quiet`\n   - Clear failure messages indicating which check failed\n\n4. WHEN `scripts/setup_hooks.sh` is created THEN it SHALL:\n   - Install pre-commit hook to `.git/hooks/pre-commit`\n   - Output success message confirming installation\n   - Be idempotent (safe to run multiple times)\n\n### Requirement 5: CI/CD Setup\n\n**User Story:** As an **AI coding agent**, I want **automated CI/CD**, so that **all code changes are automatically verified before merging**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN `.github/workflows/ci.yml` is created THEN it SHALL:\n   - Run on every push to any branch\n   - Run on every pull request\n   - Execute `scripts/verify.sh` (clippy, fmt, tests, coverage)\n   - Fail the workflow if verification fails\n\n2. WHEN CI workflow runs THEN it SHALL:\n   - Cache Cargo dependencies for faster builds\n   - Cache npm dependencies (for keyrx_ui)\n   - Run on multiple platforms: `ubuntu-latest`, `windows-latest`\n   - Upload coverage reports to CI artifacts\n\n3. WHEN `.github/workflows/release.yml` is created THEN it SHALL:\n   - Run only on git tags matching `v*.*.*` (semver)\n   - Build release binaries for Linux (x86_64) and Windows (x86_64)\n   - Cross-compile using `cross` crate\n   - Create GitHub Release with binaries attached\n\n4. WHEN CI/CD workflows are created THEN they SHALL:\n   - Have clear job names (e.g., \"Clippy Lint\", \"Format Check\", \"Unit Tests\")\n   - Output structured logs readable by AI agents\n   - Include timeout limits (30 minutes max per job)\n\n### Requirement 6: Makefile Orchestration\n\n**User Story:** As an **AI coding agent**, I want **simple top-level commands**, so that **I can build/test/deploy without memorizing complex scripts**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN a `Makefile` is created THEN it SHALL define targets:\n   - `make build`: Run `scripts/build.sh`\n   - `make verify`: Run `scripts/verify.sh`\n   - `make test`: Run `scripts/test.sh`\n   - `make launch`: Run `scripts/launch.sh`\n   - `make clean`: Remove build artifacts (`target/`, `node_modules/`, `dist/`)\n   - `make setup`: Install pre-commit hooks and dev tools\n\n2. WHEN `make` is run without target THEN it SHALL:\n   - Run `make build` by default\n   - Output available targets with descriptions\n\n3. WHEN `make setup` is run THEN it SHALL:\n   - Install pre-commit hooks (via `scripts/setup_hooks.sh`)\n   - Install required tools: `cargo-watch`, `cargo-tarpaulin`, `cargo-fuzz`, `wasm-pack`\n   - Verify installations by checking versions\n   - Output success message\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility**: Each script does ONE thing (build, verify, test, launch)\n- **Modular Design**: Scripts can be composed (e.g., `verify.sh` calls `build.sh`)\n- **Clear Interfaces**: All scripts accept same flags (`--error`, `--json`, `--quiet`, `--log-file`)\n- **Idempotency**: Scripts can be run multiple times safely (e.g., `make setup`)\n\n### Performance\n\n- **Build Time**: Initial build <5 minutes on modern hardware\n- **Test Time**: All unit tests <30 seconds\n- **CI Time**: Full CI pipeline <10 minutes (with caching)\n- **Script Startup**: Script overhead <100ms (parsing args, setting up logs)\n\n### Reliability\n\n- **Exit Codes**: Scripts MUST return correct exit codes (0=success, 1=error, 2=warning)\n- **Atomicity**: Scripts either succeed completely or fail completely (no partial states)\n- **Error Messages**: All failures include actionable error messages\n- **Determinism**: Same inputs → same outputs (no randomness)\n\n### Usability (for AI Agents)\n\n- **Consistent Patterns**: All scripts follow same flag conventions\n- **Machine-Parseable**: JSON output mode for structured data\n- **Self-Documenting**: Scripts output usage help with `--help` flag\n- **Discoverable**: `scripts/CLAUDE.md` is the single source of truth\n\n### Security\n\n- **No Secrets in Logs**: Scripts MUST NOT log sensitive data (API keys, passwords)\n- **Safe Defaults**: Scripts run with least privileges (no unnecessary `sudo`)\n- **Input Validation**: Scripts validate all arguments before execution\n\n### Compatibility\n\n- **Linux**: Scripts work on Ubuntu 22.04+, Fedora 38+, Arch Linux (Bash 5+)\n- **Windows**: Scripts work on Windows 10+ (PowerShell 7+, or WSL with Bash)\n- **CI**: Scripts work in GitHub Actions Ubuntu and Windows runners\n",
  "fileStats": {
    "size": 14806,
    "lines": 322,
    "lastModified": "2025-12-21T04:53:12.190Z"
  },
  "comments": []
}