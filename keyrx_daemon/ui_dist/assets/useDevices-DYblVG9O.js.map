{"version":3,"file":"useDevices-DYblVG9O.js","sources":["../../src/api/devices.ts","../../src/hooks/useDevices.ts"],"sourcesContent":["/**\n * Device management API client\n */\n\nimport { apiClient } from './client';\nimport { validateApiResponse, DeviceListResponseSchema, DeviceEntrySchema } from './schemas';\nimport type { DeviceEntry, DeviceScope } from '../types';\n\ninterface RenameDeviceRequest {\n  name: string;\n}\n\ninterface SetScopeRequest {\n  scope: DeviceScope;\n}\n\ninterface DeviceResponse {\n  success: boolean;\n}\n\ninterface DevicesListResponse {\n  devices: DeviceEntry[];\n}\n\n/**\n * Fetch all connected devices\n */\nexport async function fetchDevices(): Promise<DeviceEntry[]> {\n  const response = await apiClient.get<DevicesListResponse>('/api/devices');\n  const validated = validateApiResponse(DeviceListResponseSchema, response, 'GET /api/devices');\n\n  // Map validated response to DeviceEntry format\n  // The REST API returns DeviceRpcInfo format (id, name, path, serial, active, scope?, layout?)\n  return validated.devices.map((device) => ({\n    id: device.id,\n    name: device.name,\n    path: device.path,\n    serial: device.serial || null,\n    active: device.active,\n    scope: device.scope === 'DeviceSpecific' ? 'device-specific' :\n           device.scope === 'Global' ? 'global' : 'global', // Default to global if unset\n    layout: device.layout || null,\n  }));\n}\n\n/**\n * Rename a device\n */\nexport async function renameDevice(\n  id: string,\n  name: string\n): Promise<DeviceResponse> {\n  const request: RenameDeviceRequest = { name };\n  const response = await apiClient.put<DeviceEntry>(`/api/devices/${id}/name`, request);\n  // Validate the returned device entry\n  validateApiResponse(DeviceEntrySchema, response, `PUT /api/devices/${id}/name`);\n  return { success: true };\n}\n\n/**\n * Set device scope (global or local)\n */\nexport async function setDeviceScope(\n  id: string,\n  scope: DeviceScope\n): Promise<DeviceResponse> {\n  const request: SetScopeRequest = { scope };\n  const response = await apiClient.put<DeviceEntry>(`/api/devices/${id}/scope`, request);\n  // Validate the returned device entry\n  validateApiResponse(DeviceEntrySchema, response, `PUT /api/devices/${id}/scope`);\n  return { success: true };\n}\n\n/**\n * Forget a device (remove from device list)\n */\nexport async function forgetDevice(id: string): Promise<DeviceResponse> {\n  const response = await apiClient.delete<DeviceEntry>(`/api/devices/${id}`);\n  // Validate the returned device entry\n  validateApiResponse(DeviceEntrySchema, response, `DELETE /api/devices/${id}`);\n  return { success: true };\n}\n","import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { queryKeys } from '../lib/queryClient';\nimport * as deviceApi from '../api/devices';\nimport type { DeviceEntry, DeviceScope } from '../types';\n\n/**\n * Fetch all devices with React Query caching\n */\nexport function useDevices() {\n  return useQuery({\n    queryKey: queryKeys.devices,\n    queryFn: deviceApi.fetchDevices,\n  });\n}\n\n/**\n * Rename a device with optimistic updates and cache invalidation\n */\nexport function useRenameDevice() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, name }: { id: string; name: string }) =>\n      deviceApi.renameDevice(id, name),\n\n    // Optimistic update: immediately update cache before API call\n    onMutate: async ({ id, name }) => {\n      // Cancel outgoing queries to avoid overwriting optimistic update\n      await queryClient.cancelQueries({ queryKey: queryKeys.devices });\n\n      // Snapshot previous value for rollback\n      const previousDevices = queryClient.getQueryData<DeviceEntry[]>(\n        queryKeys.devices\n      );\n\n      // Optimistically update cache\n      queryClient.setQueryData<DeviceEntry[]>(queryKeys.devices, (old) =>\n        old?.map((device) => (device.id === id ? { ...device, name } : device))\n      );\n\n      // Return context for rollback\n      return { previousDevices };\n    },\n\n    // Rollback on error\n    onError: (_error, _variables, context) => {\n      if (context?.previousDevices) {\n        queryClient.setQueryData(queryKeys.devices, context.previousDevices);\n      }\n    },\n\n    // Refetch on success to ensure data consistency\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: queryKeys.devices });\n    },\n  });\n}\n\n/**\n * Set device scope with optimistic updates\n */\nexport function useSetDeviceScope() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, scope }: { id: string; scope: DeviceScope }) =>\n      deviceApi.setDeviceScope(id, scope),\n\n    onMutate: async ({ id, scope }) => {\n      await queryClient.cancelQueries({ queryKey: queryKeys.devices });\n\n      const previousDevices = queryClient.getQueryData<DeviceEntry[]>(\n        queryKeys.devices\n      );\n\n      queryClient.setQueryData<DeviceEntry[]>(queryKeys.devices, (old) =>\n        old?.map((device) => (device.id === id ? { ...device, scope } : device))\n      );\n\n      return { previousDevices };\n    },\n\n    onError: (_error, _variables, context) => {\n      if (context?.previousDevices) {\n        queryClient.setQueryData(queryKeys.devices, context.previousDevices);\n      }\n    },\n\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: queryKeys.devices });\n    },\n  });\n}\n\n/**\n * Forget a device with optimistic updates\n */\nexport function useForgetDevice() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (id: string) => deviceApi.forgetDevice(id),\n\n    onMutate: async (id) => {\n      await queryClient.cancelQueries({ queryKey: queryKeys.devices });\n\n      const previousDevices = queryClient.getQueryData<DeviceEntry[]>(\n        queryKeys.devices\n      );\n\n      queryClient.setQueryData<DeviceEntry[]>(queryKeys.devices, (old) =>\n        old?.filter((device) => device.id !== id)\n      );\n\n      return { previousDevices };\n    },\n\n    onError: (_error, _variables, context) => {\n      if (context?.previousDevices) {\n        queryClient.setQueryData(queryKeys.devices, context.previousDevices);\n      }\n    },\n\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: queryKeys.devices });\n    },\n  });\n}\n"],"names":["async","fetchDevices","response","apiClient","get","validateApiResponse","DeviceListResponseSchema","devices","map","device","id","name","path","serial","active","scope","layout","useDevices","useQuery","queryKey","queryKeys","queryFn","deviceApi.fetchDevices"],"mappings":"sKA2BAA,eAAsBC,IACpB,MAAMC,QAAiBC,EAAUC,IAAyB,gBAK1D,OAJkBC,EAAoBC,EAA0BJ,EAAU,oBAIzDK,QAAQC,IAAKC,IAAA,CAC5BC,GAAID,EAAOC,GACXC,KAAMF,EAAOE,KACbC,KAAMH,EAAOG,KACbC,OAAQJ,EAAOI,QAAU,KACzBC,OAAQL,EAAOK,OACfC,MAAwB,mBAAjBN,EAAOM,MAA6B,mBACpCN,EAAOM,MAAqB,UACnCC,OAAQP,EAAOO,QAAU,OAE7B,CCnCO,SAASC,IACd,OAAOC,EAAS,CACdC,SAAUC,EAAUb,QACpBc,QAASC,GAEb"}