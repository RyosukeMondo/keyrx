{"version":3,"file":"useProfileConfig-B4iSMHmG.js","sources":["../../src/components/KeyButton.tsx","../../src/components/KeyboardVisualizer.tsx","../../src/utils/kle-parser.ts","../../src/utils/keyboard.ts","../../src/config/env.ts","../../src/hooks/useUnifiedApi.ts","../../src/types/rpc.ts","../../src/api/rpc.ts","../../src/hooks/useProfileConfig.ts"],"sourcesContent":["import React, { useMemo } from 'react';\nimport { Tooltip } from './Tooltip';\nimport { cn } from '../utils/cn';\nimport type { KeyMapping } from '@/types';\n\ninterface KeyButtonProps {\n  keyCode: string;\n  label: string;\n  mapping?: KeyMapping;\n  onClick: () => void;\n  isPressed?: boolean;\n  className?: string;\n}\n\nexport const KeyButton = React.memo<KeyButtonProps>(\n  ({ keyCode, label, mapping, onClick, isPressed = false, className = '' }) => {\n    const hasMapping = !!mapping;\n\n    const tooltipContent = useMemo(() => {\n      if (!mapping) return `${keyCode} (Default)`;\n\n      switch (mapping.type) {\n        case 'simple':\n          return `${keyCode} → ${mapping.tapAction}`;\n        case 'tap_hold':\n          return `${keyCode} → Tap: ${mapping.tapAction}, Hold: ${mapping.holdAction} (${mapping.threshold}ms)`;\n        case 'macro':\n          return `${keyCode} → Macro (${mapping.macroSteps?.length || 0} steps)`;\n        case 'layer_switch':\n          return `${keyCode} → Layer: ${mapping.targetLayer}`;\n        default:\n          return `${keyCode} (Default)`;\n      }\n    }, [keyCode, mapping]);\n\n    // Get remap display text\n    const remapText = useMemo(() => {\n      if (!mapping) return '';\n\n      switch (mapping.type) {\n        case 'simple':\n          return mapping.tapAction || '';\n        case 'tap_hold':\n          return `T:${mapping.tapAction} H:${mapping.holdAction}`;\n        case 'macro':\n          return 'MACRO';\n        case 'layer_switch':\n          return mapping.targetLayer || '';\n        default:\n          return '';\n      }\n    }, [mapping]);\n\n    // Determine border and background color based on mapping type\n    const getKeyStyle = () => {\n      if (!mapping) return {\n        border: 'border-slate-600',\n        bg: 'bg-slate-700',\n      };\n\n      switch (mapping.type) {\n        case 'simple':\n          return {\n            border: 'border-green-500',\n            bg: 'bg-slate-700',\n          };\n        case 'tap_hold':\n          return {\n            border: 'border-red-500',\n            bg: 'bg-red-900/15',\n          };\n        case 'macro':\n          return {\n            border: 'border-purple-500',\n            bg: 'bg-purple-900/15',\n          };\n        case 'layer_switch':\n          return {\n            border: 'border-yellow-500',\n            bg: 'bg-yellow-900/15',\n          };\n        default:\n          return {\n            border: 'border-slate-600',\n            bg: 'bg-slate-700',\n          };\n      }\n    };\n\n    const style = getKeyStyle();\n\n    return (\n      <Tooltip content={tooltipContent}>\n        <button\n          onClick={onClick}\n          aria-label={`Key ${keyCode}. Current mapping: ${tooltipContent}. Click to configure.`}\n          className={cn(\n            'relative flex flex-col items-center justify-center',\n            'rounded border transition-all duration-150',\n            'hover:brightness-110 hover:-translate-y-0.5',\n            'focus:outline focus:outline-2 focus:outline-primary-500',\n            'min-h-[50px]',\n            style.border,\n            style.bg,\n            isPressed && 'bg-green-500 border-green-400',\n            className\n          )}\n          style={{\n            aspectRatio: '1',\n          }}\n        >\n          {/* Original key label (small, gray) */}\n          <span className=\"text-[10px] text-slate-400 font-mono\">\n            {label}\n          </span>\n\n          {/* Remap label (bold, yellow) */}\n          {hasMapping && (\n            <span className=\"text-[12px] text-yellow-300 font-bold font-mono mt-0.5\">\n              {remapText}\n            </span>\n          )}\n        </button>\n      </Tooltip>\n    );\n  }\n);\n\nKeyButton.displayName = 'KeyButton';\n","import React, { useMemo, useRef } from 'react';\nimport { useDroppable } from '@dnd-kit/core';\nimport { KeyButton } from './KeyButton';\nimport type { KeyMapping } from '@/types';\nimport { parseKLEJson } from '../utils/kle-parser';\nimport { cn } from '../utils/cn';\nimport { useArrowNavigation } from '../utils/keyboard';\nimport type { AssignableKey } from './KeyAssignmentPanel';\n\n// Import layout data\nimport ANSI_104 from '../data/layouts/ANSI_104.json';\n\ninterface KeyboardVisualizerProps {\n  layout: 'ANSI_104' | 'ISO_105' | 'JIS_109' | 'HHKB' | 'NUMPAD';\n  keyMappings: Map<string, KeyMapping>;\n  onKeyClick: (keyCode: string) => void;\n  onKeyDrop?: (keyCode: string, droppedKey: AssignableKey) => void;\n  simulatorMode?: boolean;\n  pressedKeys?: Set<string>;\n  className?: string;\n}\n\nconst layoutData = {\n  ANSI_104,\n  // TODO: Add other layouts when needed\n  ISO_105: ANSI_104, // Placeholder\n  JIS_109: ANSI_104, // Placeholder\n  HHKB: ANSI_104, // Placeholder\n  NUMPAD: ANSI_104, // Placeholder\n};\n\ninterface DroppableKeyWrapperProps {\n  keyCode: string;\n  label: string;\n  mapping?: KeyMapping;\n  isPressed: boolean;\n  onClick: () => void;\n  onDrop?: (droppedKey: AssignableKey) => void;\n  disabled?: boolean;\n}\n\n/**\n * Wrapper component for individual keys that makes them droppable zones\n */\nconst DroppableKeyWrapper: React.FC<DroppableKeyWrapperProps> = ({\n  keyCode,\n  label,\n  mapping,\n  isPressed,\n  onClick,\n  onDrop,\n  disabled = false,\n}) => {\n  const { setNodeRef, isOver } = useDroppable({\n    id: `drop-${keyCode}`,\n    data: { keyCode },\n    disabled,\n  });\n\n  const handleClick = () => {\n    if (!disabled) {\n      onClick();\n    }\n  };\n\n  // Build comprehensive aria-label for drop zone\n  const mappingDescription = mapping\n    ? `Currently mapped to ${mapping.tapAction || 'custom action'}`\n    : 'No mapping assigned';\n\n  const ariaLabel = disabled\n    ? `${label} key. ${mappingDescription}. Not configurable.`\n    : `${label} key. ${mappingDescription}. Drop zone for key assignment. ${isOver ? 'Drop here to assign' : ''}`;\n\n  return (\n    <div\n      ref={setNodeRef}\n      className={cn(\n        'relative',\n        isOver && !disabled && 'ring-2 ring-primary-500 ring-offset-2 ring-offset-slate-800'\n      )}\n      aria-label={ariaLabel}\n      aria-dropeffect={disabled ? 'none' : isOver ? 'move' : 'none'}\n    >\n      <KeyButton\n        keyCode={keyCode}\n        label={label}\n        mapping={mapping}\n        onClick={handleClick}\n        isPressed={isPressed}\n        className={cn(\n          disabled && 'opacity-50 cursor-not-allowed'\n        )}\n      />\n    </div>\n  );\n};\n\nDroppableKeyWrapper.displayName = 'DroppableKeyWrapper';\n\nexport const KeyboardVisualizer: React.FC<KeyboardVisualizerProps> = ({\n  layout,\n  keyMappings,\n  onKeyClick,\n  onKeyDrop,\n  simulatorMode = false,\n  pressedKeys = new Set(),\n  className = '',\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const keyButtons = useMemo(() => {\n    const kleData = layoutData[layout];\n    return parseKLEJson(kleData);\n  }, [layout]);\n\n  // Calculate grid dimensions\n  const maxRow = useMemo(\n    () => Math.max(...keyButtons.map((k) => k.gridRow)),\n    [keyButtons]\n  );\n  const maxCol = useMemo(\n    () =>\n      Math.max(...keyButtons.map((k) => k.gridColumn + k.gridColumnSpan - 1)),\n    [keyButtons]\n  );\n\n  // Enable arrow key navigation for keyboard keys\n  useArrowNavigation(containerRef, {\n    orientation: 'horizontal',\n    loop: true,\n  });\n\n  const handleKeyDrop = (keyCode: string) => (droppedKey: AssignableKey) => {\n    if (onKeyDrop) {\n      onKeyDrop(keyCode, droppedKey);\n    }\n  };\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn('keyboard-grid', className)}\n      role=\"group\"\n      aria-label={`${layout} keyboard layout${simulatorMode ? ' (simulator mode)' : ''}. Use arrow keys to navigate between keys, Enter to select.`}\n      style={{\n        display: 'grid',\n        gridTemplateRows: `repeat(${maxRow}, 52px)`,\n        gridTemplateColumns: `repeat(${maxCol}, 52px)`,\n        gap: '2px',\n        padding: '16px',\n        backgroundColor: 'var(--color-bg-secondary)',\n        borderRadius: '12px',\n      }}\n    >\n      {keyButtons.map((key) => (\n        <div\n          key={key.keyCode}\n          style={{\n            gridRow: key.gridRow,\n            gridColumn: `${key.gridColumn} / span ${key.gridColumnSpan}`,\n          }}\n        >\n          <DroppableKeyWrapper\n            keyCode={key.keyCode}\n            label={key.label}\n            mapping={keyMappings.get(key.keyCode)}\n            onClick={() => onKeyClick(key.keyCode)}\n            onDrop={handleKeyDrop(key.keyCode)}\n            isPressed={pressedKeys.has(key.keyCode)}\n            disabled={simulatorMode}\n          />\n        </div>\n      ))}\n    </div>\n  );\n};\n","/**\n * KLE (Keyboard Layout Editor) JSON Parser\n * Converts layout data into renderable KeyButton objects with grid positioning\n */\n\nexport interface KLEKey {\n  code: string;\n  label: string;\n  x: number;\n  y: number;\n  w?: number;\n}\n\nexport interface KLEData {\n  name: string;\n  keys: KLEKey[];\n}\n\nexport interface KeyButton {\n  keyCode: string;\n  label: string;\n  gridRow: number;\n  gridColumn: number;\n  gridColumnSpan: number;\n  width: number;\n}\n\n/**\n * Parse KLE JSON data into KeyButton objects for grid layout\n * @param kleData - Keyboard layout data from JSON\n * @returns Array of KeyButton objects with grid positioning\n */\nexport function parseKLEJson(kleData: KLEData): KeyButton[] {\n  return kleData.keys.map((key) => ({\n    keyCode: key.code,\n    label: key.label,\n    gridRow: Math.floor(key.y) + 1, // 1-indexed for CSS Grid\n    gridColumn: Math.floor(key.x) + 1,\n    gridColumnSpan: Math.ceil(key.w || 1),\n    width: key.w || 1,\n  }));\n}\n","/**\n * Keyboard Navigation Utilities\n *\n * Helper functions and hooks for keyboard navigation,\n * accessibility, and focus management.\n */\n\nimport { useEffect, useCallback, RefObject } from 'react';\n\n/**\n * Common keyboard keys\n */\nexport const Keys = {\n  ENTER: 'Enter',\n  ESCAPE: 'Escape',\n  SPACE: ' ',\n  TAB: 'Tab',\n  ARROW_UP: 'ArrowUp',\n  ARROW_DOWN: 'ArrowDown',\n  ARROW_LEFT: 'ArrowLeft',\n  ARROW_RIGHT: 'ArrowRight',\n  HOME: 'Home',\n  END: 'End',\n  PAGE_UP: 'PageUp',\n  PAGE_DOWN: 'PageDown',\n} as const;\n\n/**\n * Check if an element is focusable\n */\nexport function isFocusable(element: HTMLElement): boolean {\n  const focusableSelectors = [\n    'a[href]',\n    'button:not([disabled])',\n    'textarea:not([disabled])',\n    'input:not([disabled])',\n    'select:not([disabled])',\n    '[tabindex]:not([tabindex=\"-1\"])',\n  ];\n\n  return focusableSelectors.some((selector) => element.matches(selector));\n}\n\n/**\n * Get all focusable elements within a container\n */\nexport function getFocusableElements(\n  container: HTMLElement\n): HTMLElement[] {\n  const selector = [\n    'a[href]',\n    'button:not([disabled])',\n    'textarea:not([disabled])',\n    'input:not([disabled])',\n    'select:not([disabled])',\n    '[tabindex]:not([tabindex=\"-1\"])',\n  ].join(', ');\n\n  return Array.from(container.querySelectorAll<HTMLElement>(selector));\n}\n\n/**\n * Focus the first focusable element in a container\n */\nexport function focusFirst(container: HTMLElement): void {\n  const elements = getFocusableElements(container);\n  elements[0]?.focus();\n}\n\n/**\n * Focus the last focusable element in a container\n */\nexport function focusLast(container: HTMLElement): void {\n  const elements = getFocusableElements(container);\n  elements[elements.length - 1]?.focus();\n}\n\n/**\n * Hook to handle Escape key\n */\nexport function useEscapeKey(onEscape: () => void, enabled = true): void {\n  useEffect(() => {\n    if (!enabled) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === Keys.ESCAPE) {\n        onEscape();\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [onEscape, enabled]);\n}\n\n/**\n * Hook to handle arrow key navigation in a list\n */\nexport function useArrowNavigation(\n  containerRef: RefObject<HTMLElement>,\n  options: {\n    orientation?: 'vertical' | 'horizontal';\n    loop?: boolean;\n    onEnter?: (index: number) => void;\n  } = {}\n): void {\n  const { orientation = 'vertical', loop = true, onEnter } = options;\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      const focusableElements = getFocusableElements(container);\n      const currentIndex = focusableElements.findIndex(\n        (el) => el === document.activeElement\n      );\n\n      if (currentIndex === -1) return;\n\n      const isVertical = orientation === 'vertical';\n      const nextKey = isVertical ? Keys.ARROW_DOWN : Keys.ARROW_RIGHT;\n      const prevKey = isVertical ? Keys.ARROW_UP : Keys.ARROW_LEFT;\n\n      let nextIndex = currentIndex;\n\n      if (event.key === nextKey) {\n        event.preventDefault();\n        nextIndex = currentIndex + 1;\n        if (nextIndex >= focusableElements.length) {\n          nextIndex = loop ? 0 : focusableElements.length - 1;\n        }\n      } else if (event.key === prevKey) {\n        event.preventDefault();\n        nextIndex = currentIndex - 1;\n        if (nextIndex < 0) {\n          nextIndex = loop ? focusableElements.length - 1 : 0;\n        }\n      } else if (event.key === Keys.HOME) {\n        event.preventDefault();\n        nextIndex = 0;\n      } else if (event.key === Keys.END) {\n        event.preventDefault();\n        nextIndex = focusableElements.length - 1;\n      } else if (event.key === Keys.ENTER && onEnter) {\n        event.preventDefault();\n        onEnter(currentIndex);\n        return;\n      }\n\n      if (nextIndex !== currentIndex) {\n        focusableElements[nextIndex]?.focus();\n      }\n    };\n\n    container.addEventListener('keydown', handleKeyDown);\n    return () => container.removeEventListener('keydown', handleKeyDown);\n  }, [containerRef, orientation, loop, onEnter]);\n}\n\n/**\n * Hook to trap focus within a container (for modals, dialogs)\n */\nexport function useFocusTrap(\n  containerRef: RefObject<HTMLElement>,\n  enabled = true\n): void {\n  useEffect(() => {\n    if (!enabled) return;\n\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key !== Keys.TAB) return;\n\n      const focusableElements = getFocusableElements(container);\n      const firstElement = focusableElements[0];\n      const lastElement = focusableElements[focusableElements.length - 1];\n\n      if (event.shiftKey) {\n        // Shift + Tab\n        if (document.activeElement === firstElement) {\n          event.preventDefault();\n          lastElement?.focus();\n        }\n      } else {\n        // Tab\n        if (document.activeElement === lastElement) {\n          event.preventDefault();\n          firstElement?.focus();\n        }\n      }\n    };\n\n    container.addEventListener('keydown', handleKeyDown);\n    return () => container.removeEventListener('keydown', handleKeyDown);\n  }, [containerRef, enabled]);\n}\n\n/**\n * Hook to restore focus when component unmounts\n */\nexport function useRestoreFocus(enabled = true): () => void {\n  const previousElement = useCallback(() => {\n    if (!enabled) return;\n    const activeElement = document.activeElement as HTMLElement;\n    return activeElement;\n  }, [enabled]);\n\n  return useCallback(() => {\n    const element = previousElement();\n    if (element && enabled) {\n      element.focus();\n    }\n  }, [previousElement, enabled]);\n}\n\n/**\n * Create keyboard event handler\n */\nexport function createKeyboardHandler(\n  handlers: Record<string, (event: React.KeyboardEvent) => void>\n) {\n  return (event: React.KeyboardEvent) => {\n    const handler = handlers[event.key];\n    if (handler) {\n      handler(event);\n    }\n  };\n}\n\n/**\n * Check if an event should trigger a button click\n * (Space or Enter keys)\n */\nexport function isClickKey(event: React.KeyboardEvent): boolean {\n  return event.key === Keys.ENTER || event.key === Keys.SPACE;\n}\n\n/**\n * Prevent default for click keys\n */\nexport function preventDefaultForClickKeys(\n  event: React.KeyboardEvent\n): void {\n  if (isClickKey(event)) {\n    event.preventDefault();\n  }\n}\n\n/**\n * CSS class for focus-visible outline\n */\nexport const focusVisibleClass =\n  'focus:outline focus:outline-2 focus:outline-primary-500 focus:outline-offset-2';\n\n/**\n * CSS class for focus-visible outline (within parent)\n */\nexport const focusVisibleWithinClass =\n  'focus-within:outline focus-within:outline-2 focus-within:outline-primary-500 focus-within:outline-offset-2';\n","/**\n * Environment Configuration\n * Type-safe access to Vite environment variables\n */\n\ninterface ImportMetaEnv {\n  readonly VITE_API_URL: string;\n  readonly VITE_WS_URL: string;\n  readonly VITE_DEBUG: string;\n  readonly VITE_ENV: string;\n  readonly MODE: string;\n  readonly DEV: boolean;\n  readonly PROD: boolean;\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\n\n/**\n * Get the API base URL\n * In production, uses relative URL (same origin)\n * In development, uses configured URL or localhost\n */\nexport function getApiUrl(): string {\n  const configuredUrl = import.meta.env.VITE_API_URL;\n\n  // In production, if no URL configured, use same origin\n  if (import.meta.env.PROD && !configuredUrl) {\n    return window.location.origin;\n  }\n\n  // In development or if explicitly configured, use the configured URL\n  return configuredUrl || 'http://localhost:9867';\n}\n\n/**\n * Get the WebSocket URL\n * In production, uses relative WebSocket URL (same origin)\n * In development, uses configured URL or localhost\n */\nexport function getWsUrl(): string {\n  const configuredUrl = import.meta.env.VITE_WS_URL;\n\n  // In production, if no URL configured, use same origin with ws/wss protocol\n  if (import.meta.env.PROD && !configuredUrl) {\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    return `${protocol}//${window.location.host}/ws-rpc`;\n  }\n\n  // In development or if explicitly configured, use the configured URL\n  return configuredUrl || 'ws://localhost:9867/ws-rpc';\n}\n\n/**\n * Check if debug mode is enabled\n */\nexport function isDebugMode(): boolean {\n  return import.meta.env.VITE_DEBUG === 'true' || import.meta.env.DEV;\n}\n\n/**\n * Get the current environment\n */\nexport function getEnvironment(): 'development' | 'production' {\n  return import.meta.env.PROD ? 'production' : 'development';\n}\n\n/**\n * Environment configuration object\n */\nexport const env = {\n  apiUrl: getApiUrl(),\n  wsUrl: getWsUrl(),\n  debug: isDebugMode(),\n  environment: getEnvironment(),\n  isDev: import.meta.env.DEV,\n  isProd: import.meta.env.PROD,\n} as const;\n\n// Log configuration in debug mode\nif (isDebugMode()) {\n  console.log('[ENV] Configuration:', {\n    apiUrl: env.apiUrl,\n    wsUrl: env.wsUrl,\n    environment: env.environment,\n    debug: env.debug,\n  });\n}\n","/**\n * useUnifiedApi - React hook for WebSocket RPC communication\n *\n * This hook provides a unified API for WebSocket-based RPC communication with the daemon.\n * It handles connection management, request/response correlation, subscriptions, and auto-reconnect.\n *\n * Features:\n * - Request/response correlation via UUID\n * - 30-second timeout for all requests\n * - Auto-reconnect (3s interval, 10 max attempts)\n * - Type-safe query/command methods\n * - Subscription management with cleanup\n * - Connection state tracking\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const api = useUnifiedApi();\n *\n *   // Query example\n *   const profiles = await api.query('get_profiles');\n *\n *   // Command example\n *   await api.command('activate_profile', { name: 'Gaming' });\n *\n *   // Subscription example\n *   useEffect(() => {\n *     return api.subscribe('daemon-state', (state) => {\n *       console.log('State changed:', state);\n *     });\n *   }, []);\n * }\n * ```\n */\n\nimport { useEffect, useRef, useCallback, useState } from 'react';\nimport useWebSocket, { ReadyState } from 'react-use-websocket';\nimport { v4 as uuidv4 } from 'uuid';\nimport { env } from '../config/env';\nimport { validateRpcMessage } from '../api/schemas';\nimport type {\n  ClientMessage,\n  ServerMessage,\n  RpcMethod,\n  SubscriptionChannel,\n  RpcError,\n  isResponse,\n  isEvent,\n  isConnected,\n} from '../types/rpc';\n\n// Import type guards\nimport {\n  isResponse as checkIsResponse,\n  isEvent as checkIsEvent,\n  isConnected as checkIsConnected,\n} from '../types/rpc';\n\nconst REQUEST_TIMEOUT_MS = 30000; // 30 seconds\nconst RECONNECT_INTERVAL_MS = 3000; // 3 seconds\nconst MAX_RECONNECT_ATTEMPTS = 10;\n\n/**\n * Pending request structure for tracking in-flight requests\n */\ninterface PendingRequest {\n  resolve: (value: unknown) => void;\n  reject: (error: Error) => void;\n  timeoutId: NodeJS.Timeout;\n}\n\n/**\n * Subscription handler function type\n */\ntype SubscriptionHandler = (data: unknown) => void;\n\n/**\n * Hook return type\n */\nexport interface UseUnifiedApiReturn {\n  /** Execute a query (read-only) RPC method */\n  query: <T = unknown>(method: RpcMethod, params?: unknown) => Promise<T>;\n  /** Execute a command (state-modifying) RPC method */\n  command: <T = unknown>(method: RpcMethod, params?: unknown) => Promise<T>;\n  /** Subscribe to a channel for real-time updates */\n  subscribe: (channel: SubscriptionChannel, handler: SubscriptionHandler) => () => void;\n  /** Unsubscribe from a channel */\n  unsubscribe: (channel: SubscriptionChannel) => void;\n  /** Current WebSocket connection state */\n  readyState: ReadyState;\n  /** Whether the WebSocket is connected and handshake completed */\n  isConnected: boolean;\n  /** Last error that occurred */\n  lastError: Error | null;\n}\n\n/**\n * React hook for unified WebSocket RPC API\n *\n * @param url - Optional WebSocket URL (defaults to env.wsUrl)\n * @returns API methods and connection state\n */\nexport function useUnifiedApi(url?: string): UseUnifiedApiReturn {\n  const wsUrl = url || env.wsUrl;\n\n  // Connection state\n  const [isConnected, setIsConnected] = useState(false);\n  const [lastError, setLastError] = useState<Error | null>(null);\n\n  // Use useRef for mutable tracking (not useState to avoid re-renders)\n  const pendingRequests = useRef<Map<string, PendingRequest>>(new Map());\n  const subscriptions = useRef<Map<SubscriptionChannel, Set<SubscriptionHandler>>>(new Map());\n\n  // WebSocket connection with auto-reconnect\n  const { sendMessage, lastMessage, readyState } = useWebSocket(wsUrl, {\n    shouldReconnect: () => true,\n    reconnectInterval: RECONNECT_INTERVAL_MS,\n    reconnectAttempts: MAX_RECONNECT_ATTEMPTS,\n    onError: (event) => {\n      console.error('[useUnifiedApi] WebSocket error:', event);\n      setLastError(new Error('WebSocket connection error'));\n      setIsConnected(false);\n    },\n    onClose: () => {\n      console.log('[useUnifiedApi] WebSocket closed');\n      setIsConnected(false);\n\n      // Reject all pending requests on disconnect\n      pendingRequests.current.forEach((pending, id) => {\n        clearTimeout(pending.timeoutId);\n        pending.reject(new Error('WebSocket connection closed'));\n      });\n      pendingRequests.current.clear();\n    },\n  });\n\n  // Handle incoming messages\n  useEffect(() => {\n    if (!lastMessage?.data) return;\n\n    try {\n      const parsedData = JSON.parse(lastMessage.data);\n\n      // Validate incoming server message\n      let message: ServerMessage;\n      try {\n        message = validateRpcMessage(parsedData, 'server');\n      } catch (validationError) {\n        console.error('[useUnifiedApi] Message validation failed:', validationError);\n        setLastError(validationError instanceof Error ? validationError : new Error('Message validation failed'));\n        return;\n      }\n\n      // Handle Connected handshake\n      if (checkIsConnected(message)) {\n        console.log('[useUnifiedApi] Connected:', message);\n        setIsConnected(true);\n        setLastError(null);\n        return;\n      }\n\n      // Handle Response messages\n      if (checkIsResponse(message)) {\n        const pending = pendingRequests.current.get(message.id);\n        if (pending) {\n          clearTimeout(pending.timeoutId);\n          pendingRequests.current.delete(message.id);\n\n          if (message.error) {\n            pending.reject(new Error(message.error.message));\n          } else {\n            pending.resolve(message.result);\n          }\n        } else {\n          console.warn('[useUnifiedApi] Received response for unknown request:', message.id);\n        }\n        return;\n      }\n\n      // Handle Event messages (broadcasts)\n      if (checkIsEvent(message)) {\n        const handlers = subscriptions.current.get(message.channel);\n        if (handlers) {\n          handlers.forEach((handler) => {\n            try {\n              handler(message.data);\n            } catch (error) {\n              console.error('[useUnifiedApi] Subscription handler error:', error);\n            }\n          });\n        }\n        return;\n      }\n\n      // Handle legacy DaemonEvent format (backward compatibility)\n      // Old format: { type: \"latency\", payload: {...} }\n      // New format: { type: \"event\", channel: \"latency\", data: {...} }\n      const anyMessage = message as any;\n      if (anyMessage.type && anyMessage.payload && anyMessage.type !== 'response' && anyMessage.type !== 'connected') {\n        const legacyType = anyMessage.type as string;\n        const legacyPayload = anyMessage.payload;\n\n        // Map legacy event type to channel name\n        const channelMap: Record<string, string> = {\n          'latency': 'latency',\n          'state': 'daemon-state',\n          'event': 'events',\n          'heartbeat': 'heartbeat', // Ignore heartbeats\n        };\n\n        const channel = channelMap[legacyType];\n        if (channel && channel !== 'heartbeat') {\n          const handlers = subscriptions.current.get(channel as SubscriptionChannel);\n          if (handlers) {\n            handlers.forEach((handler) => {\n              try {\n                handler(legacyPayload);\n              } catch (error) {\n                console.error('[useUnifiedApi] Subscription handler error:', error);\n              }\n            });\n          }\n        }\n        return;\n      }\n\n      console.warn('[useUnifiedApi] Unknown message type:', message);\n    } catch (error) {\n      console.error('[useUnifiedApi] Failed to parse message:', error);\n      setLastError(error instanceof Error ? error : new Error('Failed to parse message'));\n    }\n  }, [lastMessage]);\n\n  /**\n   * Send a request and return a promise that resolves with the response\n   */\n  const sendRequest = useCallback(\n    <T = unknown>(message: ClientMessage): Promise<T> => {\n      return new Promise((resolve, reject) => {\n        if (readyState !== ReadyState.OPEN) {\n          reject(new Error('WebSocket is not connected'));\n          return;\n        }\n\n        const id = message.id;\n\n        // Setup timeout\n        const timeoutId = setTimeout(() => {\n          pendingRequests.current.delete(id);\n          reject(new Error(`Request timeout after ${REQUEST_TIMEOUT_MS}ms`));\n        }, REQUEST_TIMEOUT_MS);\n\n        // Store pending request\n        pendingRequests.current.set(id, {\n          resolve: resolve as (value: unknown) => void,\n          reject,\n          timeoutId,\n        });\n\n        // Validate outgoing client message\n        try {\n          validateRpcMessage(message, 'client');\n        } catch (validationError) {\n          clearTimeout(timeoutId);\n          pendingRequests.current.delete(id);\n          console.error('[useUnifiedApi] Outgoing message validation failed:', validationError);\n          reject(validationError instanceof Error ? validationError : new Error('Message validation failed'));\n          return;\n        }\n\n        // Send message\n        try {\n          sendMessage(JSON.stringify(message));\n        } catch (error) {\n          clearTimeout(timeoutId);\n          pendingRequests.current.delete(id);\n          reject(error);\n        }\n      });\n    },\n    [readyState, sendMessage]\n  );\n\n  /**\n   * Execute a query (read-only) RPC method\n   */\n  const query = useCallback(\n    <T = unknown>(method: RpcMethod, params?: unknown): Promise<T> => {\n      const id = uuidv4();\n      const message: ClientMessage = {\n        type: 'query',\n        id,\n        method,\n        params,\n      };\n      return sendRequest<T>(message);\n    },\n    [sendRequest]\n  );\n\n  /**\n   * Execute a command (state-modifying) RPC method\n   */\n  const command = useCallback(\n    <T = unknown>(method: RpcMethod, params?: unknown): Promise<T> => {\n      const id = uuidv4();\n      const message: ClientMessage = {\n        type: 'command',\n        id,\n        method,\n        params,\n      };\n      return sendRequest<T>(message);\n    },\n    [sendRequest]\n  );\n\n  /**\n   * Subscribe to a channel for real-time updates\n   *\n   * @param channel - Channel to subscribe to\n   * @param handler - Function to call when events are received\n   * @returns Unsubscribe function\n   */\n  const subscribe = useCallback(\n    (channel: SubscriptionChannel, handler: SubscriptionHandler): (() => void) => {\n      // Add handler to subscriptions\n      let handlers = subscriptions.current.get(channel);\n      if (!handlers) {\n        handlers = new Set();\n        subscriptions.current.set(channel, handlers);\n      }\n\n      const isFirstSubscriber = handlers.size === 0;\n      handlers.add(handler);\n\n      // Send subscribe message to server if this is the first subscriber\n      if (isFirstSubscriber && readyState === ReadyState.OPEN) {\n        const id = uuidv4();\n        const message: ClientMessage = {\n          type: 'subscribe',\n          id,\n          channel,\n        };\n        sendMessage(JSON.stringify(message));\n      }\n\n      // Return unsubscribe function\n      return () => {\n        const handlers = subscriptions.current.get(channel);\n        if (handlers) {\n          handlers.delete(handler);\n\n          // If no more handlers, send unsubscribe message to server\n          if (handlers.size === 0) {\n            subscriptions.current.delete(channel);\n            if (readyState === ReadyState.OPEN) {\n              const id = uuidv4();\n              const message: ClientMessage = {\n                type: 'unsubscribe',\n                id,\n                channel,\n              };\n              sendMessage(JSON.stringify(message));\n            }\n          }\n        }\n      };\n    },\n    [readyState, sendMessage]\n  );\n\n  /**\n   * Unsubscribe from a channel (all handlers)\n   */\n  const unsubscribe = useCallback(\n    (channel: SubscriptionChannel): void => {\n      const handlers = subscriptions.current.get(channel);\n      if (handlers) {\n        subscriptions.current.delete(channel);\n\n        // Send unsubscribe message to server\n        if (readyState === ReadyState.OPEN) {\n          const id = uuidv4();\n          const message: ClientMessage = {\n            type: 'unsubscribe',\n            id,\n            channel,\n          };\n          sendMessage(JSON.stringify(message));\n        }\n      }\n    },\n    [readyState, sendMessage]\n  );\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      // Clear all pending requests\n      pendingRequests.current.forEach((pending) => {\n        clearTimeout(pending.timeoutId);\n        pending.reject(new Error('Component unmounted'));\n      });\n      pendingRequests.current.clear();\n\n      // Unsubscribe from all channels\n      subscriptions.current.forEach((_, channel) => {\n        if (readyState === ReadyState.OPEN) {\n          const id = uuidv4();\n          const message: ClientMessage = {\n            type: 'unsubscribe',\n            id,\n            channel,\n          };\n          try {\n            sendMessage(JSON.stringify(message));\n          } catch (error) {\n            console.error('[useUnifiedApi] Failed to send unsubscribe on unmount:', error);\n          }\n        }\n      });\n      subscriptions.current.clear();\n    };\n  }, [readyState, sendMessage]);\n\n  return {\n    query,\n    command,\n    subscribe,\n    unsubscribe,\n    readyState,\n    isConnected,\n    lastError,\n  };\n}\n","/**\n * TypeScript RPC types matching the Rust WebSocket RPC protocol.\n *\n * This module defines type-safe message types for WebSocket RPC communication\n * between the frontend and daemon. All types match their Rust counterparts\n * defined in keyrx_daemon/src/web/rpc_types.rs exactly.\n */\n\n// JSON-RPC 2.0 standard error codes\nexport const PARSE_ERROR = -32700;\nexport const INVALID_REQUEST = -32600;\nexport const METHOD_NOT_FOUND = -32601;\nexport const INVALID_PARAMS = -32602;\nexport const INTERNAL_ERROR = -32603;\n\n/**\n * All available RPC method names.\n * Query methods are read-only operations.\n * Command methods modify state.\n */\nexport type RpcMethod =\n  // Query methods (read-only)\n  | \"get_profiles\"\n  | \"get_devices\"\n  | \"get_config\"\n  | \"get_layers\"\n  | \"get_latency\"\n  | \"get_events\"\n  | \"get_profile_config\"\n  | \"get_active_profile\"\n  // Command methods (state-modifying)\n  | \"create_profile\"\n  | \"activate_profile\"\n  | \"delete_profile\"\n  | \"duplicate_profile\"\n  | \"rename_profile\"\n  | \"rename_device\"\n  | \"set_scope_device\"\n  | \"forget_device\"\n  | \"update_config\"\n  | \"set_key_mapping\"\n  | \"delete_key_mapping\"\n  | \"clear_events\"\n  | \"simulate\"\n  | \"reset_simulator\"\n  | \"set_profile_config\"\n  | \"set_device_layout\";\n\n/**\n * Available subscription channels for real-time updates.\n */\nexport type SubscriptionChannel = \"daemon-state\" | \"events\" | \"latency\";\n\n/**\n * Messages sent from client to server.\n * Uses discriminated union with 'type' field for type safety.\n */\nexport type ClientMessage =\n  | {\n      /** Message type discriminator */\n      type: \"query\";\n      /** Unique identifier for request/response correlation */\n      id: string;\n      /** Method name to invoke */\n      method: RpcMethod;\n      /** Optional parameters for the method */\n      params?: unknown;\n    }\n  | {\n      /** Message type discriminator */\n      type: \"command\";\n      /** Unique identifier for request/response correlation */\n      id: string;\n      /** Method name to invoke */\n      method: RpcMethod;\n      /** Optional parameters for the method */\n      params?: unknown;\n    }\n  | {\n      /** Message type discriminator */\n      type: \"subscribe\";\n      /** Unique identifier for request/response correlation */\n      id: string;\n      /** Channel name to subscribe to */\n      channel: SubscriptionChannel;\n    }\n  | {\n      /** Message type discriminator */\n      type: \"unsubscribe\";\n      /** Unique identifier for request/response correlation */\n      id: string;\n      /** Channel name to unsubscribe from */\n      channel: SubscriptionChannel;\n    };\n\n/**\n * Messages sent from server to client.\n * Uses discriminated union with 'type' field for type safety.\n */\nexport type ServerMessage =\n  | {\n      /** Message type discriminator */\n      type: \"response\";\n      /** Request ID this response corresponds to */\n      id: string;\n      /** Result data (success) - only present if no error */\n      result?: unknown;\n      /** Error information (failure) - only present if error occurred */\n      error?: RpcError;\n    }\n  | {\n      /** Message type discriminator */\n      type: \"event\";\n      /** Channel this event was published on */\n      channel: SubscriptionChannel;\n      /** Event data */\n      data: unknown;\n    }\n  | {\n      /** Message type discriminator */\n      type: \"connected\";\n      /** Protocol version */\n      version: string;\n      /** Server timestamp in microseconds since UNIX epoch */\n      timestamp: number;\n    };\n\n/**\n * RPC error structure following JSON-RPC 2.0 conventions.\n */\nexport interface RpcError {\n  /** Numeric error code */\n  code: number;\n  /** Human-readable error message */\n  message: string;\n  /** Optional additional error data */\n  data?: unknown;\n}\n\n/**\n * Current daemon state snapshot.\n * Broadcast on \"daemon-state\" channel when state changes.\n */\nexport interface DaemonState {\n  /** Active modifier IDs (e.g., [\"MD_00\", \"MD_01\"]) */\n  modifiers: string[];\n  /** Active lock IDs (e.g., [\"LK_00\"]) */\n  locks: string[];\n  /** Current active layer name */\n  layer: string;\n}\n\n/**\n * Individual key event data.\n * Broadcast on \"events\" channel for each key press/release.\n */\nexport interface KeyEvent {\n  /** Timestamp in microseconds since UNIX epoch */\n  timestamp: number;\n  /** Key code (e.g., \"KEY_A\") */\n  keyCode: string;\n  /** Event type (\"press\" or \"release\") */\n  eventType: \"press\" | \"release\";\n  /** Input key (before mapping) */\n  input: string;\n  /** Output key (after mapping) */\n  output: string;\n  /** Processing latency in microseconds */\n  latency: number;\n}\n\n/**\n * Latency statistics.\n * Broadcast on \"latency\" channel periodically (every 1 second).\n */\nexport interface LatencyMetrics {\n  /** Minimum latency in microseconds */\n  min: number;\n  /** Average latency in microseconds */\n  avg: number;\n  /** Maximum latency in microseconds */\n  max: number;\n  /** 95th percentile latency in microseconds */\n  p95: number;\n  /** 99th percentile latency in microseconds */\n  p99: number;\n  /** Timestamp of this stats snapshot (microseconds since UNIX epoch) */\n  timestamp: number;\n}\n\n/**\n * Type guard to check if a ServerMessage is a Response.\n */\nexport function isResponse(msg: ServerMessage): msg is Extract<ServerMessage, { type: \"response\" }> {\n  return msg.type === \"response\";\n}\n\n/**\n * Type guard to check if a ServerMessage is an Event.\n */\nexport function isEvent(msg: ServerMessage): msg is Extract<ServerMessage, { type: \"event\" }> {\n  return msg.type === \"event\";\n}\n\n/**\n * Type guard to check if a ServerMessage is a Connected handshake.\n */\nexport function isConnected(msg: ServerMessage): msg is Extract<ServerMessage, { type: \"connected\" }> {\n  return msg.type === \"connected\";\n}\n","/**\n * Type-safe RPC client for WebSocket communication with the daemon.\n *\n * This client wraps the useUnifiedApi hook and provides typed methods for all\n * RPC operations. All methods are thin wrappers that delegate to the underlying\n * query/command/subscribe methods with proper type safety.\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const api = useUnifiedApi();\n *   const client = new RpcClient(api);\n *\n *   // Query profiles\n *   const profiles = await client.getProfiles();\n *\n *   // Activate a profile\n *   await client.activateProfile('Gaming');\n *\n *   // Subscribe to state changes\n *   client.onDaemonState((state) => {\n *     console.log('State changed:', state);\n *   });\n * }\n * ```\n */\n\nimport type { UseUnifiedApiReturn } from '../hooks/useUnifiedApi';\nimport type { DaemonState, KeyEvent, LatencyMetrics } from '../types/rpc';\nimport type { Profile, ProfileConfig, Device, Config, Layer, SimulationInput, SimulationResult, PaginatedEvents } from './types';\nimport { validateApiResponse, ProfileConfigRpcSchema, ProfileRpcInfoSchema, DeviceRpcInfoSchema } from './schemas';\n\n/**\n * Type-safe RPC client for daemon communication.\n */\nexport class RpcClient {\n  private api: UseUnifiedApiReturn;\n\n  /**\n   * Create a new RPC client.\n   *\n   * @param api - The useUnifiedApi hook return value\n   */\n  constructor(api: UseUnifiedApiReturn) {\n    this.api = api;\n  }\n\n  // ========================================\n  // Profile Methods\n  // ========================================\n\n  /**\n   * Get all profiles.\n   *\n   * @returns Array of profile metadata\n   * @throws Error if the request fails\n   */\n  async getProfiles(): Promise<Profile[]> {\n    return this.api.query<Profile[]>('get_profiles');\n  }\n\n  /**\n   * Create a new profile.\n   *\n   * @param name - Name of the profile to create\n   * @param template - Optional template to initialize from\n   * @returns Success status\n   * @throws Error if profile name is invalid or profile already exists\n   */\n  async createProfile(name: string, template?: string): Promise<void> {\n    return this.api.command<void>('create_profile', { name, template });\n  }\n\n  /**\n   * Activate a profile.\n   *\n   * @param name - Name of the profile to activate\n   * @returns Success status\n   * @throws Error if profile does not exist or activation fails\n   */\n  async activateProfile(name: string): Promise<void> {\n    return this.api.command<void>('activate_profile', { name });\n  }\n\n  /**\n   * Delete a profile.\n   *\n   * @param name - Name of the profile to delete\n   * @returns Success status\n   * @throws Error if profile does not exist or is currently active\n   */\n  async deleteProfile(name: string): Promise<void> {\n    return this.api.command<void>('delete_profile', { name });\n  }\n\n  /**\n   * Duplicate a profile.\n   *\n   * @param sourceName - Name of the profile to duplicate\n   * @param newName - Name for the new profile\n   * @returns Success status\n   * @throws Error if source does not exist or new name is invalid\n   */\n  async duplicateProfile(sourceName: string, newName: string): Promise<void> {\n    return this.api.command<void>('duplicate_profile', { source_name: sourceName, new_name: newName });\n  }\n\n  /**\n   * Rename a profile.\n   *\n   * @param oldName - Current name of the profile\n   * @param newName - New name for the profile\n   * @returns Success status\n   * @throws Error if profile does not exist or new name is invalid\n   */\n  async renameProfile(oldName: string, newName: string): Promise<void> {\n    return this.api.command<void>('rename_profile', { old_name: oldName, new_name: newName });\n  }\n\n  /**\n   * Get profile configuration source code.\n   *\n   * @param name - Name of the profile\n   * @returns Profile configuration with name and source code\n   * @throws Error if profile does not exist\n   */\n  async getProfileConfig(name: string): Promise<ProfileConfig> {\n    const response = await this.api.query<any>('get_profile_config', { name });\n    const validated = validateApiResponse(ProfileConfigRpcSchema, response, 'get_profile_config');\n    return {\n      name: validated.name,\n      source: validated.config, // Backend returns 'config' field\n    };\n  }\n\n  /**\n   * Set profile configuration source code.\n   *\n   * @param name - Name of the profile\n   * @param source - Rhai configuration source code\n   * @returns Success status\n   * @throws Error if profile does not exist or source is invalid\n   */\n  async setProfileConfig(name: string, source: string): Promise<void> {\n    const response = await this.api.command<any>('set_profile_config', { name, source });\n    // For commands, the response is typically empty on success or contains error info\n    // Validation already happened at the WebSocket layer, so we just need to check for errors\n    if (response && typeof response === 'object') {\n      console.debug(JSON.stringify({\n        timestamp: new Date().toISOString(),\n        level: 'debug',\n        service: 'RPC Client',\n        event: 'set_profile_config_success',\n        context: { profileName: name },\n      }));\n    }\n  }\n\n  /**\n   * Get the currently active profile name.\n   *\n   * @returns Active profile name or null if no profile is active\n   * @throws Error if the request fails\n   */\n  async getActiveProfile(): Promise<string | null> {\n    return this.api.query<string | null>('get_active_profile');\n  }\n\n  // ========================================\n  // Device Methods\n  // ========================================\n\n  /**\n   * Get all devices.\n   *\n   * @returns Array of device information\n   * @throws Error if the request fails\n   */\n  async getDevices(): Promise<Device[]> {\n    return this.api.query<Device[]>('get_devices');\n  }\n\n  /**\n   * Rename a device.\n   *\n   * @param serial - Device serial number\n   * @param newName - New name for the device\n   * @returns Success status\n   * @throws Error if device does not exist or name is invalid\n   */\n  async renameDevice(serial: string, newName: string): Promise<void> {\n    return this.api.command<void>('rename_device', { serial, new_name: newName });\n  }\n\n  /**\n   * Set device scope.\n   *\n   * @param serial - Device serial number\n   * @param scope - Scope to set ('global' or 'profile')\n   * @returns Success status\n   * @throws Error if device does not exist or scope is invalid\n   */\n  async setScopeDevice(serial: string, scope: 'global' | 'profile'): Promise<void> {\n    return this.api.command<void>('set_scope_device', { serial, scope });\n  }\n\n  /**\n   * Forget a device (remove from configuration).\n   *\n   * @param serial - Device serial number\n   * @returns Success status\n   * @throws Error if device does not exist\n   */\n  async forgetDevice(serial: string): Promise<void> {\n    return this.api.command<void>('forget_device', { serial });\n  }\n\n  /**\n   * Set device keyboard layout preference.\n   *\n   * @param serial - Device serial number\n   * @param layout - Layout name (e.g., 'ansi', 'iso', 'jis')\n   * @returns Success status\n   * @throws Error if device does not exist or layout is invalid\n   */\n  async setDeviceLayout(serial: string, layout: string): Promise<void> {\n    return this.api.command<void>('set_device_layout', { serial, layout });\n  }\n\n  // ========================================\n  // Configuration Methods\n  // ========================================\n\n  /**\n   * Get current configuration.\n   *\n   * @returns Configuration code and hash\n   * @throws Error if the request fails\n   */\n  async getConfig(): Promise<Config> {\n    return this.api.query<Config>('get_config');\n  }\n\n  /**\n   * Update configuration.\n   *\n   * @param code - New configuration code\n   * @returns Success status\n   * @throws Error if configuration is invalid or exceeds size limit\n   */\n  async updateConfig(code: string): Promise<void> {\n    return this.api.command<void>('update_config', { code });\n  }\n\n  /**\n   * Set a single key mapping.\n   *\n   * @param layer - Layer name\n   * @param keyCode - Key code to map\n   * @param mapping - Mapping definition\n   * @returns Success status\n   * @throws Error if layer or mapping is invalid\n   */\n  async setKeyMapping(layer: string, keyCode: string, mapping: string): Promise<void> {\n    return this.api.command<void>('set_key_mapping', { layer, key_code: keyCode, mapping });\n  }\n\n  /**\n   * Delete a key mapping.\n   *\n   * @param layer - Layer name\n   * @param keyCode - Key code to unmap\n   * @returns Success status\n   * @throws Error if layer does not exist\n   */\n  async deleteKeyMapping(layer: string, keyCode: string): Promise<void> {\n    return this.api.command<void>('delete_key_mapping', { layer, key_code: keyCode });\n  }\n\n  /**\n   * Get all layers.\n   *\n   * @returns Array of layer names\n   * @throws Error if the request fails\n   */\n  async getLayers(): Promise<Layer[]> {\n    return this.api.query<Layer[]>('get_layers');\n  }\n\n  // ========================================\n  // Metrics Methods\n  // ========================================\n\n  /**\n   * Get current latency statistics.\n   *\n   * @returns Latency metrics\n   * @throws Error if the request fails\n   */\n  async getLatency(): Promise<LatencyMetrics> {\n    return this.api.query<LatencyMetrics>('get_latency');\n  }\n\n  /**\n   * Get event history with pagination.\n   *\n   * @param limit - Maximum number of events to return (default 100, max 1000)\n   * @param offset - Number of events to skip (default 0)\n   * @returns Paginated events\n   * @throws Error if the request fails\n   */\n  async getEvents(limit?: number, offset?: number): Promise<PaginatedEvents> {\n    return this.api.query<PaginatedEvents>('get_events', { limit, offset });\n  }\n\n  /**\n   * Clear event history.\n   *\n   * @returns Success status\n   * @throws Error if the request fails\n   */\n  async clearEvents(): Promise<void> {\n    return this.api.command<void>('clear_events');\n  }\n\n  // ========================================\n  // Simulation Methods\n  // ========================================\n\n  /**\n   * Run a simulation with the current configuration.\n   *\n   * @param input - Array of input events to simulate\n   * @returns Simulation results\n   * @throws Error if simulation fails\n   */\n  async simulate(input: SimulationInput[]): Promise<SimulationResult[]> {\n    return this.api.command<SimulationResult[]>('simulate', { input });\n  }\n\n  /**\n   * Reset the simulator state.\n   *\n   * @returns Success status\n   * @throws Error if the request fails\n   */\n  async resetSimulator(): Promise<void> {\n    return this.api.command<void>('reset_simulator');\n  }\n\n  // ========================================\n  // Subscription Methods\n  // ========================================\n\n  /**\n   * Subscribe to daemon state changes.\n   *\n   * @param handler - Function to call when state changes\n   * @returns Unsubscribe function\n   */\n  onDaemonState(handler: (state: DaemonState) => void): () => void {\n    return this.api.subscribe('daemon-state', handler as (data: unknown) => void);\n  }\n\n  /**\n   * Subscribe to key events.\n   *\n   * @param handler - Function to call for each key event\n   * @returns Unsubscribe function\n   */\n  onKeyEvent(handler: (event: KeyEvent) => void): () => void {\n    return this.api.subscribe('events', handler as (data: unknown) => void);\n  }\n\n  /**\n   * Subscribe to latency metric updates.\n   *\n   * @param handler - Function to call when latency metrics are updated\n   * @returns Unsubscribe function\n   */\n  onLatencyUpdate(handler: (metrics: LatencyMetrics) => void): () => void {\n    return this.api.subscribe('latency', handler as (data: unknown) => void);\n  }\n\n  // ========================================\n  // Connection State\n  // ========================================\n\n  /**\n   * Check if connected to the daemon.\n   *\n   * @returns True if WebSocket is connected and handshake completed\n   */\n  get isConnected(): boolean {\n    return this.api.isConnected;\n  }\n\n  /**\n   * Get the current WebSocket connection state.\n   *\n   * @returns ReadyState enum value\n   */\n  get readyState() {\n    return this.api.readyState;\n  }\n\n  /**\n   * Get the last error that occurred.\n   *\n   * @returns Error object or null if no error\n   */\n  get lastError(): Error | null {\n    return this.api.lastError;\n  }\n}\n","import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { queryKeys } from '../lib/queryClient';\nimport { useUnifiedApi } from './useUnifiedApi';\nimport { RpcClient } from '../api/rpc';\nimport type { ProfileConfig } from '../api/types';\n\n/**\n * Fetch profile configuration source code with React Query caching\n *\n * @param name - Profile name to fetch configuration for\n * @returns Query result with profile configuration\n */\nexport function useGetProfileConfig(name: string) {\n  const api = useUnifiedApi();\n  const client = new RpcClient(api);\n\n  return useQuery({\n    queryKey: queryKeys.config(name),\n    queryFn: () => client.getProfileConfig(name),\n    enabled: !!name && api.isConnected, // Only fetch if name is provided and WebSocket connected\n    staleTime: 30000, // Consider data fresh for 30 seconds\n    gcTime: 300000, // Keep in cache for 5 minutes\n    retry: 1, // Only retry once on failure\n    retryDelay: 1000, // Wait 1 second before retry\n  });\n}\n\n/**\n * Update profile configuration source code with optimistic updates\n *\n * @returns Mutation function and status\n */\nexport function useSetProfileConfig() {\n  const queryClient = useQueryClient();\n  const api = useUnifiedApi();\n  const client = new RpcClient(api);\n\n  return useMutation({\n    mutationFn: ({ name, source }: { name: string; source: string }) =>\n      client.setProfileConfig(name, source),\n\n    onMutate: async ({ name, source }) => {\n      // Cancel outgoing queries for this profile config\n      await queryClient.cancelQueries({ queryKey: queryKeys.config(name) });\n\n      // Snapshot previous value\n      const previousConfig = queryClient.getQueryData<ProfileConfig>(\n        queryKeys.config(name)\n      );\n\n      // Optimistically update to new value\n      queryClient.setQueryData<ProfileConfig>(queryKeys.config(name), {\n        name,\n        source,\n      });\n\n      return { previousConfig };\n    },\n\n    onError: (_error, { name }, context) => {\n      // Rollback to previous value on error\n      if (context?.previousConfig) {\n        queryClient.setQueryData(queryKeys.config(name), context.previousConfig);\n      }\n    },\n\n    onSuccess: (_data, { name }) => {\n      // Invalidate related queries\n      queryClient.invalidateQueries({ queryKey: queryKeys.config(name) });\n      queryClient.invalidateQueries({ queryKey: queryKeys.profiles });\n    },\n  });\n}\n"],"names":["KeyButton","React","memo","keyCode","label","mapping","onClick","isPressed","className","hasMapping","tooltipContent","useMemo","type","tapAction","holdAction","threshold","macroSteps","length","targetLayer","remapText","style","border","bg","getKeyStyle","jsx","Tooltip","content","children","jsxs","cn","aspectRatio","displayName","layoutData","ANSI_104","ISO_105","JIS_109","HHKB","NUMPAD","DroppableKeyWrapper","onDrop","disabled","setNodeRef","isOver","useDroppable","id","data","mappingDescription","ariaLabel","ref","KeyboardVisualizer","layout","keyMappings","onKeyClick","onKeyDrop","simulatorMode","pressedKeys","Set","containerRef","useRef","keyButtons","keys","map","key","code","gridRow","Math","floor","y","gridColumn","x","gridColumnSpan","ceil","w","width","maxRow","max","k","maxCol","options","orientation","loop","onEnter","useEffect","container","current","handleKeyDown","event","focusableElements","selector","join","Array","from","querySelectorAll","getFocusableElements","currentIndex","findIndex","el","document","activeElement","isVertical","nextKey","prevKey","nextIndex","preventDefault","focus","addEventListener","removeEventListener","useArrowNavigation","role","display","gridTemplateRows","gridTemplateColumns","gap","padding","backgroundColor","borderRadius","get","droppedKey","has","env","wsUrl","window","location","protocol","host","useUnifiedApi","url","isConnected","setIsConnected","useState","lastError","setLastError","pendingRequests","Map","subscriptions","sendMessage","lastMessage","readyState","useWebSocket","shouldReconnect","reconnectInterval","reconnectAttempts","onError","Error","onClose","forEach","pending","clearTimeout","timeoutId","reject","clear","parsedData","JSON","parse","message","validateRpcMessage","validationError","delete","error","resolve","result","msg","checkIsEvent","handlers","channel","handler","anyMessage","payload","legacyType","legacyPayload","latency","state","heartbeat","sendRequest","useCallback","Promise","ReadyState","OPEN","setTimeout","set","stringify","query","method","params","uuidv4","command","subscribe","isFirstSubscriber","size","add","unsubscribe","_","RpcClient","constructor","api","this","getProfiles","createProfile","name","template","activateProfile","deleteProfile","duplicateProfile","sourceName","newName","source_name","new_name","renameProfile","oldName","old_name","getProfileConfig","response","validated","validateApiResponse","ProfileConfigRpcSchema","source","config","setProfileConfig","getActiveProfile","getDevices","renameDevice","serial","setScopeDevice","scope","forgetDevice","setDeviceLayout","getConfig","updateConfig","setKeyMapping","layer","key_code","deleteKeyMapping","getLayers","getLatency","getEvents","limit","offset","clearEvents","simulate","input","resetSimulator","onDaemonState","onKeyEvent","onLatencyUpdate","useGetProfileConfig","client","useQuery","queryKey","queryKeys","queryFn","enabled","staleTime","gcTime","retry","retryDelay","useSetProfileConfig","queryClient","useQueryClient","useMutation","mutationFn","onMutate","async","cancelQueries","previousConfig","getQueryData","setQueryData","_error","context","onSuccess","_data","invalidateQueries","profiles"],"mappings":"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"}