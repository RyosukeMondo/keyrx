{"version":3,"file":"useProfiles-MkTJ18U7.js","sources":["../../src/api/profiles.ts","../../src/hooks/useProfiles.ts"],"sourcesContent":["/**\n * Profile management API client\n */\n\nimport { apiClient } from './client';\nimport { validateApiResponse, ProfileListResponseSchema, ProfileRpcInfoSchema, ActivationRpcResultSchema } from './schemas';\nimport type { ProfileMetadata, Template, ActivationResult } from '../types';\n\ninterface CreateProfileRequest {\n  name: string;\n  template: Template;\n}\n\ninterface ProfileResponse {\n  success: boolean;\n}\n\n/**\n * Fetch all profiles\n */\nexport async function fetchProfiles(): Promise<ProfileMetadata[]> {\n  const response = await apiClient.get<{ profiles: ProfileMetadata[] }>('/api/profiles');\n  const validated = validateApiResponse(ProfileListResponseSchema, response, 'GET /api/profiles');\n\n  // Map response to ProfileMetadata format\n  return validated.profiles.map((p) => ({\n    name: p.name,\n    rhaiPath: p.rhaiPath,\n    krxPath: p.krxPath,\n    createdAt: p.createdAt,\n    modifiedAt: p.modifiedAt,\n    deviceCount: p.deviceCount,\n    keyCount: p.keyCount,\n    isActive: p.isActive,\n  }));\n}\n\n/**\n * Create a new profile\n */\nexport async function createProfile(\n  name: string,\n  template: Template\n): Promise<ProfileResponse> {\n  const request: CreateProfileRequest = { name, template };\n  const response = await apiClient.post<any>('/api/profiles', request);\n  // Validate the returned profile info\n  validateApiResponse(ProfileRpcInfoSchema, response, 'POST /api/profiles');\n  return { success: true };\n}\n\n/**\n * Activate a profile\n */\nexport async function activateProfile(\n  name: string\n): Promise<ActivationResult> {\n  const response = await apiClient.post<any>(`/api/profiles/${name}/activate`);\n  const validated = validateApiResponse(ActivationRpcResultSchema, response, `POST /api/profiles/${name}/activate`);\n\n  // Map RPC activation result to ActivationResult format\n  return {\n    success: validated.success,\n    profile: name,\n    compiledSize: 0, // RPC doesn't provide this, use placeholder\n    compileTimeMs: validated.compile_time_ms,\n    errors: validated.error ? [validated.error] : [],\n  };\n}\n\n/**\n * Delete a profile\n */\nexport async function deleteProfile(name: string): Promise<ProfileResponse> {\n  const response = await apiClient.delete<any>(`/api/profiles/${name}`);\n  // Validate the response - for delete, we expect either empty or success indicator\n  // Since there's no specific schema for delete response, we'll just check it doesn't error\n  if (response && typeof response === 'object') {\n    console.debug(JSON.stringify({\n      timestamp: new Date().toISOString(),\n      level: 'debug',\n      service: 'API Validation',\n      event: 'delete_profile_success',\n      context: { profileName: name },\n    }));\n  }\n  return { success: true };\n}\n\n/**\n * Duplicate a profile\n */\nexport async function duplicateProfile(\n  sourceName: string,\n  newName: string\n): Promise<ProfileResponse> {\n  const response = await apiClient.post<any>(\n    `/api/profiles/${sourceName}/duplicate`,\n    { newName }\n  );\n  // Validate the returned profile info\n  validateApiResponse(ProfileRpcInfoSchema, response, `POST /api/profiles/${sourceName}/duplicate`);\n  return { success: true };\n}\n\n/**\n * Validation error structure\n */\nexport interface ValidationError {\n  line: number;\n  column: number;\n  length: number;\n  message: string;\n}\n\n/**\n * Validation result\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationError[];\n}\n\n/**\n * Validate profile configuration\n */\nexport async function validateConfig(config: string): Promise<ValidationResult> {\n  return apiClient.post<ValidationResult>('/api/profiles/validate', { config });\n}\n","import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { queryKeys } from '../lib/queryClient';\nimport * as profileApi from '../api/profiles';\nimport type { ProfileMetadata, Template } from '../types';\n\n/**\n * Fetch all profiles with React Query caching\n */\nexport function useProfiles() {\n  return useQuery({\n    queryKey: queryKeys.profiles,\n    queryFn: profileApi.fetchProfiles,\n  });\n}\n\n/**\n * Get the currently active profile\n */\nexport function useActiveProfile() {\n  const { data: profiles } = useProfiles();\n  return profiles?.find((p) => p.isActive) ?? null;\n}\n\n/**\n * Create a new profile with cache invalidation\n */\nexport function useCreateProfile() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ name, template }: { name: string; template: Template }) =>\n      profileApi.createProfile(name, template),\n\n    // Invalidate and refetch profiles list after creation\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: queryKeys.profiles });\n    },\n  });\n}\n\n/**\n * Activate a profile with optimistic updates\n */\nexport function useActivateProfile() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (name: string) => profileApi.activateProfile(name),\n\n    onMutate: async (name) => {\n      // Cancel outgoing queries\n      await queryClient.cancelQueries({ queryKey: queryKeys.profiles });\n\n      // Snapshot previous value\n      const previousProfiles = queryClient.getQueryData<ProfileMetadata[]>(\n        queryKeys.profiles\n      );\n\n      // Optimistically update: set all to inactive, target to active\n      queryClient.setQueryData<ProfileMetadata[]>(\n        queryKeys.profiles,\n        (old) =>\n          old?.map((p) => ({\n            ...p,\n            isActive: p.name === name,\n          }))\n      );\n\n      return { previousProfiles };\n    },\n\n    onError: (_error, _variables, context) => {\n      if (context?.previousProfiles) {\n        queryClient.setQueryData(queryKeys.profiles, context.previousProfiles);\n      }\n    },\n\n    onSuccess: (result, _variables, context) => {\n      // Only invalidate cache if there are no compilation errors\n      // If there are errors, rollback to previous state\n      if (result.errors && result.errors.length > 0) {\n        // Rollback optimistic update on compilation error\n        if (context?.previousProfiles) {\n          queryClient.setQueryData(queryKeys.profiles, context.previousProfiles);\n        }\n      } else {\n        // Success - invalidate profiles, config, daemon state, and active profile queries\n        queryClient.invalidateQueries({ queryKey: queryKeys.profiles });\n        queryClient.invalidateQueries({ queryKey: ['config'] });\n        queryClient.invalidateQueries({ queryKey: queryKeys.daemonState });\n        queryClient.invalidateQueries({ queryKey: queryKeys.activeProfile });\n      }\n    },\n  });\n}\n\n/**\n * Delete a profile with optimistic updates\n */\nexport function useDeleteProfile() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (name: string) => {\n      // Check if profile is active before attempting deletion\n      const profiles = queryClient.getQueryData<ProfileMetadata[]>(\n        queryKeys.profiles\n      );\n      const profile = profiles?.find((p) => p.name === name);\n\n      if (profile?.isActive) {\n        throw new Error('Cannot delete the active profile');\n      }\n\n      return profileApi.deleteProfile(name);\n    },\n\n    onMutate: async (name) => {\n      await queryClient.cancelQueries({ queryKey: queryKeys.profiles });\n\n      const previousProfiles = queryClient.getQueryData<ProfileMetadata[]>(\n        queryKeys.profiles\n      );\n\n      // Optimistically remove profile\n      queryClient.setQueryData<ProfileMetadata[]>(queryKeys.profiles, (old) =>\n        old?.filter((p) => p.name !== name)\n      );\n\n      return { previousProfiles };\n    },\n\n    onError: (_error, _variables, context) => {\n      if (context?.previousProfiles) {\n        queryClient.setQueryData(queryKeys.profiles, context.previousProfiles);\n      }\n    },\n\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: queryKeys.profiles });\n    },\n  });\n}\n"],"names":["async","fetchProfiles","response","apiClient","get","validateApiResponse","ProfileListResponseSchema","profiles","map","p","name","rhaiPath","krxPath","createdAt","modifiedAt","deviceCount","keyCount","isActive","useProfiles","useQuery","queryKey","queryKeys","queryFn","profileApi.fetchProfiles","useActiveProfile","data","find","useCreateProfile","queryClient","useQueryClient","useMutation","mutationFn","template","request","post","ProfileRpcInfoSchema","success","profileApi.createProfile","onSuccess","invalidateQueries","useActivateProfile","validated","ActivationRpcResultSchema","profile","compiledSize","compileTimeMs","compile_time_ms","errors","error","profileApi.activateProfile","onMutate","cancelQueries","previousProfiles","getQueryData","setQueryData","old","onError","_error","_variables","context","result","length","daemonState","activeProfile","useDeleteProfile","Error","delete","profileApi.deleteProfile","filter"],"mappings":"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"}