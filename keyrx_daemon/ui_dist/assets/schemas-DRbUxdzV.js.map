{"version":3,"file":"schemas-DRbUxdzV.js","sources":["../../src/api/schemas.ts"],"sourcesContent":["import { z } from 'zod';\n\n/**\n * Zod schemas for runtime validation of API responses.\n * These schemas match the TypeScript types generated from Rust structs in types/generated.ts.\n *\n * Note: Schemas are designed to be permissive with unexpected fields (log warnings instead of throwing).\n */\n\n// JSON value type for serde_json::Value compatibility\nexport const ValueSchema: z.ZodType<any> = z.lazy(() =>\n  z.union([\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.null(),\n    z.record(z.string(), ValueSchema),\n    z.array(ValueSchema),\n  ])\n);\n\n// Device scope enum\nexport const DeviceScopeSchema = z.enum(['DeviceSpecific', 'Global']);\n\n// Device metadata entry\nexport const DeviceEntrySchema = z.object({\n  id: z.string().max(256),\n  name: z.string().max(64),\n  serial: z.string().optional(),\n  scope: DeviceScopeSchema,\n  layout: z.string().max(32).optional(),\n  last_seen: z.number(),\n}).passthrough(); // Allow unexpected fields (log warning in validator)\n\n// Device information from RPC and REST API\n// Matches Rust DeviceResponse struct in keyrx_daemon/src/web/api/devices.rs\nexport const DeviceRpcInfoSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  path: z.string(),\n  serial: z.string().nullable().optional(), // Backend returns null when not available\n  active: z.boolean(),\n  scope: z.string().nullable().optional(),\n  layout: z.string().nullable().optional(), // Backend returns null when not set\n}).passthrough();\n\n// Event in event log\nexport const EventRpcEntrySchema = z.object({\n  timestamp: z.number(),\n  key_code: z.number(),\n  event_type: z.string(),\n  device_id: z.string(),\n}).passthrough();\n\n// Individual key event data\nexport const KeyEventDataSchema = z.object({\n  timestamp: z.number(),\n  keyCode: z.string(),\n  eventType: z.string(),\n  input: z.string(),\n  output: z.string(),\n  latency: z.number(),\n}).passthrough();\n\n// Latency statistics from RPC\nexport const LatencyRpcStatsSchema = z.object({\n  min_us: z.number(),\n  avg_us: z.number(),\n  max_us: z.number(),\n  p50_us: z.number(),\n  p95_us: z.number(),\n  p99_us: z.number(),\n  count: z.number(),\n}).passthrough();\n\n// Latency statistics\nexport const LatencyStatsSchema = z.object({\n  min: z.number(),\n  avg: z.number(),\n  max: z.number(),\n  p95: z.number(),\n  p99: z.number(),\n  timestamp: z.number(),\n}).passthrough();\n\n// Profile configuration from RPC\n// Matches Rust ProfileConfigResponse in keyrx_daemon/src/web/api/profiles.rs\nexport const ProfileConfigRpcSchema = z.object({\n  name: z.string(),\n  config: z.string(), // The Rhai source code\n}).passthrough();\n\n// Profile information from RPC (used in list responses)\nexport const ProfileRpcInfoSchema = z.object({\n  name: z.string(),\n  rhaiPath: z.string(),\n  krxPath: z.string(),\n  modifiedAt: z.string(), // ISO 8601 timestamp\n  createdAt: z.string(), // ISO 8601 timestamp\n  layerCount: z.number(),\n  deviceCount: z.number(),\n  keyCount: z.number(),\n  isActive: z.boolean(),\n}).passthrough();\n\n// Activation result\nexport const ActivationRpcResultSchema = z.object({\n  success: z.boolean(),\n  compile_time_ms: z.number(),\n  reload_time_ms: z.number(),\n  error: z.string().optional(),\n}).passthrough();\n\n// Daemon state snapshot\nexport const DaemonStateSchema = z.object({\n  modifiers: z.array(z.string()),\n  locks: z.array(z.string()),\n  layer: z.string(),\n  active_profile: z.string().optional(),\n}).passthrough();\n\n// RPC error structure\nexport const RpcErrorSchema = z.object({\n  code: z.number(),\n  message: z.string(),\n  data: ValueSchema.optional(),\n}).passthrough();\n\n// Client messages (requests from UI to daemon)\nexport const ClientMessageSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('query'),\n    content: z.object({\n      id: z.string(),\n      method: z.string(),\n      params: ValueSchema.optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal('command'),\n    content: z.object({\n      id: z.string(),\n      method: z.string(),\n      params: ValueSchema.optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal('subscribe'),\n    content: z.object({\n      id: z.string(),\n      channel: z.string(),\n    }),\n  }),\n  z.object({\n    type: z.literal('unsubscribe'),\n    content: z.object({\n      id: z.string(),\n      channel: z.string(),\n    }),\n  }),\n]);\n\n// Daemon events (broadcasts from daemon)\nexport const DaemonEventSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('state'),\n    payload: DaemonStateSchema,\n  }),\n  z.object({\n    type: z.literal('event'),\n    payload: KeyEventDataSchema,\n  }),\n  z.object({\n    type: z.literal('latency'),\n    payload: LatencyStatsSchema,\n  }),\n]);\n\n// Server messages (responses from daemon to UI)\nexport const ServerMessageSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('response'),\n    content: z.object({\n      id: z.string(),\n      result: ValueSchema.optional(),\n      error: RpcErrorSchema.optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal('event'),\n    content: z.object({\n      channel: z.string(),\n      data: ValueSchema,\n    }),\n  }),\n  z.object({\n    type: z.literal('connected'),\n    content: z.object({\n      version: z.string(),\n      timestamp: z.number(),\n    }),\n  }),\n]);\n\n// API response collections\n// NOTE: DeviceListResponseSchema uses DeviceRpcInfoSchema (not DeviceEntrySchema)\n// because the REST API returns the same format as the RPC interface.\n// DeviceEntrySchema is for device metadata storage format, not API responses.\nexport const DeviceListResponseSchema = z.object({\n  devices: z.array(DeviceRpcInfoSchema),\n}).passthrough();\n\nexport const ProfileListResponseSchema = z.object({\n  profiles: z.array(ProfileRpcInfoSchema),\n}).passthrough();\n\nexport const ProfileConfigResponseSchema = ProfileConfigRpcSchema;\n\n/**\n * Validates API response data against a Zod schema.\n *\n * @template T - The expected TypeScript type\n * @param schema - Zod schema to validate against\n * @param data - Unknown data to validate\n * @param endpoint - API endpoint name for error context\n * @returns Validated data of type T\n * @throws Error if validation fails\n *\n * @example\n * const devices = validateApiResponse(\n *   DeviceListResponseSchema,\n *   await response.json(),\n *   'GET /api/devices'\n * );\n */\nexport function validateApiResponse<T>(\n  schema: z.ZodSchema<T>,\n  data: unknown,\n  endpoint: string\n): T {\n  const result = schema.safeParse(data);\n\n  if (!result.success) {\n    const errorMessage = `API validation failed for ${endpoint}: ${result.error.message}`;\n\n    // Log structured error for debugging\n    console.error(JSON.stringify({\n      timestamp: new Date().toISOString(),\n      level: 'error',\n      service: 'API Validation',\n      event: 'validation_failed',\n      context: {\n        endpoint,\n        error: result.error.format(),\n        data: data,\n      },\n    }));\n\n    throw new Error(errorMessage);\n  }\n\n  // Check for unexpected fields and log as warnings\n  // Note: Using passthrough() on schemas allows unexpected fields,\n  // so we just log them as warnings rather than failing validation\n  if (typeof data === 'object' && data !== null) {\n    const receivedKeys = Object.keys(data);\n\n    // We can't easily introspect Zod schemas to get expected keys,\n    // but passthrough() already handles this by including extra fields in the result.\n    // Just log that we received data for tracking purposes.\n    if (receivedKeys.length > 0) {\n      console.debug(JSON.stringify({\n        timestamp: new Date().toISOString(),\n        level: 'debug',\n        service: 'API Validation',\n        event: 'validation_success',\n        context: {\n          endpoint,\n          fieldCount: receivedKeys.length,\n        },\n      }));\n    }\n  }\n\n  return result.data;\n}\n\n/**\n * Validates WebSocket RPC message.\n * Handles both client messages (outgoing) and server messages (incoming).\n *\n * @param data - Unknown message data\n * @param direction - 'client' for outgoing, 'server' for incoming\n * @returns Validated message\n * @throws Error if validation fails\n */\nexport function validateRpcMessage(\n  data: unknown,\n  direction: 'client' | 'server'\n): any {\n  const schema = direction === 'client' ? ClientMessageSchema : ServerMessageSchema;\n  const result = schema.safeParse(data);\n\n  if (!result.success) {\n    console.error(JSON.stringify({\n      timestamp: new Date().toISOString(),\n      level: 'error',\n      service: 'WebSocket RPC',\n      event: 'message_validation_failed',\n      context: {\n        direction,\n        error: result.error.format(),\n        data: data,\n      },\n    }));\n\n    throw new Error(`Invalid ${direction} RPC message: ${result.error.message}`);\n  }\n\n  return result.data;\n}\n"],"names":["ValueSchema","z.lazy","z.union","z.string","z.number","z.boolean","z.null","z.record","z.array","DeviceScopeSchema","z.enum","z.object","id","max","name","serial","optional","scope","layout","last_seen","passthrough","DeviceRpcInfoSchema","path","nullable","active","timestamp","key_code","event_type","device_id","KeyEventDataSchema","keyCode","eventType","input","output","latency","min_us","avg_us","max_us","p50_us","p95_us","p99_us","count","LatencyStatsSchema","min","avg","p95","p99","ProfileConfigRpcSchema","config","ProfileRpcInfoSchema","rhaiPath","krxPath","modifiedAt","createdAt","layerCount","deviceCount","keyCount","isActive","ActivationRpcResultSchema","success","compile_time_ms","reload_time_ms","error","DaemonStateSchema","modifiers","locks","layer","active_profile","RpcErrorSchema","code","message","data","ClientMessageSchema","z.discriminatedUnion","type","z.literal","content","method","params","channel","payload","ServerMessageSchema","result","version","DeviceListResponseSchema","devices","ProfileListResponseSchema","profiles","validateApiResponse","schema","endpoint","safeParse","errorMessage","Error","Object","keys","length","validateRpcMessage","direction"],"mappings":"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"}