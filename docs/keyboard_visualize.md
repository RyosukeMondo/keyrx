Webベースのキーボードレイアウト可視化およびQMKファームウェア連携に関する技術調査報告書1. エグゼクティブサマリー本報告書は、Webブラウザ上で動作するキーボードリマップ（キー配置変更）ツールの開発において、物理的なキーボードレイアウトの定義、可視化、およびQMKファームウェアとのデータ連携を実現するための技術選定と実装戦略に関する包括的な調査結果である。特に、ユーザー要件として挙げられた「JSONファイルによるレイアウト定義」、「リアルなサイズ感でのWeb UI表示（特にISOエンターキーのような非矩形形状の再現）」、「QMKファームウェアとの紐付け」という3点の実現可能性と、それを支えるオープンソースライブラリのエコシステムを詳細に分析した。調査の結果、一般的なWeb開発で使用される仮想キーボードライブラリ（react-simple-keyboard等）は、主にテキスト入力支援を目的としており、物理的な基板（PCB）設計に忠実な可視化や、ISOエンターキーのような複雑なポリゴン形状の描画、およびQMK特有のマトリックス回路データとの連携機能を持たないことが判明した。したがって、既存のUIコンポーネントを単に導入するのではなく、Keyboard Layout Editor (KLE) JSON形式と**QMK info.json**形式のデータを相互運用するパーサーと、**SVG（Scalable Vector Graphics）**技術を用いたカスタムレンダリングエンジンを組み合わせるアーキテクチャが最適解であると結論付けた。本報告書では、この結論に至る技術的根拠、主要なオープンソースプロジェクト（qmk_configurator, keymap-editor, remap）のコード解析、ライセンス比較、および具体的な実装ロードマップを提示する。2. キーボードデータ定義の標準規格と構造解析「Remap」のようなツールを作成する上で、最初に直面する課題は「キーボードの形状と機能をどのようにデータとして定義するか」である。現在、カスタムキーボードコミュニティには2つの支配的なデータ規格が存在し、ツール開発にはこれら両方の深い理解と相互変換ロジックが不可欠である。2.1 Keyboard Layout Editor (KLE) JSON規格Keyboard Layout Editor（KLE）は、GitHubユーザーijprestによって開発された、キーボードレイアウト設計のデファクトスタンダードツールである1。ユーザーが「JSONファイルなどで定義して」と言及する場合、その多くはこのKLE形式を指している可能性が高い。2.1.1 データ構造の特性と課題KLEのJSONデータは、可読性よりもデータサイズの圧縮を優先した独自形式を採用している。相対座標系: 各キーの座標（X, Y）は絶対値ではなく、直前のキーからの相対的な位置として定義される。これにより、データの記述量は減るが、レンダリング時の計算コストが増大する。メタデータと文字列の混在: 配列の中にオブジェクト（プロパティ変更）と文字列（キーのラベル）が混在しており、単純なJSONパーサーでは構造化データとして扱いにくい。回転の処理: r（角度）、rx（回転中心X）、ry（回転中心Y）プロパティにより、Ergo系キーボードのような複雑な配置が可能だが、これをWebブラウザで正しく描画するには、SVGのtransform属性への正確な変換が必要となる。2.1.2 ISOエンターキーの定義KLEにおけるISOエンターキーは、通常、単一のキーではなく、視覚的に結合された2つのキー、あるいは特殊な形状メタデータを持つキーとして定義されることが多い。標準的な定義では、幅1.5u（ユニット）のキーと、その下の行にある幅1.25uのキーを組み合わせることでL字型を表現する。この「暗黙の形状定義」を、リマップツール側で「単一のクリッカブルなオブジェクト」として解釈・描画するロジックが、本プロジェクトの核となる技術的ハードルの一つである。2.2 QMK info.json規格QMKファームウェアは、近年「Data Driven Configuration（データ駆動型設定）」への移行を進めており、その中心にあるのがinfo.jsonファイルである2。2.2.1 物理と論理の架け橋KLEが「見た目」を定義するのに対し、info.jsonは「物理配置」と「電気的接続（マトリックス）」を紐付ける役割を持つ。Matrix Mapping: QMKのキーボードは、行（Row）と列（Col）の交点としてキーを認識する。info.json内のlayoutsオブジェクトは、物理的な座標（x, y）を持つ各キーに対し、matrix: [row, col]という配列を割り当てる。リマップツールにおける重要性: ユーザーの要件である「QMKの紐づけ」を実現するには、画面上のキーがクリックされた際、このinfo.jsonを参照して「どのRow/Colの値を変更するか」を特定する必要がある。2.3 規格間のギャップと統合戦略リマップツールを作成する場合、ユーザーがアップロードするKLE JSON（見た目）と、ファームウェアが要求するQMKのマトリックスデータ（機能）をマージする必要がある。課題: KLE JSONにはマトリックス情報が含まれていないことが多い。解決策: ツール側で、KLEの物理座標とQMK info.jsonの物理座標を照合（マッチング）させ、視覚データに電気的属性を付与するアルゴリズムの実装が求められる。3. 「リアルなサイズ」を実現するレンダリング技術の選定ユーザーの要件である「Web UIのキーボード表示をリアルなサイズ（エンターキーの再現）で実施したい」という点は、技術選定における最大のフィルタリング要因となる。3.1 既存の仮想キーボードライブラリの限界市場にはreact-simple-keyboard5やKioskBoard7といったライブラリが存在するが、これらは本プロジェクトの要件を満たさない。3.1.1 react-simple-keyboardの構造的欠陥このライブラリは、Webアプリケーションにおける「タッチスクリーン入力」を目的としている。DOMベースの描画: キーをHTMLのdiv要素として描画し、CSSのFlexboxやGridで配置する。これは「行（Row）」の概念に強く依存しており、行をまたぐ形状（ISOエンターキーやテンキーの＋キーなど）の表現が極めて困難である。形状の制約: CSSのボックスモデルは本質的に矩形である。L字型のキーを表現するには、複数のdivを重ね合わせるか、複雑なclip-pathを使用する必要があるが、これらはクリック判定（Hit Testing）の精度を低下させる8。回転の欠如: 物理的なキーボード（特にAlice配列やErgoDoxなど）に見られる「キーごとの回転」をサポートしていない。3.2 SVG (Scalable Vector Graphics) による解決策調査の結果、qmk_configurator9やkeymap-editor10など、成功しているキーボードコンフィギュレーターは例外なくSVGを採用していることが確認された。3.2.1 座標精度とスケーラビリティSVGはベクター形式であるため、KLEやQMK info.jsonで定義されるx, y, w, h（およびr）の数値を、そのまま描画座標として利用できる。1ユニット（1u）を例えば50pxと定義すれば、19.05mmの物理的な比率を画面上で完全に再現可能である11。3.2.2 ISOエンターキーの描画アルゴリズムISOエンターキーのような非凸多角形（Non-convex polygon）をSVGで描画する場合、<rect>要素ではなく<path>要素を使用する。実装ロジックの例:ISOエンターキーが、上段（幅1.5u）と下段（幅1.25u、左端揃えではない）の結合として定義されている場合、以下のようなパスデータを生成することで、継ぎ目のない「リアルな」形状を描画できる。$$P = (x, y) \rightarrow (x+1.5u, y) \rightarrow (x+1.5u, y+2u) \rightarrow (x+0.25u, y+2u) \rightarrow (x+0.25u, y+1u) \rightarrow (x, y+1u) \rightarrow Z$$この<path>要素に対しJavaScriptのイベントリスナー（onclick等）を設定することで、L字型の内側部分（通常は#や\キーが配置される場所）をクリックしてもエンターキーが反応しない、正確な当たり判定を実現できる13。3.2.3 結論：SVGコンポーネントの自作が必須「リアルなサイズ」と「ISOエンターの再現」を満たす既存の「npmインストール可能なコンポーネント」は存在しない。したがって、KLE/QMKのデータをパースし、それをSVG要素に変換するReact/Vueコンポーネントを自作することが、最も確実かつ高品質なアプローチとなる。4. オープンソースライブラリとエコシステムの詳細調査自作コンポーネントを開発するにあたり、ゼロからすべてを作る必要はない。以下のオープンソースライブラリやプロジェクトは、部品として利用するか、あるいは実装の参照モデルとして極めて重要である。4.1 kle-serial (必須のパーサーライブラリ)URL: https://github.com/ijprest/kle-serial 14役割: データ変換の中核ライセンス: MIT詳細:ユーザーがアップロードするKLE形式のJSONは、前述の通り相対座標や省略記法が多用されており、そのままでは描画できない。kle-serialは、この複雑なフォーマットを読み込み、すべてのキーが絶対座標（x, y）、幅（w）、高さ（h）、回転（r）を持つ標準化されたオブジェクト配列（Keyboardオブジェクト）に変換する。利用推奨度: 必須。このロジックを自前で実装するのは車輪の再発明であり、バグの温床となるため、このライブラリを依存関係に含めるべきである。4.2 qmk_configurator (リファレンス実装)URL: https://github.com/qmk/qmk_configurator 9役割: QMK公式のWeb UIライセンス: GPL-3.0技術スタック: Vue.js調査からの洞察:このプロジェクトのソースコード、特にsrc/components/VisualKeyMap.vue（バージョンによりパスは異なる可能性がある）は、QMKのinfo.jsonデータをどのように解釈して画面に描画しているかの「正解」を示している。特に、マトリックスデータとビジュアルデータの紐付けロジックや、キーコード（KC_Aなど）のバリデーションロジックは、このリポジトリから学ぶべき点が多い9。注意点: ライブラリとして切り出されていないため、コードをそのまま流用することは難しい。また、GPLライセンスであるため、コードをコピー＆ペーストしてクローズドソースの製品を作ることはできない。あくまで「ロジックの参考」として扱うべきである。4.3 keymap-editor (最有力なSVGレンダリング参照先)URL: https://github.com/nickcoutsos/keymap-editor 10開発者: Nick Coutsos役割: ZMKファームウェア向けのキーマップエディタライセンス: MIT技術スタック: React, SVG調査からの洞察:本プロジェクトの要件に最も近い実装である。KLE形式やZMKのDevicetree形式を読み込み、ブラウザ上でSVGを用いて美しくレンダリングしている。特に、ISOエンターキーのような非矩形キーの描画において、SVGパスを用いたアプローチを積極的に採用しており、その実装コードは極めて参考になる18。推奨アクション: Reactを採用する場合、このリポジトリのレンダリング部分（KeyコンポーネントやKeyboardLayoutコンポーネント）の設計パターンを模倣することを強く推奨する。MITライセンスであるため、コードの再利用も比較的容易である。4.4 remap-keys/remap (WebHID通信の参照先)URL: https://github.com/remap-keys/remap 19役割: ブラウザからキーボードへの書き込みライセンス: GPL-3.0 (要確認: リポジトリ内のLICENSEファイルを参照)調査からの洞察:「Remapツール作成中」というユーザーの状況を鑑みると、可視化だけでなく「キーボードへの設定書き込み」もスコープに含まれる。remapは、WebHID APIを使用してブラウザとキーボード（QMK RawHIDプロトコル）間の通信を確立している。技術的ポイント: QMKファームウェア側でVIA_ENABLE = yesまたはRawHID機能が有効になっている必要がある。JavaScript側でnavigator.hid.requestDevice()を呼び出し、ベンダーID/プロダクトIDでデバイスを特定し、バイナリパケットを送受信する実装が必要となる。5. QMKとの紐付け（Association）の詳細ロジック「QMKの紐づけ」という要件は、単に絵を描くだけでなく、その絵に対する操作をファームウェアのデータ構造に反映させることを意味する。5.1 データフローの設計入力:Visual Data (KLE JSON): ユーザーがデザインした、またはプリセットとして用意されたキーの配置図。Logical Data (QMK info.json): キーボードのマトリックス回路図（どのスイッチがどのピンに繋がっているか）。マッピング処理:ビジュアル上のキー（例: 左上のEscキー）は、KLEデータ上では index: 0, x: 0, y: 0 である。論理上のキーは、info.json上では matrix: （0行0列）である。アプリ起動時、またはレイアウト読み込み時に、この2つを結合したオブジェクト配列を生成する。結合例:JavaScriptconst integratedKey = {
visual: { x: 0, y: 0, w: 1, h: 1 }, // SVG描画用
logical: { row: 0, col: 0 }, // QMKデータ生成用
currentKeycode: 'KC_ESC' // 現在の設定値
};
ユーザーインタラクション:ユーザーが画面上のキー（SVG要素）をクリックする。イベントハンドラがintegratedKeyオブジェクトを参照する。キーコード選択モーダルを表示し、ユーザーが新しいキー（例: KC_A）を選択する。アプリ内部の状態（State）にある keymap の値を KC_ESC から KC_A に更新する。出力:更新されたキーマップ配列をJSONとしてエクスポートするか、WebHID経由でキーボードのEEPROMに直接書き込む。5.2 info.jsonがない場合の対応自作キーボード（ハンドワイヤリング）の場合、QMK公式リポジトリにinfo.jsonが存在しない場合がある。その場合、ツール側で簡易的なマトリックス生成機能（「左上から順に 0,0 -> 0,1 ->... と割り当てる」など）を提供するか、ユーザーにマトリックス定義を入力させるUIが必要となる。6. ライセンスとオープンソース戦略の比較開発するツールを公開する場合、または商用利用する場合、採用するライブラリのライセンスは法的に重要な意味を持つ。ライブラリ/プロジェクトライセンス特徴採用時の注意点kle-serialMIT制限が緩い商用・非商用問わず、著作権表示のみで自由に利用・改変・組み込みが可能。最も安全な選択肢。keymap-editorMIT制限が緩い同上。レンダリングロジックの参照先として最適。qmk_configuratorGPL-3.0コピーレフトこのコードを流用（コピー）して作成したツールは、必ずGPL-3.0で公開し、ソースコードを開示しなければならない。クローズドな商用アプリには使用不可。remapGPL-3.0 (要確認)コピーレフト同上。WebHID通信部分のロジックを参考にする際は、ライセンス汚染に注意が必要。ロジックを理解して自前で再実装すれば回避可能。react-simple-keyboardMIT制限が緩いライセンス的には使いやすいが、機能要件（ISOエンター、回転）を満たさないため、採用候補から除外すべき。推奨戦略:基本的にはMITライセンスのライブラリ（kle-serial）を中心に構成し、GPLのプロジェクト（QMK, Remap）はあくまで「仕様の理解」や「APIの挙動確認」のための参考資料として利用するに留め、コードの直接的なコピーは避けるのが賢明である。これにより、将来的にツールを商用化したり、独自のライセンスで配布したりする際の柔軟性を確保できる。7. 実装ロードマップと技術要件まとめユーザーの目標である「Web UIでのリアルなキーボード表示とQMK連携ツール」を実現するための具体的なステップを以下に示す。Step 1: 開発環境とベース技術の選定フレームワーク: React または Vue.js（keymap-editorの知見を活かすならReact、QMK Configuratorに親和性を感じるならVue）。言語: TypeScript（複雑なキーボードデータの型定義に必須）。ビルドツール: Vite（高速な開発体験のため）。Step 2: パーサーの実装kle-serialをnpmインストール。ファイルアップロード機能を作成し、KLE JSONを読み込んでコンソールに解析結果（座標データ）を表示するまでを実装。Step 3: SVGレンダリングエンジンの開発解析されたキー配列をmap関数で展開し、SVG要素を描画するコンポーネントを作成。矩形キー: <rect>タグで描画。rx, ry属性で角丸（Radius）を表現し、よりリアルなキーキャップ感を出す。ISOエンター: 形状判定ロジックを実装し、<path d="...">タグで描画。スタイル: CSSでキーキャップの色（Keycap color）や刻印（Legend）のスタイルを適用。立体感を出すためにSVGフィルター（ドロップシャドウ等）を活用すると「リアルさ」が増す。Step 4: QMKデータとの統合QMK API (http://api.qmk.fm/v1/keyboards) からinfo.jsonを取得する機能、またはローカルのinfo.jsonを読み込む機能を実装。ビジュアル上のキーとマトリックス上のインデックスを紐付けるロジックを実装。Step 5: WebHID通信の実装（Remap機能）navigator.hid APIを用いてデバイス接続機能を実装。QMKのRawHIDプロトコル仕様に基づき、レイヤーデータやキーコードデータの送受信パケットを構築。8. 結論「リアルなサイズ」でのキーボードレイアウト表示とQMK連携を実現するためには、汎用的な仮想キーボードライブラリの使用を避け、SVG技術を用いた独自のレンダリングエンジンを構築する必要がある。その際、kle-serialをデータ解析の要とし、keymap-editor (MIT) のレンダリングロジックを参照しつつ、qmk_configurator (GPL) のマトリックス管理ロジックから仕様を学ぶというアプローチが、技術的にもライセンス的にも最適解である。この構成により、ISOエンターキーのような複雑な形状も正確に再現しつつ、QMKファームウェアとの堅牢な連携機能を持つツールが実現可能となる。補足資料：主要データ構造の比較特徴KLE JSONQMK info.json主な用途視覚的デザイン（見た目）ファームウェア設定（機能・配線）座標系相対座標（前のキー基準）絶対座標（Key Units）単位1u (約19.05mm)1u (約19.05mm)必須情報キーの大きさ、位置、ラベル、色マトリックス位置 (Row, Col)、物理位置回転対応あり (Rotation Origin, Angle)なし（視覚用データとしては持たないことが多い）ツールでの扱いインポート用データシステム連携用データ以上が、ユーザーの要件に基づいた詳細な技術調査報告である。
