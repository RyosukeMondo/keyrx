# Tasks Document

- [ ] 1. Add macOS dependencies to Cargo.toml
  - File: keyrx_daemon/Cargo.toml
  - Add target-specific dependencies for macOS: rdev, enigo, iokit-sys, objc2, accessibility-sys
  - Configure feature gates for macOS platform
  - Purpose: Enable macOS-specific crate dependencies
  - _Leverage: Existing Windows target dependencies pattern in keyrx_daemon/Cargo.toml_
  - _Requirements: REQ-7_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer specializing in dependency management and cross-platform builds | Task: Add macOS target-specific dependencies to keyrx_daemon/Cargo.toml following REQ-7, using the existing Windows dependency pattern as reference. Dependencies needed: rdev = "0.5.3", enigo = "0.2", iokit-sys = "0.4", objc2 = "0.5", accessibility-sys = "0.1". Note that tray-icon is already present and cross-platform. | Restrictions: Must use target-specific dependency syntax `[target.'cfg(target_os = "macos")'.dependencies]`, do not modify existing Linux/Windows dependencies, ensure versions are compatible with Rust 1.70+ MSRV | _Leverage: keyrx_daemon/Cargo.toml Windows dependency pattern_ | _Requirements: REQ-7_ | Success: Cargo build succeeds on macOS target with all dependencies resolved, no dependency conflicts with existing platforms | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Implement the changes, 3) Use log-implementation tool to record the implementation with detailed artifacts (files modified, dependencies added), 4) Mark task as complete `[x]` in tasks.md

- [ ] 2. Create macOS platform module structure
  - Files: keyrx_daemon/src/platform/macos/mod.rs, input_capture.rs, output_injection.rs, device_discovery.rs, keycode_map.rs, tray.rs, permissions.rs
  - Create directory structure and skeleton module files
  - Define MacosPlatform struct
  - Purpose: Establish module organization for macOS platform code
  - _Leverage: keyrx_daemon/src/platform/windows/ directory structure as reference_
  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-4, REQ-5_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Software Architect specializing in Rust module organization and platform abstraction | Task: Create macOS platform module structure following requirements REQ-1 through REQ-5, mirroring the Windows platform directory structure. Create keyrx_daemon/src/platform/macos/ directory with skeleton files: mod.rs (MacosPlatform struct), input_capture.rs, output_injection.rs, device_discovery.rs, keycode_map.rs, tray.rs, permissions.rs. Each file should have module-level documentation (`//!`) and basic structure. | Restrictions: Must follow naming conventions from structure.md (snake_case files, PascalCase structs), include proper module documentation, do not implement logic yet (skeleton only), ensure all files compile with empty implementations | _Leverage: keyrx_daemon/src/platform/windows/ module structure_ | _Requirements: REQ-1, REQ-2, REQ-3, REQ-4, REQ-5_ | Success: Directory structure created, all skeleton files compile without errors, module organization matches Windows pattern, each file has clear documentation | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Create all skeleton files, 3) Use log-implementation tool to record file creations and module structure, 4) Mark task as complete `[x]` in tasks.md

- [ ] 3. Implement MacosPlatform struct and Platform trait
  - File: keyrx_daemon/src/platform/macos/mod.rs
  - Implement MacosPlatform struct with Platform trait methods
  - Add initialization and shutdown logic
  - Purpose: Provide main platform abstraction implementation
  - _Leverage: keyrx_daemon/src/platform/mod.rs Platform trait definition, keyrx_daemon/src/platform/windows/mod.rs implementation pattern_
  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-4_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Platform Engineer with expertise in Rust trait implementation and system programming | Task: Implement MacosPlatform struct and all Platform trait methods following REQ-1 through REQ-4. Structure should contain MacosInputCapture, MacosOutputInjector, and devices Vec. Implement initialize() with Accessibility permission check, capture_input() delegating to MacosInputCapture, inject_output() delegating to MacosOutputInjector, list_devices() delegating to device_discovery module, and shutdown() with cleanup logic. | Restrictions: Must implement all Platform trait methods exactly, do not modify trait definition, ensure proper error handling with PlatformError enum, maintain thread safety for event processing | _Leverage: keyrx_daemon/src/platform/mod.rs Platform trait, keyrx_daemon/src/platform/windows/mod.rs pattern, keyrx_daemon/src/platform/common.rs PlatformError_ | _Requirements: REQ-1, REQ-2, REQ-3, REQ-4_ | Success: MacosPlatform implements Platform trait completely, compiles without errors, proper error propagation, initialization checks Accessibility permission | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Implement MacosPlatform, 3) Use log-implementation tool to record implementation with artifacts (classes created, methods implemented, integrations with permission checker), 4) Mark task as complete `[x]` in tasks.md

- [ ] 4. Implement Accessibility permission checker
  - File: keyrx_daemon/src/platform/macos/permissions.rs
  - Implement check_accessibility_permission() using accessibility-sys crate
  - Implement get_permission_error_message() with detailed instructions
  - Purpose: Detect and report Accessibility permission status
  - _Leverage: accessibility-sys crate AXIsProcessTrusted API_
  - _Requirements: REQ-5_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: macOS Developer with expertise in Accessibility APIs and user-facing error messages | Task: Implement Accessibility permission detection and error messaging following REQ-5. Create check_accessibility_permission() function using unsafe AXIsProcessTrusted() from accessibility-sys crate. Create get_permission_error_message() returning comprehensive setup instructions including: System Preferences navigation, unlock with password, checkbox location, restart requirement, and link to docs. | Restrictions: Must use unsafe block only for AXIsProcessTrusted() call, error message must be actionable and user-friendly, do not assume user technical knowledge, include URL to documentation | _Leverage: accessibility-sys::accessibility::AXIsProcessTrusted_ | _Requirements: REQ-5_ | Success: Permission check works correctly, error message is clear and actionable, unsafe code is minimal and documented, compiles on macOS target | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Implement permission checker, 3) Use log-implementation tool to record functions created and safety documentation, 4) Mark task as complete `[x]` in tasks.md

- [ ] 5. Implement CGKeyCode to KeyRx keycode mapping
  - File: keyrx_daemon/src/platform/macos/keycode_map.rs
  - Create bidirectional mapping between CGKeyCode (u16) and keyrx KeyCode enum
  - Implement rdev::Key and enigo::Key conversions
  - Purpose: Enable key code translation for input capture and output injection
  - _Leverage: keyrx_daemon/src/platform/windows/keycode.rs mapping pattern, keyrx_core KeyCode enum_
  - _Requirements: REQ-1, REQ-2_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Systems Developer with expertise in keyboard input systems and macOS virtual key codes | Task: Implement comprehensive keycode mapping following REQ-1 and REQ-2. Create functions: cgkeycode_to_keyrx(u16) -> Option<KeyCode>, keyrx_to_cgkeycode(KeyCode) -> Option<u16>, rdev_key_to_keyrx(rdev::Key) -> Option<KeyCode>, keyrx_to_enigo_key(KeyCode) -> Option<enigo::Key>. Cover 100+ keys: A-Z (0x00-0x19), 0-9, modifiers (Shift, Ctrl, Cmd, Option), function keys (F1-F20), special keys (Escape 0x35, Return 0x24, Tab, Space, Delete, etc). Reference: https://developer.apple.com/documentation/appkit/nsevent/specialkey | Restrictions: Must maintain bidirectional consistency (roundtrip property), follow Windows keycode.rs pattern, handle unmapped keys gracefully with None, include comprehensive tests for all mappings | _Leverage: keyrx_daemon/src/platform/windows/keycode.rs, keyrx_core KeyCode enum_ | _Requirements: REQ-1, REQ-2_ | Success: All 100+ macOS key codes mapped correctly, bidirectional mapping verified, comprehensive unit tests pass, no panics on unmapped keys | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Implement keycode mappings with tests, 3) Use log-implementation tool to record functions created and mapping coverage, 4) Mark task as complete `[x]` in tasks.md

- [ ] 6. Implement macOS input capture using rdev
  - File: keyrx_daemon/src/platform/macos/input_capture.rs
  - Create MacosInputCapture struct using rdev crate for CGEventTap abstraction
  - Implement event capture with channel-based architecture
  - Purpose: Capture keyboard events from macOS using safe Rust wrapper
  - _Leverage: rdev::listen API, keycode_map::rdev_key_to_keyrx, std::sync::mpsc_
  - _Requirements: REQ-1_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Concurrent Systems Developer with expertise in Rust async/channel patterns and event-driven architectures | Task: Implement macOS keyboard input capture following REQ-1. Create MacosInputCapture struct with event_rx: Receiver<KeyEvent> field. Implement new() method that spawns a thread running rdev::listen() callback, converts rdev::Event to KeyEvent using keycode_map, sends events via channel. Implement next_event() method that blocks on channel recv. Handle EventType::KeyPress and EventType::KeyRelease, ignore other event types. | Restrictions: Must use safe Rust (rdev handles unsafe FFI), ensure thread safety with channels, handle channel disconnect gracefully, do not block main thread in new(), must achieve <1ms capture latency | _Leverage: rdev::listen, rdev::Event, keycode_map::rdev_key_to_keyrx, std::sync::mpsc_ | _Requirements: REQ-1_ | Success: Input capture works correctly, events flow through channel, conversion to KeyEvent correct, thread spawns successfully, no race conditions | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Implement input capture, 3) Use log-implementation tool to record classes created and threading architecture, 4) Mark task as complete `[x]` in tasks.md

- [ ] 7. Implement macOS output injection using enigo
  - File: keyrx_daemon/src/platform/macos/output_injection.rs
  - Create MacosOutputInjector struct using enigo crate for CGEventPost abstraction
  - Implement event injection with proper error handling
  - Purpose: Inject remapped keyboard events to macOS
  - _Leverage: enigo::Enigo API, keycode_map::keyrx_to_enigo_key_
  - _Requirements: REQ-2_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Systems Developer with expertise in macOS input injection and Rust error handling | Task: Implement macOS keyboard output injection following REQ-2. Create MacosOutputInjector struct with enigo: Enigo field. Implement new() method creating Enigo with default settings, returning PlatformError on failure. Implement inject() method taking KeyEvent, converting to enigo::Key via keycode_map, calling enigo.key() with Direction::Press or Direction::Release, returning PlatformError::OutputDeviceError on failure. | Restrictions: Must use safe Rust (enigo handles unsafe FFI), proper error propagation, no panics, handle both Press and Release events, must achieve <1ms injection latency | _Leverage: enigo::Enigo, enigo::Direction, keycode_map::keyrx_to_enigo_key, keyrx_daemon/src/platform/common::PlatformError_ | _Requirements: REQ-2_ | Success: Output injection works correctly, KeyEvents convert properly, error handling robust, latency <1ms, compiles on macOS target | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Implement output injection, 3) Use log-implementation tool to record classes and error handling patterns, 4) Mark task as complete `[x]` in tasks.md

- [ ] 8. Implement IOKit device enumeration
  - File: keyrx_daemon/src/platform/macos/device_discovery.rs
  - Implement USB keyboard device enumeration using iokit-sys crate
  - Extract VID/PID/serial number with RAII safety wrappers
  - Purpose: Enumerate and identify USB keyboards for device-specific configs
  - _Leverage: iokit-sys::* APIs, core_foundation crate, keyrx_daemon/src/platform/common::DeviceInfo_
  - _Requirements: REQ-3_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Low-level Systems Programmer with expertise in macOS IOKit FFI and memory safety | Task: Implement IOKit USB device enumeration following REQ-3. Create list_keyboard_devices() function using unsafe iokit-sys APIs: IOServiceMatching(kIOUSBDeviceClassName), IOServiceGetMatchingServices(), IOIteratorNext(). Extract device properties: name, VID, PID, serial number. CRITICAL: Implement RAII wrapper IOObjectGuard for automatic IOObjectRelease() to prevent resource leaks. Return Vec<DeviceInfo>. Handle devices without serial numbers by generating stable IDs. | Restrictions: Must use unsafe blocks only where necessary, document all safety invariants, implement RAII for all IOKit objects (iterator, devices), test for resource leaks, handle all error cases gracefully, target <5% unsafe code in this file | _Leverage: iokit-sys::*, core_foundation::base::TCFType, keyrx_daemon/src/platform/common::DeviceInfo_ | _Requirements: REQ-3_ | Success: Device enumeration works correctly, no resource leaks (verify with Instruments), RAII wrappers prevent leaks, VID/PID/serial extracted correctly, compiles on macOS target | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Implement with RAII safety, 3) Use log-implementation tool to record unsafe code blocks and safety measures, 4) Mark task as complete `[x]` in tasks.md

- [ ] 9. Implement macOS system tray integration
  - File: keyrx_daemon/src/platform/macos/tray.rs
  - Create MacosSystemTray struct using tray-icon crate
  - Implement SystemTray trait with menu bar icon and context menu
  - Purpose: Provide macOS menu bar integration for daemon control
  - _Leverage: tray-icon crate (already in Cargo.toml), keyrx_daemon/src/platform/windows/tray.rs pattern_
  - _Requirements: REQ-4_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: macOS UI Developer with expertise in native menu bar applications and tray-icon crate | Task: Implement macOS system tray integration following REQ-4. Create MacosSystemTray struct implementing SystemTray trait. Use tray-icon crate to create menu bar icon with context menu items: "Open Web UI", "Reload Config", "Exit". Implement new() creating TrayIcon with TrayIconBuilder, poll_event() checking for menu item clicks, shutdown() cleaning up tray icon. Follow Windows tray.rs implementation pattern exactly (tray-icon is cross-platform). | Restrictions: Must implement SystemTray trait exactly, use existing tray-icon crate (do not add new dependencies), follow macOS HIG for menu bar items, handle menu events via channels, ensure proper cleanup on shutdown | _Leverage: tray-icon::TrayIconBuilder, tray-icon::menu::*, keyrx_daemon/src/platform/windows/tray.rs pattern_ | _Requirements: REQ-4_ | Success: Menu bar icon appears on macOS, context menu works correctly, menu item clicks detected, follows Windows implementation, compiles on macOS target | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Implement tray integration, 3) Use log-implementation tool to record UI components created, 4) Mark task as complete `[x]` in tasks.md

- [ ] 10. Update platform factory to include macOS
  - File: keyrx_daemon/src/platform/mod.rs
  - Add macOS arm to create_platform() factory function
  - Update conditional compilation to recognize macOS target
  - Purpose: Enable macOS platform selection at compile time
  - _Leverage: Existing create_platform() function (lines 320-337), Linux/Windows patterns_
  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-4_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with expertise in conditional compilation and factory patterns | Task: Update platform factory following REQ-1 through REQ-4. Add `#[cfg(target_os = "macos")]` arm to create_platform() function in keyrx_daemon/src/platform/mod.rs (lines 320-337). Return `Ok(Box::new(macos::MacosPlatform::new()?))`. Add module declaration: `#[cfg(target_os = "macos")] pub mod macos;` at top of file. | Restrictions: Must follow exact same pattern as Linux/Windows arms, do not modify existing platform arms, ensure only one platform is selected at compile time, proper error handling for MacosPlatform::new() | _Leverage: keyrx_daemon/src/platform/mod.rs create_platform() lines 320-337_ | _Requirements: REQ-1, REQ-2, REQ-3, REQ-4_ | Success: macOS platform selected on macOS target, factory compiles without errors, conditional compilation works correctly, MacosPlatform instantiated properly | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Update factory function, 3) Use log-implementation tool to record factory modification and integration point, 4) Mark task as complete `[x]` in tasks.md

- [ ] 11. Add macOS CI/CD pipeline
  - File: .github/workflows/ci.yml
  - Add macOS runner to GitHub Actions test matrix
  - Configure macOS-specific build and test steps
  - Purpose: Enable automated testing on macOS platform
  - _Leverage: Existing ci.yml Ubuntu/Windows jobs pattern_
  - _Requirements: REQ-7, REQ-8_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer with expertise in GitHub Actions and CI/CD pipelines | Task: Add macOS CI/CD following REQ-7 and REQ-8. Update .github/workflows/ci.yml to add `macos-latest` to os matrix. Configure steps: checkout, install Rust, build with `--target x86_64-apple-darwin`, run unit tests (`cargo test -p keyrx_daemon --lib macos`), run integration tests (`cargo test -p keyrx_daemon --test macos_integration`). Skip E2E tests requiring Accessibility permission (add comment explaining why). | Restrictions: Must follow existing Ubuntu/Windows pattern, do not duplicate steps, use matrix strategy, skip permission-dependent tests with clear logging, ensure tests run in parallel with other platforms | _Leverage: .github/workflows/ci.yml existing jobs_ | _Requirements: REQ-7, REQ-8_ | Success: macOS job runs in CI, builds succeed, unit tests pass, integration tests pass, E2E tests documented as manual-only, parallel execution with other platforms | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Update CI/CD config, 3) Use log-implementation tool to record CI/CD changes and test strategy, 4) Mark task as complete `[x]` in tasks.md

- [ ] 12. Create unit tests for keycode mapping
  - File: keyrx_daemon/src/platform/macos/keycode_map.rs (add tests module)
  - Write comprehensive tests for all keycode conversions
  - Add property-based tests for bidirectional mapping
  - Purpose: Ensure keycode mapping correctness and prevent regressions
  - _Leverage: proptest crate for property-based testing, keyrx_core::KeyCode enum_
  - _Requirements: REQ-8_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in Rust unit testing and property-based testing | Task: Create comprehensive keycode mapping tests following REQ-8. Add `#[cfg(test)] mod tests` to keycode_map.rs. Write tests: test_all_cgkeycodes_mapped (verify 100+ codes), test_bidirectional_mapping (roundtrip property: cgkeycode_to_keyrx(keyrx_to_cgkeycode(x)) == Some(x)), test_special_keys (Escape, Return, modifiers), test_unmapped_keys_return_none. Use proptest for property-based testing of bidirectional invariant. | Restrictions: Must achieve ≥80% coverage for keycode_map module, test both success and failure cases, verify all special keys explicitly, use property-based testing for exhaustive verification | _Leverage: proptest crate, keyrx_core::KeyCode_ | _Requirements: REQ-8_ | Success: All tests pass, 100+ keycodes verified, bidirectional property holds, coverage ≥80%, property-based tests run 1000+ cases | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Write comprehensive tests, 3) Use log-implementation tool to record test coverage and property-based testing, 4) Mark task as complete `[x]` in tasks.md

- [ ] 13. Create integration tests for input/output pipeline
  - File: keyrx_daemon/tests/macos_integration.rs
  - Test full capture → remap → inject flow with mocked components
  - Verify latency tracking and error handling
  - Purpose: Ensure macOS platform components work correctly together
  - _Leverage: Existing integration test patterns from Windows/Linux_
  - _Requirements: REQ-8_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Integration Test Engineer with expertise in Rust integration testing and mocking | Task: Create macOS integration tests following REQ-8. Create keyrx_daemon/tests/macos_integration.rs. Test scenarios: test_capture_to_inject_flow (mock rdev input, verify enigo output), test_device_enumeration (mock IOKit, verify DeviceInfo), test_permission_check_denied (mock AXIsProcessTrusted false), test_permission_check_granted (mock true). Mock external dependencies (rdev, enigo, IOKit) to avoid Accessibility permission requirement. | Restrictions: Must not require Accessibility permission (use mocks), test component integration not implementation, verify error propagation, ensure tests run in CI, no flaky tests | _Leverage: keyrx_daemon/tests/integration pattern_ | _Requirements: REQ-8_ | Success: Integration tests pass in CI without Accessibility permission, component interactions verified, error paths tested, tests are reliable and deterministic | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Write integration tests, 3) Use log-implementation tool to record test scenarios and mocking strategy, 4) Mark task as complete `[x]` in tasks.md

- [ ] 14. Create macOS setup documentation
  - File: docs/setup/macos.md
  - Write comprehensive macOS setup guide with screenshots
  - Document Accessibility permission grant process
  - Purpose: Help users successfully set up keyrx on macOS
  - _Leverage: Existing docs structure, permissions.rs error message content_
  - _Requirements: REQ-5, REQ-7_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with expertise in macOS system preferences and user documentation | Task: Create macOS setup documentation following REQ-5 and REQ-7. Write docs/setup/macos.md covering: installation (build from source, future binary releases), Accessibility permission grant (step-by-step with screenshots), troubleshooting (permission issues, CGEventTap failures), building from source (Cargo commands for x86_64 and ARM64), code signing (for contributors). Include screenshots for: System Preferences → Security & Privacy → Accessibility, daemon in permission list, menu bar icon. | Restrictions: Must be beginner-friendly (no assumed macOS expertise), include actual screenshots (or placeholders with descriptions), provide troubleshooting for common issues, link to Apple's official Accessibility documentation | _Leverage: keyrx_daemon/src/platform/macos/permissions.rs error message, docs/ existing structure_ | _Requirements: REQ-5, REQ-7_ | Success: Documentation is clear and actionable, covers all setup steps, includes screenshots, troubleshooting section comprehensive, follows existing docs style | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Write documentation, 3) Use log-implementation tool to record documentation sections created, 4) Mark task as complete `[x]` in tasks.md

- [ ] 15. Update main README with macOS support
  - File: README.md
  - Add macOS to supported platforms list
  - Add macOS installation instructions
  - Purpose: Inform users that macOS is now supported
  - _Leverage: Existing README.md platform support section_
  - _Requirements: REQ-7_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with expertise in README documentation and project promotion | Task: Update main README.md to include macOS support following REQ-7. Add macOS to "Supported Platforms" section alongside Linux and Windows. Add macOS installation instructions linking to docs/setup/macos.md. Update feature comparison table to show macOS column with feature parity indicators (✅ for supported, ⚠️ for limited). Mention Rust-first implementation and <1ms latency achievement. | Restrictions: Must maintain existing README style, keep macOS section concise (link to docs for details), update any platform-specific notes, do not remove or modify Linux/Windows sections | _Leverage: README.md existing structure_ | _Requirements: REQ-7_ | Success: macOS prominently listed in supported platforms, installation instructions clear, feature table updated, links to detailed docs work | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Update README, 3) Use log-implementation tool to record documentation updates, 4) Mark task as complete `[x]` in tasks.md

- [ ] 16. Add macOS to release workflow
  - File: .github/workflows/release.yml
  - Add macOS binary build to release pipeline
  - Configure code signing and notarization (if certificate available)
  - Purpose: Enable automated macOS binary releases
  - _Leverage: Existing release.yml Linux/Windows build jobs_
  - _Requirements: REQ-7_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Release Engineer with expertise in GitHub Actions and macOS code signing | Task: Update release workflow following REQ-7. Add macOS build job to .github/workflows/release.yml. Build for both x86_64-apple-darwin (Intel) and aarch64-apple-darwin (Apple Silicon). Create universal binary using lipo if possible. Add code signing step using Developer ID certificate (from secrets, conditional if available). Add notarization step using xcrun notarytool (conditional if certificate available). Upload binaries to GitHub Releases with platform suffix (keyrx-macos-x64.tar.gz, keyrx-macos-arm64.tar.gz). | Restrictions: Must build both Intel and ARM64, code signing optional (check for secrets first), notarization optional, follow existing release asset naming, include checksums (SHA256) | _Leverage: .github/workflows/release.yml existing jobs_ | _Requirements: REQ-7_ | Success: macOS binaries built on release, both architectures supported, code signing works if configured, release assets uploaded correctly | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Update release workflow, 3) Use log-implementation tool to record build pipeline and signing configuration, 4) Mark task as complete `[x]` in tasks.md

- [ ] 17. Create manual E2E test checklist
  - File: docs/testing/macos-e2e-checklist.md
  - Document manual testing procedures for macOS platform
  - Create pre-release verification checklist
  - Purpose: Ensure thorough manual testing before releases
  - _Leverage: Design document E2E testing section_
  - _Requirements: REQ-8_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in manual testing and test documentation | Task: Create manual E2E testing checklist following REQ-8. Document in docs/testing/macos-e2e-checklist.md. Include checkboxes for: event capture latency <1ms (with measurement method), event injection latency <1ms, menu bar icon appears, menu items work, config reload <500ms, device enumeration lists keyboards, cross-device modifiers work, daemon survives 10000 key presses, memory usage <50MB (1 hour session), CPU usage <1% idle and <5% loaded, no memory leaks (Xcode Instruments), permission grant flow, first-time setup experience. | Restrictions: Must be comprehensive enough to catch regressions, include measurement methods for performance metrics, specify tools for verification (Instruments, Activity Monitor), realistic test scenarios | _Leverage: Design document E2E testing section_ | _Requirements: REQ-8_ | Success: Checklist covers all critical user scenarios, performance metrics measurable, clear pass/fail criteria, usable by testers without deep technical knowledge | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Create checklist, 3) Use log-implementation tool to record testing procedures documented, 4) Mark task as complete `[x]` in tasks.md

- [ ] 18. Performance benchmarking and optimization
  - Files: keyrx_daemon/benches/macos_latency.rs
  - Create latency benchmarks for macOS platform
  - Verify <1ms latency requirement
  - Purpose: Ensure macOS meets performance requirements
  - _Leverage: criterion crate (already in Cargo.toml), existing benchmark patterns_
  - _Requirements: REQ-1, REQ-2, REQ-6_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Performance Engineer with expertise in Rust benchmarking and low-latency systems | Task: Create performance benchmarks following REQ-1, REQ-2, and REQ-6. Write keyrx_daemon/benches/macos_latency.rs using criterion crate. Benchmark: input capture latency (rdev event to KeyEvent conversion), output injection latency (KeyEvent to CGEventPost), full pipeline latency (capture → core processing → inject), keycode lookup latency (should match existing O(1) MPHF performance). Set criterion targets: p95 latency <1ms for full pipeline, p50 <500μs, p99 <2ms. | Restrictions: Must use criterion for statistical rigor, benchmark on real macOS hardware (not CI), isolate platform code from core processing, measure actual system latency (include OS overhead), run benchmarks for 10+ seconds for statistical significance | _Leverage: criterion crate, existing benchmark patterns, keyrx_core benchmarks_ | _Requirements: REQ-1, REQ-2, REQ-6_ | Success: Benchmarks show p95 <1ms, results reproducible, statistical analysis shows no regressions, latency matches Linux/Windows | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Create benchmarks and run, 3) Use log-implementation tool to record benchmark results and performance analysis, 4) Mark task as complete `[x]` in tasks.md

- [ ] 19. Final integration and cross-platform verification
  - Files: All macOS platform files
  - Test identical .krx config on Linux, Windows, and macOS
  - Verify byte-for-byte behavior match
  - Purpose: Ensure complete cross-platform compatibility
  - _Leverage: Existing test configurations, multi-device config examples_
  - _Requirements: REQ-6_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior QA Engineer with expertise in cross-platform testing and deterministic behavior verification | Task: Perform final cross-platform verification following REQ-6. Test same .krx configuration on Linux, Windows, and macOS. Verify: same input produces same output on all platforms, tap-hold timing identical, DFA state transitions identical, multi-device configs work identically, ExtendedState (255 modifiers/locks) works identically. Use deterministic testing with virtual clock to ensure reproducibility. Document any platform-specific limitations (e.g., exclusive grab not available on macOS). | Restrictions: Must test on real hardware for all three platforms, use identical .krx binary, verify deterministic behavior (same input sequence → same output), document any differences with justification, ensure core logic unchanged | _Leverage: Existing test configs, keyrx_core simulator, deterministic testing framework_ | _Requirements: REQ-6_ | Success: Identical behavior verified across all platforms, no unexpected differences, limitations documented, core logic untouched, cross-platform compatibility confirmed | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Run cross-platform tests, 3) Use log-implementation tool to record test results and platform parity verification, 4) Mark task as complete `[x]` in tasks.md

- [ ] 20. Documentation review and cleanup
  - Files: All documentation files created/modified
  - Review all documentation for accuracy and completeness
  - Ensure consistency across platform docs
  - Purpose: Provide high-quality documentation for macOS users
  - _Leverage: docs/ existing documentation, project documentation standards_
  - _Requirements: All_
  - _Prompt: Implement the task for spec macos-support, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior Technical Writer with expertise in documentation quality and consistency | Task: Review and finalize all documentation covering all requirements. Review files: docs/setup/macos.md, docs/testing/macos-e2e-checklist.md, README.md, inline code documentation (rustdoc comments). Verify: accuracy (no outdated info), completeness (all steps documented), consistency (matches Linux/Windows docs style), clarity (beginner-friendly), links work (no broken URLs), screenshots present or placeholders clear, troubleshooting comprehensive. Add cross-references between docs. | Restrictions: Must maintain consistency with existing docs, verify all technical claims are accurate, test all documented procedures, ensure beginner-friendly language, no assumptions about user knowledge | _Leverage: docs/ structure, Rust documentation standards_ | _Requirements: All_ | Success: All documentation reviewed and accurate, consistent style across platforms, no broken links, procedures tested and verified, ready for public release | Instructions: After completing this task: 1) Mark task as in-progress `[-]` in .spec-workflow/specs/macos-support/tasks.md, 2) Review all docs, 3) Use log-implementation tool to record documentation review and fixes, 4) Mark task as complete `[x]` in tasks.md
