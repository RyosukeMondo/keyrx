{
  "id": "snapshot_1766288402668_y3vh8orcq",
  "approvalId": "approval_1766288402663_5u2kr81es",
  "approvalTitle": "Product vision and goals for keyrx",
  "version": 1,
  "timestamp": "2025-12-21T03:40:02.668Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Product Overview\n\n## Product Purpose\n\nkeyrx is an ultra-low latency, deterministic keyboard remapping system that bridges the gap between firmware-level solutions (like QMK) and OS-level software remappers (like Karabiner-Elements, AutoHotKey). Built in Rust, keyrx delivers firmware-class performance (<1ms latency) with software-level flexibility, enabling professional users and competitive gamers to customize their keyboard input without hardware constraints or compilation barriers.\n\nThe system solves the fundamental trade-off in keyboard customization: **firmware solutions are fast but inflexible**, requiring hardware-specific implementations and recompilation for changes, while **OS-level solutions are flexible but slow**, suffering from garbage collection, interpreter overhead, and OS scheduler unpredictability.\n\n## Target Users\n\n### Primary Users\n\n1. **Professional Power Users**\n   - Need sub-millisecond response times for productivity workflows\n   - Require complex multi-layered keyboard configurations\n   - Want instant configuration changes without firmware flashing\n\n2. **Competitive Gamers**\n   - Demand deterministic, zero-lag input processing\n   - Need device-specific configurations (e.g., different mappings per keyboard)\n   - Require guaranteed performance under system load\n\n3. **AI Coding Agents**\n   - Unique design philosophy: \"AI Coding Agent First\"\n   - Need machine-verifiable configuration without human UAT\n   - Require deterministic, reproducible behavior for automated testing\n   - Must validate complex configurations (255 modifiers × 255 lock keys) programmatically\n\n### Pain Points Addressed\n\n- **Firmware Latency**: Traditional software remappers introduce 5-50ms latency (unacceptable for gaming/professional use)\n- **Configuration Complexity**: Managing 255 modifiers + 255 lock keys requires automated validation (impossible via manual testing)\n- **Hardware Lock-in**: Firmware solutions require specific keyboard hardware\n- **Deployment Friction**: Firmware changes require compilation and flashing; OS software changes are instant but slow\n\n## Key Features\n\n1. **Sub-Millisecond Latency Processing**\n   - Target: <100μs processing time (100x faster than typical OS remappers)\n   - Zero-copy deserialization with rkyv\n   - Lock-free ring buffers for event handling\n   - No heap allocation in hot path\n\n2. **Extreme Configuration Flexibility**\n   - Support for 255 custom modifier keys (vs. standard 8)\n   - Support for 255 custom lock keys\n   - Rhai scripting language for configuration DSL\n   - Compile-time evaluation: flexibility of scripting + performance of static tables\n\n3. **Cross-Platform OS Integration**\n   - Windows: Low-Level Hooks (WH_KEYBOARD_LL) + Raw Input for device identification\n   - Linux: evdev/uinput with EVIOCGRAB for kernel-level interception\n   - Device-specific configuration via serial number matching\n\n4. **Advanced Input Logic**\n   - Deterministic Finite Automaton (DFA) for Tap/Hold behavior\n   - Retroactive state correction (QMK-style Permissive Hold)\n   - O(1) key lookup via Minimal Perfect Hash Functions (MPHF)\n   - Combo keys and layer switching\n\n5. **AI-First Verification**\n   - Browser-based WASM simulation with cycle-accurate execution\n   - Deterministic Simulation Testing (DST) with virtual clock\n   - Property-based testing (PBT) with proptest\n   - Fuzz testing with cargo-fuzz\n   - 100% configuration verification without human UAT\n\n6. **Real-Time Simulation & Preview**\n   - React + WASM frontend runs identical core logic in browser\n   - Live visualization of state transitions (Pending → Held → Tapped)\n   - Edit-and-preview workflow: instant feedback on configuration changes\n\n## Business Objectives\n\n1. **Eliminate the Firmware vs. Software Trade-off**\n   - Achieve firmware-level latency (<1ms) in software\n   - Maintain software-level flexibility (no recompilation required)\n\n2. **Enable AI-Driven Configuration Management**\n   - Make keyboard remapping fully automatable by AI agents\n   - Eliminate manual testing as a validation bottleneck\n   - Support complex configurations beyond human testing capability\n\n3. **Create a Platform for Input Innovation**\n   - Enable experiments with novel input paradigms (255 modifiers, conditional layers)\n   - Provide foundation for input research and competitive optimization\n\n## Success Metrics\n\n### Performance Metrics\n- **Latency Budget**: <100μs processing time (target), <1ms maximum (hard requirement)\n- **Lookup Performance**: O(1) constant-time key lookup (verified via benchmarks)\n- **Determinism**: 100% reproducible behavior (same input → same output, verified via DST)\n\n### Quality Metrics\n- **Test Coverage**: 80% minimum, 90% for critical paths (enforced via CI)\n- **Zero Manual Testing**: All validation automated (no UAT phase)\n- **Fuzz Testing**: No crashes/panics under 1M+ random input sequences\n\n### User Experience Metrics\n- **Configuration Change Time**: <5 seconds from script edit to live deployment\n- **Simulation Accuracy**: WASM simulation matches daemon behavior byte-for-byte\n- **Error Detection**: Configuration errors caught at compile-time (before deployment)\n\n## Product Principles\n\n### 1. AI Coding Agent First\nkeyrx is designed to be verified, modified, and deployed by AI agents without human intervention. This means:\n- **CLI-first design**: Every GUI operation has a machine-readable CLI/API equivalent\n- **Deterministic behavior**: Same input always produces same output (no randomness, no time-dependent behavior in tests)\n- **Contract-based architecture**: Configuration (Rhai) and execution (Rust) separated by compile-time-verified IR\n\n### 2. Complete Determinism\n- Same input sequence + same configuration → identical output (bit-for-bit)\n- Time is virtualized in test environments (no wall-clock dependencies)\n- No undefined behavior, no race conditions, no non-deterministic optimizations\n\n### 3. Observability & Controllability\n- All internal state is inspectable (via debug mode, structured logging)\n- All operations are reversible or testable in isolation\n- Configuration is serialized to deterministic binary format (rkyv) for hash-based verification\n\n### 4. Zero-Cost Abstractions\n- High-level Rhai scripting for configuration\n- Low-level Rust execution with no runtime overhead\n- Compile-time transformation eliminates abstraction penalties\n\n### 5. Module Isolation\n- Core logic (keyrx_core) is `no_std` and OS-agnostic\n- Platform-specific code isolated in keyrx_daemon\n- WASM compatibility enables browser-based testing\n\n## Monitoring & Visibility\n\n### Development/Debug Mode\n- **Dashboard Type**: Browser-based React UI (also available as Electron/Tauri desktop app)\n- **Real-Time Updates**: WebSocket for live event streaming from daemon\n- **Key Metrics Displayed**:\n  - Current layer and active modifiers/locks (255-bit state vector)\n  - Event latency histogram (per-key processing time)\n  - State transition visualization (DFA states for Tap/Hold)\n  - Input device list with serial numbers\n- **Sharing Capabilities**: Configuration export as .krx binary or Rhai source\n\n### Production Mode\n- **Structured Logging**: JSON logs with timestamp, level, event type, context\n- **Performance Counters**: Latency percentiles (p50, p95, p99, max)\n- **Health Checks**: API endpoint for daemon status, active configuration hash\n\n## Future Vision\n\nkeyrx is positioned to become the standard platform for advanced input customization, enabling use cases currently impossible with existing tools.\n\n### Potential Enhancements\n\n- **Remote Configuration Management**\n  - Cloud sync for configurations across machines\n  - Version control integration (Git-based config history)\n  - Team/organization-level configuration sharing\n\n- **Analytics & Telemetry**\n  - Heatmaps of key usage patterns\n  - Latency trend analysis over time\n  - Configuration optimization recommendations (AI-suggested improvements)\n\n- **Extended Platform Support**\n  - macOS support (IOKit-based implementation)\n  - Mobile platforms (Android/iOS with accessibility APIs)\n  - Embedded systems (firmware alternative for custom keyboards)\n\n- **Advanced Input Features**\n  - Mouse remapping with same architecture\n  - Gesture recognition (chord detection, sequence patterns)\n  - Context-aware remapping (per-application configurations)\n  - Macro recording and playback with timing precision\n\n- **Ecosystem Development**\n  - Community configuration marketplace\n  - Plugin system for custom actions (shell commands, IPC triggers)\n  - Integration with productivity tools (IDE-aware layers, app-specific profiles)\n\n### Long-Term Vision\n\nkeyrx aims to redefine input systems as **programmable, verifiable, and AI-manageable infrastructure**. Just as compilers transformed high-level languages into optimized machine code, keyrx transforms high-level input intentions (Rhai scripts) into deterministic, hardware-speed execution.\n\nThe ultimate goal: **make input customization as powerful and accessible as code itself**, with the same rigor, testability, and automation that modern software development demands.\n",
  "fileStats": {
    "size": 9070,
    "lines": 187,
    "lastModified": "2025-12-21T03:39:55.513Z"
  },
  "comments": []
}