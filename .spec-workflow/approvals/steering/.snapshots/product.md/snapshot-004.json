{
  "id": "snapshot_1766292210813_m68bkdzgw",
  "approvalId": "approval_1766292183891_cs7e9mtk6",
  "approvalTitle": "Complete steering docs (multi-device + imports)",
  "version": 4,
  "timestamp": "2025-12-21T04:43:30.813Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Product Overview\n\n## Product Purpose\n\nkeyrx is an ultra-low latency, deterministic keyboard remapping system that bridges the gap between firmware-level solutions (like QMK) and OS-level software remappers (like Karabiner-Elements, AutoHotKey). Built in Rust, keyrx delivers firmware-class performance (<1ms latency) with software-level flexibility, enabling professional users and competitive gamers to customize their keyboard input without hardware constraints or compilation barriers.\n\nThe system solves the fundamental trade-off in keyboard customization: **firmware solutions are fast but inflexible**, requiring hardware-specific implementations and recompilation for changes, while **OS-level solutions are flexible but slow**, suffering from garbage collection, interpreter overhead, and OS scheduler unpredictability.\n\n## Target Users\n\n### Primary Users\n\n1. **Professional Power Users**\n   - Need sub-millisecond response times for productivity workflows\n   - Require complex multi-layered keyboard configurations\n   - Want instant configuration changes without firmware flashing\n\n2. **Competitive Gamers**\n   - Demand deterministic, zero-lag input processing\n   - Need device-specific configurations (e.g., different mappings per keyboard)\n   - Require guaranteed performance under system load\n\n3. **AI Coding Agents**\n   - Unique design philosophy: \"AI Coding Agent First\"\n   - Need machine-verifiable configuration without human UAT\n   - Require deterministic, reproducible behavior for automated testing\n   - Must validate complex configurations (255 modifiers × 255 lock keys) programmatically\n\n### Pain Points Addressed\n\n- **Firmware Latency**: Traditional software remappers introduce 5-50ms latency (unacceptable for gaming/professional use)\n- **Configuration Complexity**: Managing 255 modifiers + 255 lock keys requires automated validation (impossible via manual testing)\n- **Hardware Lock-in**: Firmware solutions require specific keyboard hardware\n- **Deployment Friction**: Firmware changes require compilation and flashing; OS software changes are instant but slow\n\n## Key Features\n\n1. **Sub-Millisecond Latency Processing**\n   - Target: <100μs processing time (100x faster than typical OS remappers)\n   - Zero-copy deserialization with rkyv\n   - Lock-free ring buffers for event handling\n   - No heap allocation in hot path\n\n2. **Extreme Configuration Flexibility**\n   - Support for 255 custom modifier keys (vs. standard 8)\n   - Support for 255 custom lock keys\n   - Rhai scripting language for configuration DSL\n   - Compile-time evaluation: flexibility of scripting + performance of static tables\n\n3. **Cross-Platform OS Integration**\n   - Windows: Low-Level Hooks (WH_KEYBOARD_LL) + Raw Input for device identification\n   - Linux: evdev/uinput with EVIOCGRAB for kernel-level interception\n   - Device-specific configuration via serial number matching\n\n4. **Advanced Input Logic**\n   - Deterministic Finite Automaton (DFA) for Tap/Hold behavior\n   - Retroactive state correction (QMK-style Permissive Hold)\n   - O(1) key lookup via Minimal Perfect Hash Functions (MPHF)\n   - Combo keys and layer switching\n\n5. **AI-First Verification**\n   - Browser-based WASM simulation with cycle-accurate execution\n   - Deterministic Simulation Testing (DST) with virtual clock\n   - Property-based testing (PBT) with proptest\n   - Fuzz testing with cargo-fuzz\n   - 100% configuration verification without human UAT\n\n6. **Real-Time Simulation & Preview**\n   - React + WASM frontend runs identical core logic in browser\n   - Live visualization of state transitions (Pending → Held → Tapped)\n   - Edit-and-preview workflow: instant feedback on configuration changes\n\n7. **Multi-Device Support with Cross-Device State** (QMK-Inspired)\n   - **N:M device-to-configuration mapping**: Multiple keyboards, modular configs\n   - **Serial number-based identification**: True per-device configs (not USB port-dependent)\n   - **Cross-device modifier sharing**: Hold Shift on Keyboard A, press A on Keyboard B → outputs 'A'\n   - **QMK-inspired global state**: Proven architecture from split keyboard firmware\n   - **Industry-first serial number support**: Fills gap left by Karabiner-Elements\n   - **Modular configuration**: Single entry point with Rhai imports for code reuse\n\n## Business Objectives\n\n1. **Eliminate the Firmware vs. Software Trade-off**\n   - Achieve firmware-level latency (<1ms) in software\n   - Maintain software-level flexibility (no recompilation required)\n\n2. **Enable AI-Driven Configuration Management**\n   - Make keyboard remapping fully automatable by AI agents\n   - Eliminate manual testing as a validation bottleneck\n   - Support complex configurations beyond human testing capability\n\n3. **Create a Platform for Input Innovation**\n   - Enable experiments with novel input paradigms (255 modifiers, conditional layers)\n   - Provide foundation for input research and competitive optimization\n\n## Success Metrics\n\n### Performance Metrics\n- **Latency Budget**: <100μs processing time (target), <1ms maximum (hard requirement)\n- **Lookup Performance**: O(1) constant-time key lookup (verified via benchmarks)\n- **Determinism**: 100% reproducible behavior (same input → same output, verified via DST)\n\n### Quality Metrics\n- **Test Coverage**: 80% minimum, 90% for critical paths (enforced via CI)\n- **Zero Manual Testing**: All validation automated (no UAT phase)\n- **Fuzz Testing**: No crashes/panics under 1M+ random input sequences\n\n### User Experience Metrics\n- **Configuration Change Time**: <5 seconds from script edit to live deployment\n- **Simulation Accuracy**: WASM simulation matches daemon behavior byte-for-byte\n- **Error Detection**: Configuration errors caught at compile-time (before deployment)\n\n## Product Principles\n\n### 1. AI Coding Agent First\nkeyrx is designed to be verified, modified, and deployed by AI agents without human intervention. This architectural philosophy is enabled by two foundational mechanisms:\n\n#### Single Source of Truth (SSOT)\n- **Unified Configuration Store**: All system state, configuration, and runtime parameters exist in a single, authoritative location (`.krx` binary format)\n- **Hash-Based Verification**: Configuration changes are verified via deterministic binary serialization—AI agents can confirm \"configuration A == configuration B\" with a simple hash comparison\n- **No Configuration Drift**: Daemon, UI, and tests all consume the same compiled artifact; impossible for frontend to show one behavior while daemon executes another\n- **Atomic Updates**: Configuration changes are all-or-nothing; no partial/inconsistent states during deployment\n\n#### Structured Logging for Machine Observability\n- **JSON-formatted logs**: Every event emitted in parseable JSON with strict schema (timestamp, level, service, event_type, context)\n- **AI-Readable Diagnostics**: AI agents parse logs to verify behavior, diagnose issues, and validate test outcomes without human interpretation\n- **Correlation IDs**: Request/event tracing through the entire pipeline (OS hook → remapping → injection)\n- **Never log secrets/PII**: Logs are safe for AI agents to consume and analyze without data leakage concerns\n\nThese mechanisms enable:\n- **CLI-first design**: Every GUI operation has a machine-readable CLI/API equivalent\n- **Deterministic behavior**: Same input always produces same output (no randomness, no time-dependent behavior in tests)\n- **Contract-based architecture**: Configuration (Rhai) and execution (Rust) separated by compile-time-verified IR\n- **Automated validation**: AI agents verify correctness by comparing hashes, parsing logs, and executing deterministic tests\n\n### 2. Complete Determinism\n- Same input sequence + same configuration → identical output (bit-for-bit)\n- Time is virtualized in test environments (no wall-clock dependencies)\n- No undefined behavior, no race conditions, no non-deterministic optimizations\n\n### 3. Observability & Controllability\n- All internal state is inspectable (via debug mode, structured logging)\n- All operations are reversible or testable in isolation\n- Configuration is serialized to deterministic binary format (rkyv) for hash-based verification\n\n### 4. Zero-Cost Abstractions\n- High-level Rhai scripting for configuration\n- Low-level Rust execution with no runtime overhead\n- Compile-time transformation eliminates abstraction penalties\n\n### 5. Module Isolation\n- Core logic (keyrx_core) is `no_std` and OS-agnostic\n- Platform-specific code isolated in keyrx_daemon\n- WASM compatibility enables browser-based testing\n\n## Monitoring & Visibility\n\n### Development/Debug Mode\n- **Dashboard Type**: Browser-based React UI (also available as Electron/Tauri desktop app)\n- **Real-Time Updates**: WebSocket for live event streaming from daemon\n- **Key Metrics Displayed**:\n  - Current layer and active modifiers/locks (255-bit state vector)\n  - Event latency histogram (per-key processing time)\n  - State transition visualization (DFA states for Tap/Hold)\n  - Input device list with serial numbers\n- **Sharing Capabilities**: Configuration export as .krx binary or Rhai source\n\n### Production Mode\n- **Structured Logging (AI-First Design)**:\n  - **Format**: JSON logs with strict schema: `{timestamp, level, service, event_type, context, correlation_id}`\n  - **Machine-Parseable**: AI agents can programmatically query, filter, and analyze logs without regex/text parsing fragility\n  - **Fail-Fast Validation**: Log schema violations are caught at compile-time (via typed logging macros)\n  - **Zero PII/Secrets**: Safe for automated analysis and storage without data privacy concerns\n  - **Example**: `{\"timestamp\":\"2025-12-21T03:40:15.234Z\",\"level\":\"INFO\",\"service\":\"keyrx_daemon\",\"event_type\":\"key_remap\",\"context\":{\"input\":\"KeyA\",\"output\":\"KeyB\",\"latency_us\":42},\"correlation_id\":\"evt_abc123\"}`\n- **Performance Counters**: Latency percentiles (p50, p95, p99, max) exposed via `/metrics` endpoint (Prometheus-compatible)\n- **Health Checks**: API endpoint for daemon status, active configuration hash (SSOT verification)\n- **Configuration Audit Trail**: All configuration changes logged with hash, timestamp, and source (CLI/API/UI)\n\n## Future Vision\n\nkeyrx is positioned to become the standard platform for advanced input customization, enabling use cases currently impossible with existing tools.\n\n### Potential Enhancements\n\n- **Remote Configuration Management**\n  - Cloud sync for configurations across machines\n  - Version control integration (Git-based config history)\n  - Team/organization-level configuration sharing\n\n- **Analytics & Telemetry**\n  - Heatmaps of key usage patterns\n  - Latency trend analysis over time\n  - Configuration optimization recommendations (AI-suggested improvements)\n\n- **Extended Platform Support**\n  - macOS support (IOKit-based implementation)\n  - Mobile platforms (Android/iOS with accessibility APIs)\n  - Embedded systems (firmware alternative for custom keyboards)\n\n- **Advanced Input Features**\n  - Mouse remapping with same architecture\n  - Gesture recognition (chord detection, sequence patterns)\n  - Context-aware remapping (per-application configurations)\n  - Macro recording and playback with timing precision\n\n- **Ecosystem Development**\n  - Community configuration marketplace\n  - Plugin system for custom actions (shell commands, IPC triggers)\n  - Integration with productivity tools (IDE-aware layers, app-specific profiles)\n\n### Long-Term Vision\n\nkeyrx aims to redefine input systems as **programmable, verifiable, and AI-manageable infrastructure**. Just as compilers transformed high-level languages into optimized machine code, keyrx transforms high-level input intentions (Rhai scripts) into deterministic, hardware-speed execution.\n\nThe ultimate goal: **make input customization as powerful and accessible as code itself**, with the same rigor, testability, and automation that modern software development demands.\n",
  "fileStats": {
    "size": 11911,
    "lines": 216,
    "lastModified": "2025-12-21T04:41:22.621Z"
  },
  "comments": []
}