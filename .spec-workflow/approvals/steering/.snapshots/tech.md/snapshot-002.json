{
  "id": "snapshot_1766289584589_xkslg43au",
  "approvalId": "approval_1766288947428_afjwxl7r9",
  "approvalTitle": "Technology architecture and decisions for keyrx",
  "version": 2,
  "timestamp": "2025-12-21T03:59:44.589Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Technology Stack\n\n## Project Type\n\n**System-level input remapping daemon with browser-based UI**\n\nkeyrx is a hybrid system combining:\n- **Low-level system daemon**: OS-specific input interception and injection\n- **Cross-platform core library**: Platform-agnostic remapping logic\n- **CLI compiler**: Rhai script → static binary transformation\n- **Web-based UI**: React + WASM for configuration and simulation\n\n## Core Technologies\n\n### Primary Language(s)\n- **Language**: Rust (edition 2021, stable channel)\n- **Compiler**: rustc 1.70+ with multiple compilation targets\n  - `x86_64-unknown-linux-gnu` (Linux daemon)\n  - `x86_64-pc-windows-msvc` (Windows daemon)\n  - `wasm32-unknown-unknown` (browser simulation)\n- **Language-specific tools**:\n  - **Cargo**: Build system and package manager\n  - **cargo-fuzz**: Fuzzing infrastructure (libFuzzer backend)\n  - **wasm-pack**: WASM build and npm packaging\n\n### Key Dependencies/Libraries\n\n#### Core Runtime (keyrx_core - no_std)\n- **rkyv** (0.7+): Zero-copy deserialization for configuration files\n  - Deterministic binary serialization\n  - Validation via bytecheck\n- **boomphf** (0.6+): Minimal Perfect Hash Function (MPHF) generation\n  - CHD algorithm for O(1) key lookup\n- **fixedbitset** (0.4+): Compact bitset for 255 modifiers/locks state\n- **arrayvec** (0.7+): Fixed-capacity vectors (no heap allocation)\n\n#### Scripting & Compilation (keyrx_compiler)\n- **rhai** (1.15+): Embedded scripting language for configuration DSL\n  - Compile-time evaluation only (not runtime)\n- **serde** (1.0+): Intermediate serialization before rkyv conversion\n\n#### OS Integration (keyrx_daemon)\n**Linux**:\n- **evdev** (0.12+): Input device handling via `/dev/input/event*`\n- **uinput** (0.1+): Virtual device creation via `/dev/uinput`\n- **nix** (0.26+): Safe wrappers for ioctl, epoll\n\n**Windows**:\n- **windows-sys** (0.48+): Raw Windows API bindings\n  - `SetWindowsHookEx` (WH_KEYBOARD_LL)\n  - `GetRawInputDeviceInfo` (device identification)\n  - `SendInput` (event injection)\n\n#### Concurrency & IPC\n- **crossbeam-channel** (0.5+): Lock-free MPMC channels for event queues\n- **memmap2** (0.7+): Memory-mapped files for zero-copy .krx loading\n- **parking_lot** (0.12+): Faster synchronization primitives (when needed outside hot path)\n\n#### Frontend (keyrx_ui)\n- **React** (18+): UI framework\n- **TypeScript** (5+): Type-safe JavaScript\n- **wasm-bindgen** (0.2+): Rust ↔ JavaScript FFI\n- **serde-wasm-bindgen** (0.5+): Serde serialization across WASM boundary\n\n#### Testing & Verification\n- **proptest** (1.2+): Property-based testing framework\n- **criterion** (0.5+): Benchmarking with statistical rigor\n- **cargo-fuzz**: Fuzz testing (integrated with libFuzzer)\n\n### Application Architecture\n\n**Four-Layer Architecture with Compile-Time Separation**:\n\n```\n┌─────────────────────────────────────────────┐\n│  keyrx_compiler (CLI)                       │\n│  - Rhai DSL parser                          │\n│  - MPHF generation (boomphf)                │\n│  - Outputs: .krx binary (rkyv)              │\n└─────────────────┬───────────────────────────┘\n                  │ (compile time only)\n                  ▼\n┌─────────────────────────────────────────────┐\n│  keyrx_core (no_std library)                │\n│  - Pure logic, no OS dependencies           │\n│  - DFA state machine (Tap/Hold)             │\n│  - MPHF-based O(1) lookup                   │\n│  - Compilable to WASM                       │\n└─────────────────┬───────────────────────────┘\n                  │ (embedded by)\n          ┌───────┴───────┐\n          ▼               ▼\n┌──────────────────┐ ┌─────────────────────┐\n│ keyrx_daemon     │ │ keyrx_ui (WASM)     │\n│ - OS hooks       │ │ - React frontend    │\n│ - evdev/uinput   │ │ - Browser simulator │\n│ - Windows LL     │ │ - Live preview      │\n│ - .krx loader    │ │                     │\n└──────────────────┘ └─────────────────────┘\n```\n\n**Key Architectural Principles**:\n- **no_std Core**: keyrx_core has zero OS dependencies, enabling WASM compilation\n- **Compile-Time Code Generation**: Rhai scripts → static Rust structures (MPHF tables, DFA)\n- **Single Source of Truth**: Both daemon and UI consume identical .krx binary\n- **Lock-Free Hot Path**: Input processing uses lock-free ring buffers, no mutexes\n\n### Data Storage\n\n#### Primary Storage\n- **Configuration Files (.krx)**:\n  - Format: rkyv-serialized binary (deterministic, zero-copy)\n  - Location: `~/.config/keyrx/` (Linux), `%APPDATA%\\keyrx\\` (Windows)\n  - Loading: Memory-mapped via memmap2 (no deserialization overhead)\n\n- **State Storage**:\n  - In-memory only: 255-bit modifier state, 255-bit lock state (fixedbitset)\n  - No persistent state (stateless daemon restart)\n\n#### Caching\n- **No explicit caching layer**: MPHF tables and memory-mapping provide O(1) access\n- **Kernel-level buffering**: evdev/Raw Input queues managed by OS\n\n#### Data Formats\n- **Configuration**: rkyv binary (internal), Rhai source (human-editable)\n- **Logs**: JSON (structured logging)\n- **IPC**: JSON over WebSocket (control channel), shared memory ring buffer (debug events)\n- **Frontend State**: React state (ephemeral), WASM linear memory (simulation)\n\n### External Integrations\n\n#### APIs\n- **OS Input Subsystem APIs** (core integration):\n  - Linux: evdev ioctl, uinput write\n  - Windows: SetWindowsHookEx, SendInput, GetRawInputDeviceInfo\n\n#### Protocols\n- **WebSocket**: Daemon ↔ UI real-time communication\n- **HTTP/REST**: Optional daemon control API (future)\n- **IPC**: Named pipes (Windows) / Unix sockets (Linux) for CLI ↔ daemon\n\n#### Authentication\n- **Not applicable**: Local system daemon (no network authentication)\n- **OS-level permissions**: Managed via udev rules (Linux) or admin privileges (Windows)\n\n### Monitoring & Dashboard Technologies\n\n#### Dashboard Framework\n- **React 18+**: Component-based UI\n- **TypeScript**: Type safety for complex state management\n- **Vite**: Build tool with hot module replacement (HMR)\n\n#### Real-time Communication\n- **WebSocket**: Daemon → UI event streaming\n  - Event types: configuration updates, input events (debug mode), latency metrics\n- **WASM Direct Calls**: UI → keyrx_core simulation (no network latency)\n\n#### Visualization Libraries\n- **Custom Canvas Rendering**: Keyboard layout visualization with state highlighting\n- **SVG-based State Diagrams**: DFA state transitions (Pending → Held → Tapped)\n- **Chart.js** (optional): Latency histograms, usage heatmaps\n\n#### State Management\n- **React useState/useReducer**: UI state (current layer, active devices)\n- **WASM Memory as SSOT**: Simulation state lives in keyrx_core (WASM), not JavaScript\n- **.krx File as Authoritative Source**: Both daemon and UI read same binary\n\n## Development Environment\n\n### Build & Development Tools\n\n#### Build System\n- **Cargo**: Primary build tool\n  - Workspace configuration for 4 crates\n  - Feature flags: `linux`, `windows`, `wasm`, `debug_ui`\n- **npm/pnpm**: Frontend build (keyrx_ui)\n- **Makefile**: Top-level orchestration (build all targets, run tests, fuzzing)\n\n#### Package Management\n- **Cargo**: Rust dependencies via Cargo.toml\n- **npm/pnpm**: JavaScript dependencies via package.json\n- **System packages**: evdev headers (Linux), Windows SDK (Windows)\n\n#### Development Workflow\n- **Daemon**: `cargo run --bin keyrx_daemon` with hot-reload config (watches .rhai files)\n- **Frontend**: `npm run dev` with Vite HMR\n- **Compiler**: `cargo run --bin keyrx_compiler -- config.rhai -o output.krx`\n- **WASM**: `wasm-pack build --target web` (auto-run by Vite)\n\n### Code Quality Tools\n\n#### Pre-Commit Hooks (Mandatory)\nPer CLAUDE.md requirements:\n- **clippy**: Linting (`cargo clippy -- -D warnings`)\n- **rustfmt**: Formatting (`cargo fmt --check`)\n- **Tests**: `cargo test --all` must pass\n- **Coverage**: `cargo tarpaulin` (80% minimum, 90% for keyrx_core)\n\n#### Static Analysis\n- **clippy**: Rust linter (pedantic mode enabled)\n- **cargo-deny**: License and dependency auditing\n- **cargo-audit**: Security vulnerability scanning\n\n#### Formatting\n- **rustfmt**: Rust code formatting (enforced in CI)\n- **prettier**: JavaScript/TypeScript formatting\n\n#### Testing Framework\n- **Built-in Rust test harness**: Unit tests\n- **proptest**: Property-based testing (1M+ generated test cases)\n- **cargo-fuzz**: Fuzzing with coverage-guided mutation\n- **criterion**: Performance benchmarks with regression detection\n- **Deterministic Simulation Testing (DST)**: Custom framework with virtual clock\n\n#### Documentation\n- **rustdoc**: API documentation (`cargo doc`)\n- **mdBook**: User guide and architecture documentation (future)\n\n### Version Control & Collaboration\n\n#### VCS\n- **Git**: Primary version control\n- **GitHub**: Hosting, CI/CD, issue tracking\n\n#### Branching Strategy\n- **Trunk-Based Development** (per CLAUDE.md: no backward compatibility required)\n- **Feature branches**: Short-lived (<3 days), merged to main after CI passes\n- **No release branches**: Rolling releases with semantic versioning\n\n#### Code Review Process\n- **Pull requests**: Required for all changes\n- **Automated checks**: clippy, rustfmt, tests, coverage, benchmarks\n- **Review focus**: Architecture, performance implications, test coverage\n\n### Dashboard Development\n\n#### Live Reload\n- **Vite HMR**: Instant frontend updates without page refresh\n- **WASM watch mode**: `wasm-pack build --dev` rebuilds on Rust core changes\n\n#### Port Management\n- **Frontend**: Default 5173 (Vite), configurable via `--port`\n- **WebSocket**: Default 9876 (daemon API), configurable via config file\n\n#### Multi-Instance Support\n- **Multiple daemons**: Not supported (single instance per user session)\n- **Multiple UIs**: Supported (read-only observers, single writer)\n\n## Deployment & Distribution\n\n### Target Platform(s)\n- **Linux**: x86_64, kernel 5.10+ (evdev requirement)\n  - Tested: Ubuntu 22.04+, Fedora 38+, Arch Linux\n- **Windows**: x86_64, Windows 10 1903+ (Low-Level Hooks stability)\n- **WASM**: Any modern browser (Chrome 90+, Firefox 88+, Safari 15+)\n\n### Distribution Method\n- **Binary releases**: GitHub Releases with pre-built binaries\n- **Package managers** (future):\n  - Linux: AUR (Arch), PPA (Ubuntu), Flatpak\n  - Windows: winget, Chocolatey\n- **Source builds**: `cargo install keyrx` (crates.io publication)\n\n### Installation Requirements\n\n**Linux**:\n- `udev` rules setup (auto-generated by installer)\n- Input group membership (non-root access to `/dev/input/event*`)\n\n**Windows**:\n- Administrator privileges for initial setup (Low-Level Hook registration)\n- User-mode execution after setup\n\n### Update Mechanism\n- **Manual**: Download new binary, restart daemon\n- **Auto-update** (future): Background downloader with signature verification\n\n## Technical Requirements & Constraints\n\n### Performance Requirements\n\n#### Hard Requirements\n- **Latency**: <1ms end-to-end (OS hook → processing → injection)\n  - Target: <100μs for 95th percentile\n- **Lookup**: O(1) constant-time key lookup (MPHF guarantee)\n- **Memory**: <50MB resident set size (daemon + loaded config)\n- **CPU**: <1% on idle, <5% under sustained input (1000 keys/sec)\n\n#### Benchmarks\n- **MPHF lookup**: <50ns (verified via criterion)\n- **DFA state transition**: <50ns\n- **rkyv deserialization**: <1μs (zero-copy validation)\n- **Event pipeline**: <100μs total (measured via tracing)\n\n### Compatibility Requirements\n\n#### Platform Support\n- **OS**: Linux 5.10+, Windows 10 1903+\n- **Architecture**: x86_64 (ARM64 future consideration)\n- **Desktop Environments**: X11, Wayland, Windows Desktop\n\n#### Dependency Versions\n- **Rust**: 1.70+ (MSRV - Minimum Supported Rust Version)\n- **glibc**: 2.31+ (Linux)\n- **WASM**: wasm32-unknown-unknown target (stable Rust)\n\n#### Standards Compliance\n- **Linux Input Subsystem**: evdev protocol compliance\n- **USB HID**: Standard HID usage tables (USB.org specification)\n- **Windows Input**: Windows Input Architecture compliance\n\n### Security & Compliance\n\n#### Security Requirements\n- **No secret logging**: PII/credentials excluded from logs (per CLAUDE.md)\n- **Memory safety**: Rust guarantees + `forbid(unsafe_code)` in keyrx_core\n- **Input validation**: All external input (Rhai scripts, IPC) validated before execution\n\n#### Threat Model\n- **Untrusted configurations**: Malicious .rhai scripts cannot execute arbitrary code (sandboxed Rhai engine)\n- **Privilege escalation**: Daemon runs with minimal required privileges (input group, not root)\n- **Log injection**: Structured JSON logging prevents injection attacks\n\n#### Compliance Standards\n- **Not applicable**: No PII collection, no network transmission (local-only system)\n\n### Scalability & Reliability\n\n#### Expected Load\n- **Input rate**: Up to 1000 events/sec (competitive gaming scenario)\n- **Configuration size**: Up to 10,000 remapping rules (MPHF handles efficiently)\n- **Concurrent users**: Single user per daemon instance\n\n#### Availability Requirements\n- **Uptime**: 99.9% (daemon restarts in <100ms)\n- **Graceful degradation**: If daemon crashes, input passes through unmodified (no stuck keys)\n- **State recovery**: Stateless design enables instant recovery after crash\n\n#### Growth Projections\n- **Not applicable**: Single-user system tool (no multi-tenancy)\n\n## Technical Decisions & Rationale\n\n### Decision Log\n\n#### 1. Rust Language Choice\n**Decision**: Use Rust for all performance-critical code (core, daemon, compiler)\n\n**Rationale**:\n- Memory safety without GC (sub-1ms latency requirement)\n- Zero-cost abstractions (high-level code → low-level performance)\n- WASM compilation support (browser simulation)\n- Strong type system (AI agent verification via compile-time checks)\n\n**Alternatives Considered**:\n- C++: Rejected due to undefined behavior risks, harder AI verification\n- Go: Rejected due to GC pauses (incompatible with <1ms latency)\n\n#### 2. Rhai for Configuration DSL\n**Decision**: Use Rhai scripting language, evaluated at compile-time only\n\n**Rationale**:\n- Rust-native (easy FFI, no C dependencies)\n- Sandboxed execution (no filesystem/network access)\n- Familiar syntax (JavaScript-like, low learning curve)\n- Compile-time evaluation eliminates runtime overhead\n\n**Alternatives Considered**:\n- Lua: Rejected (C dependency, harder WASM integration)\n- YAML/TOML: Rejected (insufficient expressiveness for 255 modifiers)\n- JavaScript (Deno): Rejected (heavy runtime, latency concerns)\n\n#### 3. rkyv Zero-Copy Serialization\n**Decision**: Use rkyv for .krx binary format\n\n**Rationale**:\n- Zero-copy deserialization (no parsing overhead)\n- Deterministic output (hash-based verification for AI agents)\n- Validation without full deserialization (bytecheck crate)\n- Memory-map friendly (direct access to mmap'd files)\n\n**Alternatives Considered**:\n- bincode: Rejected (requires deserialization, not zero-copy)\n- Protocol Buffers: Rejected (schema compilation complexity, not zero-copy)\n- MessagePack: Rejected (parsing overhead)\n\n#### 4. MPHF (Minimal Perfect Hash Function) for Lookup\n**Decision**: Use boomphf CHD algorithm for O(1) key lookup\n\n**Rationale**:\n- Guaranteed O(1) lookup (no hash collisions)\n- Compact representation (sparse keyspace → dense array)\n- Build time negligible (compile phase only)\n- Cache-friendly (sequential array access)\n\n**Alternatives Considered**:\n- std::HashMap: Rejected (non-deterministic, worst-case O(n), resize overhead)\n- Direct array indexing: Rejected (sparse keyspace wastes memory)\n- B-tree: Rejected (O(log n) lookup, not constant-time)\n\n#### 5. no_std Core Design\n**Decision**: keyrx_core is `#![no_std]` (no standard library)\n\n**Rationale**:\n- WASM compilation without std (smaller binary, faster)\n- Eliminates accidental heap allocation in hot path\n- Forces explicit dependency management (better for AI code analysis)\n- Proves core logic is OS-agnostic\n\n**Alternatives Considered**:\n- Full std support: Rejected (couples core to OS, harder to verify)\n\n#### 6. React + WASM Frontend (Not Electron/Tauri Initially)\n**Decision**: Web-based UI with WASM, packaged as local HTML later\n\n**Rationale**:\n- WASM simulation shares exact core code with daemon (no drift)\n- Faster iteration (web dev tools, HMR)\n- Cross-platform by default (same UI on Linux/Windows)\n- Lighter weight than Electron (future Tauri packaging possible)\n\n**Alternatives Considered**:\n- Native GUI (GTK/Qt): Rejected (platform-specific, no WASM simulation)\n- Electron: Rejected (bloat, slower startup)\n- TUI (terminal UI): Rejected (insufficient visualization for DFA/state)\n\n## Known Limitations\n\n### 1. Windows Hook Timeout Risk\n**Impact**: If keyrx_daemon processing exceeds ~300ms, Windows may silently unhook\n\n**Mitigation**: Lock-free event queue + immediate CallNextHookEx return\n\n**Future Solution**: Kernel driver (requires signing, deployment complexity)\n\n### 2. macOS Not Supported\n**Impact**: macOS users cannot use keyrx\n\n**Why**: Requires CGEventTap API research and implementation\n\n**Timeline**: Post-1.0 (after Linux/Windows stabilization)\n\n### 3. WASM Simulation Cannot Test OS-Specific Quirks\n**Impact**: evdev/Windows hook edge cases not testable in browser\n\n**Mitigation**: E2E tests on real OS (GitHub Actions matrix)\n\n**Future Solution**: Record/replay of OS events for deterministic testing\n\n### 4. 255 Modifiers/Locks May Exceed OS Virtual Key Limits\n**Impact**: Some OS key codes may conflict with custom modifier IDs\n\n**Mitigation**: Namespace separation (custom IDs start at 0x8000, above standard range)\n\n**Future Solution**: Virtual key remapping table (if needed)\n\n### 5. No Multi-User Support\n**Impact**: One keyrx_daemon per system (not per user session)\n\n**Why**: Global input hooks are system-wide (Windows) or require device grab (Linux)\n\n**Future Solution**: User-session isolation via systemd user services (Linux) or per-session hooks (Windows, complex)\n",
  "fileStats": {
    "size": 18423,
    "lines": 463,
    "lastModified": "2025-12-21T03:48:55.761Z"
  },
  "comments": []
}