{
  "id": "snapshot_1766290831152_zkderpo0q",
  "approvalId": "approval_1766290621877_ge7czmi3t",
  "approvalTitle": "Tech doc (added AI-friendly scripting)",
  "version": 5,
  "timestamp": "2025-12-21T04:20:31.152Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Technology Stack\n\n## Project Type\n\n**System-level input remapping daemon with browser-based UI**\n\nkeyrx is a hybrid system combining:\n- **Low-level system daemon**: OS-specific input interception and injection\n- **Cross-platform core library**: Platform-agnostic remapping logic\n- **CLI compiler**: Rhai script → static binary transformation\n- **Web-based UI**: React + WASM for configuration and simulation\n\n## Core Technologies\n\n### Primary Language(s)\n- **Language**: Rust (edition 2021, stable channel)\n- **Compiler**: rustc 1.70+ with multiple compilation targets\n  - `x86_64-unknown-linux-gnu` (Linux daemon)\n  - `x86_64-pc-windows-msvc` (Windows daemon)\n  - `wasm32-unknown-unknown` (browser simulation)\n- **Language-specific tools**:\n  - **Cargo**: Build system and package manager\n  - **cargo-fuzz**: Fuzzing infrastructure (libFuzzer backend)\n  - **wasm-pack**: WASM build and npm packaging\n\n### Key Dependencies/Libraries\n\n#### Core Runtime (keyrx_core - no_std)\n- **rkyv** (0.7+): Zero-copy deserialization for configuration files\n  - Deterministic binary serialization\n  - Validation via bytecheck\n- **boomphf** (0.6+): Minimal Perfect Hash Function (MPHF) generation\n  - CHD algorithm for O(1) key lookup\n- **fixedbitset** (0.4+): Compact bitset for 255 modifiers/locks state\n- **arrayvec** (0.7+): Fixed-capacity vectors (no heap allocation)\n\n#### Scripting & Compilation (keyrx_compiler)\n- **rhai** (1.15+): Embedded scripting language for configuration DSL\n  - Compile-time evaluation only (not runtime)\n- **serde** (1.0+): Intermediate serialization before rkyv conversion\n\n#### OS Integration & Web Server (keyrx_daemon)\n**Linux**:\n- **evdev** (0.12+): Input device handling via `/dev/input/event*`\n- **uinput** (0.1+): Virtual device creation via `/dev/uinput`\n- **nix** (0.26+): Safe wrappers for ioctl, epoll\n\n**Windows**:\n- **windows-sys** (0.48+): Raw Windows API bindings\n  - `SetWindowsHookEx` (WH_KEYBOARD_LL)\n  - `GetRawInputDeviceInfo` (device identification)\n  - `SendInput` (event injection)\n\n**Embedded Web Server** (optional feature, enabled by default):\n- **axum** (0.7+): Lightweight async web framework\n  - Serves static UI files (embedded at compile-time via `include_dir!`)\n  - WebSocket endpoint for real-time UI communication\n  - REST API for daemon control (status, config upload)\n- **tower-http** (0.5+): HTTP middleware (CORS, static file serving)\n- **tokio** (1.35+): Async runtime for web server + event processing\n\n#### Concurrency & IPC\n- **crossbeam-channel** (0.5+): Lock-free MPMC channels for event queues\n- **memmap2** (0.7+): Memory-mapped files for zero-copy .krx loading\n- **parking_lot** (0.12+): Faster synchronization primitives (when needed outside hot path)\n\n#### Frontend (keyrx_ui)\n- **React** (18+): UI framework\n- **TypeScript** (5+): Type-safe JavaScript\n- **wasm-bindgen** (0.2+): Rust ↔ JavaScript FFI\n- **serde-wasm-bindgen** (0.5+): Serde serialization across WASM boundary\n\n#### Testing & Verification\n- **proptest** (1.2+): Property-based testing framework\n- **criterion** (0.5+): Benchmarking with statistical rigor\n- **cargo-fuzz**: Fuzz testing (integrated with libFuzzer)\n\n### Application Architecture\n\n**Four-Crate Architecture (KISS Principle)**:\n\n```\n┌─────────────────────────────────────────────┐\n│  keyrx_compiler (CLI)                       │\n│  - Rhai DSL parser                          │\n│  - MPHF generation (boomphf)                │\n│  - Outputs: .krx binary (rkyv)              │\n└─────────────────┬───────────────────────────┘\n                  │ (compile time only)\n                  ▼\n┌─────────────────────────────────────────────┐\n│  keyrx_core (no_std library)                │\n│  - Pure logic, no OS dependencies           │\n│  - DFA state machine (Tap/Hold)             │\n│  - MPHF-based O(1) lookup                   │\n│  - Compilable to WASM                       │\n└─────────────────┬───────────────────────────┘\n                  │ (embedded by)\n          ┌───────┴───────┐\n          ▼               ▼\n┌──────────────────────────┐  ┌─────────────────────┐\n│ keyrx_daemon             │  │ keyrx_ui            │\n│ - OS hooks (evdev/WinLL) │  │ - React + WASM      │\n│ - .krx loader (mmap)     │  │ - Browser simulator │\n│ - Embedded web server:   │  │ - Static files only │\n│   * axum HTTP/WebSocket  │  │                     │\n│   * Serves UI (embedded) │◄─┤ (compiled output)   │\n│   * REST API             │  │                     │\n└──────────────────────────┘  └─────────────────────┘\n         │\n         │ (User accesses)\n         ▼\n   http://localhost:9876\n   (Daemon serves UI + API)\n```\n\n**Key Architectural Principles**:\n- **no_std Core**: keyrx_core has zero OS dependencies, enabling WASM compilation\n- **Compile-Time Code Generation**: Rhai scripts → static Rust structures (MPHF tables, DFA)\n- **Single Source of Truth**: Both daemon and UI consume identical .krx binary\n- **Lock-Free Hot Path**: Input processing uses lock-free ring buffers, no mutexes\n\n### Project Folder Structure\n\n```\nkeyrx/\n├── Cargo.toml              # Workspace root\n├── Makefile                # Build orchestration (all targets, tests, fuzz)\n├── .github/\n│   └── workflows/\n│       ├── ci.yml          # Clippy, rustfmt, tests, coverage\n│       └── release.yml     # Cross-platform binary builds\n│\n├── crates/\n│   ├── keyrx_core/         # Platform-agnostic remapping logic\n│   │   ├── Cargo.toml      # no_std, minimal dependencies\n│   │   ├── src/\n│   │   │   ├── lib.rs      # Public API (EventStream trait, State)\n│   │   │   ├── config.rs   # rkyv-serialized config structures\n│   │   │   ├── lookup.rs   # MPHF-based key lookup\n│   │   │   ├── dfa.rs      # Deterministic Finite Automaton (Tap/Hold)\n│   │   │   ├── state.rs    # 255-bit modifier/lock state (fixedbitset)\n│   │   │   └── simulator.rs # Deterministic Simulation Testing (DST)\n│   │   ├── benches/        # Criterion benchmarks (lookup, DFA)\n│   │   └── fuzz/           # cargo-fuzz targets\n│   │\n│   ├── keyrx_compiler/     # Rhai → .krx compiler\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs     # CLI entry point\n│   │   │   ├── parser.rs   # Rhai AST evaluation\n│   │   │   ├── mphf_gen.rs # MPHF generation (boomphf)\n│   │   │   ├── dfa_gen.rs  # DFA compilation from Tap/Hold configs\n│   │   │   └── serialize.rs # rkyv binary output\n│   │   └── tests/\n│   │       └── integration/ # End-to-end compiler tests\n│   │\n│   ├── keyrx_daemon/       # OS-specific daemon + embedded web server\n│   │   ├── Cargo.toml      # Platform-specific + web server dependencies\n│   │   ├── src/\n│   │   │   ├── main.rs     # Daemon entry point, CLI args\n│   │   │   ├── platform/\n│   │   │   │   ├── linux.rs   # evdev/uinput implementation\n│   │   │   │   └── windows.rs # Low-Level Hooks + Raw Input\n│   │   │   ├── web/        # Embedded web server (optional feature)\n│   │   │   │   ├── mod.rs     # axum server setup\n│   │   │   │   ├── api.rs     # REST API (config upload, status)\n│   │   │   │   ├── ws.rs      # WebSocket handler (real-time events)\n│   │   │   │   └── static.rs  # Serve embedded UI files\n│   │   │   ├── loader.rs   # Memory-mapped .krx loading\n│   │   │   └── logger.rs   # Structured JSON logging\n│   │   ├── ui_dist/        # Embedded UI files (from keyrx_ui build)\n│   │   │   ├── index.html\n│   │   │   ├── keyrx_core_bg.wasm\n│   │   │   └── assets/     # JS, CSS bundles\n│   │   └── tests/\n│   │       └── e2e/        # OS-specific integration tests\n│   │\n│   └── keyrx_ui/           # React + WASM frontend\n│       ├── package.json\n│       ├── vite.config.ts  # Vite bundler config\n│       ├── src/\n│       │   ├── App.tsx     # Root component\n│       │   ├── components/\n│       │   │   ├── KeyboardVisualizer.tsx  # SVG keyboard with state\n│       │   │   ├── DFADiagram.tsx          # State transition graph\n│       │   │   ├── ConfigEditor.tsx        # Rhai script editor\n│       │   │   └── DeviceSelector.tsx      # Serial number picker\n│       │   ├── wasm/\n│       │   │   └── core.ts  # TypeScript bindings for keyrx_core WASM\n│       │   └── hooks/\n│       │       ├── useSimulator.ts # WASM simulation hook\n│       │       └── useDaemon.ts    # WebSocket connection to daemon\n│       └── public/\n│           └── fonts/\n│\n├── docs/\n│   ├── reseach.md          # Original design document (this file)\n│   ├── api.md              # REST API specification\n│   └── rhai_dsl.md         # Configuration DSL guide\n│\n├── examples/\n│   ├── basic.rhai          # Simple remapping example\n│   ├── vim_mode.rhai       # Complex Tap/Hold + layers\n│   └── 255_modifiers.rhai  # Extreme configuration test\n│\n└── scripts/\n    ├── build.sh            # Build all crates (supports --error, --release, --watch)\n    ├── verify.sh           # Run all verification (clippy, rustfmt, tests, coverage)\n    ├── launch.sh           # Start daemon + UI (supports --headless, --debug)\n    ├── test.sh             # Run test suite (supports --unit, --integration, --fuzz)\n    ├── setup_linux.sh      # udev rules + permissions setup\n    ├── install_windows.ps1 # Windows registry + permissions setup\n    ├── cross_compile.sh    # Cross-compilation for all platforms\n    ├── CLAUDE.md           # AI-friendly script usage guide\n    └── logs/               # Timestamped logs (gitignored)\n        └── .gitignore      # Ignore all logs except this file\n```\n\n**Key Directory Responsibilities**:\n- **`crates/keyrx_core/`**: Pure logic, no OS dependencies, WASM-compatible\n- **`crates/keyrx_compiler/`**: Standalone CLI tool, runs at configuration time\n- **`crates/keyrx_daemon/`**: Background process with OS-specific hooks + embedded web server (axum)\n- **`crates/keyrx_ui/`**: React frontend, compiled to static assets + WASM (embedded in daemon)\n\n### Data Storage\n\n#### Primary Storage\n- **Configuration Files (.krx)**:\n  - Format: rkyv-serialized binary (deterministic, zero-copy)\n  - Location: `~/.config/keyrx/` (Linux), `%APPDATA%\\keyrx\\` (Windows)\n  - Loading: Memory-mapped via memmap2 (no deserialization overhead)\n\n- **State Storage**:\n  - In-memory only: 255-bit modifier state, 255-bit lock state (fixedbitset)\n  - No persistent state (stateless daemon restart)\n\n#### Caching\n- **No explicit caching layer**: MPHF tables and memory-mapping provide O(1) access\n- **Kernel-level buffering**: evdev/Raw Input queues managed by OS\n\n#### Data Formats\n- **Configuration**: rkyv binary (internal), Rhai source (human-editable)\n- **Logs**: JSON (structured logging)\n- **IPC**: JSON over WebSocket (control channel), shared memory ring buffer (debug events)\n- **Frontend State**: React state (ephemeral), WASM linear memory (simulation)\n\n### External Integrations\n\n#### APIs\n- **OS Input Subsystem APIs** (core integration):\n  - Linux: evdev ioctl, uinput write\n  - Windows: SetWindowsHookEx, SendInput, GetRawInputDeviceInfo\n\n#### Protocols\n- **WebSocket**: Daemon ↔ UI real-time communication\n- **HTTP/REST**: Optional daemon control API (future)\n- **IPC**: Named pipes (Windows) / Unix sockets (Linux) for CLI ↔ daemon\n\n#### Authentication\n- **Not applicable**: Local system daemon (no network authentication)\n- **OS-level permissions**: Managed via udev rules (Linux) or admin privileges (Windows)\n\n### Monitoring & Dashboard Technologies\n\n#### Dashboard Framework\n- **React 18+**: Component-based UI\n- **TypeScript**: Type safety for complex state management\n- **Vite**: Build tool with hot module replacement (HMR)\n\n#### Real-time Communication\n- **WebSocket**: Daemon → UI event streaming\n  - Event types: configuration updates, input events (debug mode), latency metrics\n- **WASM Direct Calls**: UI → keyrx_core simulation (no network latency)\n\n#### Visualization Libraries\n- **Custom Canvas Rendering**: Keyboard layout visualization with state highlighting\n- **SVG-based State Diagrams**: DFA state transitions (Pending → Held → Tapped)\n- **Chart.js** (optional): Latency histograms, usage heatmaps\n\n#### State Management\n- **React useState/useReducer**: UI state (current layer, active devices)\n- **WASM Memory as SSOT**: Simulation state lives in keyrx_core (WASM), not JavaScript\n- **.krx File as Authoritative Source**: Both daemon and UI read same binary\n\n## Development Environment\n\n### Build & Development Tools\n\n#### Build System\n- **Cargo**: Primary build tool\n  - Workspace configuration for 4 crates\n  - Feature flags: `linux`, `windows`, `wasm`, `debug_ui`\n- **npm/pnpm**: Frontend build (keyrx_ui)\n- **Makefile**: Top-level orchestration (delegates to AI-friendly scripts)\n\n#### AI-Coding-Agent-Friendly Scripts\nAll scripts follow strict conventions for machine parseability (per AI Coding Agent First principle):\n\n**Output Format**:\n- **Consistent markers**: `=== accomplished ===`, `=== failed ===`, `=== warning ===`\n- **Structured logs**: `[YYYY-MM-DD HH:MM:SS] [LEVEL] message`\n- **Exit codes**: 0 (success), 1 (error), 2 (warning)\n- **Timestamped log files**: `logs/build_$(date +%s).log` (epoch timestamp)\n\n**Flag Support** (all scripts):\n- `--error`: Output errors only (filter INFO/DEBUG for AI focus)\n- `--json`: Machine-readable JSON output\n- `--quiet`: Suppress all output except final marker\n- `--log-file <path>`: Override default log location\n\n**Example Usage** (for AI agents):\n```bash\n# Build and check for errors only\n./scripts/build.sh --error --log-file logs/build_$(date +%s).log\nif grep -q \"=== accomplished ===\" logs/build_*.log; then\n  echo \"Build verified by AI agent\"\nfi\n```\n\n**CLAUDE.md Documentation**:\n- Located at `scripts/CLAUDE.md`\n- Minimal, structured documentation for each script\n- AI agents read this first before executing commands\n- Includes examples, expected outputs, failure scenarios\n\n#### Package Management\n- **Cargo**: Rust dependencies via Cargo.toml\n- **npm/pnpm**: JavaScript dependencies via package.json\n- **System packages**: evdev headers (Linux), Windows SDK (Windows)\n\n#### Development Workflow\n- **Daemon with UI**: `cargo run --bin keyrx_daemon --features web`\n  - Serves UI on http://localhost:9876\n  - Automatically embeds compiled WASM + React frontend (from ui_dist/)\n  - Hot-reloads when .krx config changes\n- **Frontend Development**: `npm run dev` (inside keyrx_ui/) with Vite HMR\n  - Development mode: http://localhost:5173 (connects to daemon's WebSocket at :9876)\n  - Production mode: `npm run build` → outputs to daemon's ui_dist/ → embedded at compile-time\n- **Compiler**: `cargo run --bin keyrx_compiler -- config.rhai -o output.krx`\n- **Headless Daemon** (no UI): `cargo run --bin keyrx_daemon` (web feature disabled)\n- **Build All**: `make build` (compiles daemon + UI, embeds assets)\n\n### Code Quality Tools\n\n#### Pre-Commit Hooks (Mandatory)\nPer CLAUDE.md requirements:\n- **clippy**: Linting (`cargo clippy -- -D warnings`)\n- **rustfmt**: Formatting (`cargo fmt --check`)\n- **Tests**: `cargo test --all` must pass\n- **Coverage**: `cargo tarpaulin` (80% minimum, 90% for keyrx_core)\n\n#### Static Analysis\n- **clippy**: Rust linter (pedantic mode enabled)\n- **cargo-deny**: License and dependency auditing\n- **cargo-audit**: Security vulnerability scanning\n\n#### Formatting\n- **rustfmt**: Rust code formatting (enforced in CI)\n- **prettier**: JavaScript/TypeScript formatting\n\n#### Testing Framework\n- **Built-in Rust test harness**: Unit tests\n- **proptest**: Property-based testing (1M+ generated test cases)\n- **cargo-fuzz**: Fuzzing with coverage-guided mutation\n- **criterion**: Performance benchmarks with regression detection\n- **Deterministic Simulation Testing (DST)**: Custom framework with virtual clock\n\n#### Documentation\n- **rustdoc**: API documentation (`cargo doc`)\n- **mdBook**: User guide and architecture documentation (future)\n\n### Version Control & Collaboration\n\n#### VCS\n- **Git**: Primary version control\n- **GitHub**: Hosting, CI/CD, issue tracking\n\n#### Branching Strategy\n- **Trunk-Based Development** (per CLAUDE.md: no backward compatibility required)\n- **Feature branches**: Short-lived (<3 days), merged to main after CI passes\n- **No release branches**: Rolling releases with semantic versioning\n\n#### Code Review Process\n- **Pull requests**: Required for all changes\n- **Automated checks**: clippy, rustfmt, tests, coverage, benchmarks\n- **Review focus**: Architecture, performance implications, test coverage\n\n### Dashboard Development\n\n#### Live Reload\n- **Vite HMR**: Instant frontend updates during development (http://localhost:5173)\n- **WASM watch mode**: Auto-rebuild on keyrx_core changes (integrated with Vite)\n- **Production**: UI assets embedded in daemon binary via `include_dir!` macro\n\n#### Port Management\n- **Daemon Web Server**: Default 9876 (serves UI + WebSocket + REST API)\n- **Vite Dev Server**: Default 5173 (development only, proxies to daemon)\n- **Configuration**: Ports configurable via `~/.config/keyrx/daemon.toml`\n\n#### Multi-Instance Support\n- **Single daemon per user session**: OS input hooks are exclusive (evdev GRAB, Windows LL Hook)\n- **Multiple UI connections**: Supported (read-only observers via WebSocket)\n\n## Deployment & Distribution\n\n### Target Platform(s)\n- **Linux**: x86_64, kernel 5.10+ (evdev requirement)\n  - Tested: Ubuntu 22.04+, Fedora 38+, Arch Linux\n- **Windows**: x86_64, Windows 10 1903+ (Low-Level Hooks stability)\n- **WASM**: Any modern browser (Chrome 90+, Firefox 88+, Safari 15+)\n\n### Distribution Method\n- **Binary releases**: GitHub Releases with pre-built binaries\n- **Package managers** (future):\n  - Linux: AUR (Arch), PPA (Ubuntu), Flatpak\n  - Windows: winget, Chocolatey\n- **Source builds**: `cargo install keyrx` (crates.io publication)\n\n### Installation Requirements\n\n**Linux**:\n- `udev` rules setup (auto-generated by installer)\n- Input group membership (non-root access to `/dev/input/event*`)\n\n**Windows**:\n- Administrator privileges for initial setup (Low-Level Hook registration)\n- User-mode execution after setup\n\n### Update Mechanism\n- **Manual**: Download new binary, restart daemon\n- **Auto-update** (future): Background downloader with signature verification\n\n## Technical Requirements & Constraints\n\n### Performance Requirements\n\n#### Hard Requirements\n- **Latency**: <1ms end-to-end (OS hook → processing → injection)\n  - Target: <100μs for 95th percentile\n- **Lookup**: O(1) constant-time key lookup (MPHF guarantee)\n- **Memory**: <50MB resident set size (daemon + loaded config)\n- **CPU**: <1% on idle, <5% under sustained input (1000 keys/sec)\n\n#### Benchmarks\n- **MPHF lookup**: <50ns (verified via criterion)\n- **DFA state transition**: <50ns\n- **rkyv deserialization**: <1μs (zero-copy validation)\n- **Event pipeline**: <100μs total (measured via tracing)\n\n### Compatibility Requirements\n\n#### Platform Support\n- **OS**: Linux 5.10+, Windows 10 1903+\n- **Architecture**: x86_64 (ARM64 future consideration)\n- **Desktop Environments**: X11, Wayland, Windows Desktop\n\n#### Dependency Versions\n- **Rust**: 1.70+ (MSRV - Minimum Supported Rust Version)\n- **glibc**: 2.31+ (Linux)\n- **WASM**: wasm32-unknown-unknown target (stable Rust)\n\n#### Standards Compliance\n- **Linux Input Subsystem**: evdev protocol compliance\n- **USB HID**: Standard HID usage tables (USB.org specification)\n- **Windows Input**: Windows Input Architecture compliance\n\n### Security & Compliance\n\n#### Security Requirements\n- **No secret logging**: PII/credentials excluded from logs (per CLAUDE.md)\n- **Memory safety**: Rust guarantees + `forbid(unsafe_code)` in keyrx_core\n- **Input validation**: All external input (Rhai scripts, IPC) validated before execution\n\n#### Threat Model\n- **Untrusted configurations**: Malicious .rhai scripts cannot execute arbitrary code (sandboxed Rhai engine)\n- **Privilege escalation**: Daemon runs with minimal required privileges (input group, not root)\n- **Log injection**: Structured JSON logging prevents injection attacks\n\n#### Compliance Standards\n- **Not applicable**: No PII collection, no network transmission (local-only system)\n\n### Scalability & Reliability\n\n#### Expected Load\n- **Input rate**: Up to 1000 events/sec (competitive gaming scenario)\n- **Configuration size**: Up to 10,000 remapping rules (MPHF handles efficiently)\n- **Concurrent users**: Single user per daemon instance\n\n#### Availability Requirements\n- **Uptime**: 99.9% (daemon restarts in <100ms)\n- **Graceful degradation**: If daemon crashes, input passes through unmodified (no stuck keys)\n- **State recovery**: Stateless design enables instant recovery after crash\n\n#### Growth Projections\n- **Not applicable**: Single-user system tool (no multi-tenancy)\n\n## Technical Decisions & Rationale\n\n### Decision Log\n\n#### 1. Rust Language Choice\n**Decision**: Use Rust for all performance-critical code (core, daemon, compiler)\n\n**Rationale**:\n- Memory safety without GC (sub-1ms latency requirement)\n- Zero-cost abstractions (high-level code → low-level performance)\n- WASM compilation support (browser simulation)\n- Strong type system (AI agent verification via compile-time checks)\n\n**Alternatives Considered**:\n- C++: Rejected due to undefined behavior risks, harder AI verification\n- Go: Rejected due to GC pauses (incompatible with <1ms latency)\n\n#### 2. Rhai for Configuration DSL\n**Decision**: Use Rhai scripting language, evaluated at compile-time only\n\n**Rationale**:\n- Rust-native (easy FFI, no C dependencies)\n- Sandboxed execution (no filesystem/network access)\n- Familiar syntax (JavaScript-like, low learning curve)\n- Compile-time evaluation eliminates runtime overhead\n\n**Alternatives Considered**:\n- Lua: Rejected (C dependency, harder WASM integration)\n- YAML/TOML: Rejected (insufficient expressiveness for 255 modifiers)\n- JavaScript (Deno): Rejected (heavy runtime, latency concerns)\n\n#### 3. rkyv Zero-Copy Serialization\n**Decision**: Use rkyv for .krx binary format\n\n**Rationale**:\n- Zero-copy deserialization (no parsing overhead)\n- Deterministic output (hash-based verification for AI agents)\n- Validation without full deserialization (bytecheck crate)\n- Memory-map friendly (direct access to mmap'd files)\n\n**Alternatives Considered**:\n- bincode: Rejected (requires deserialization, not zero-copy)\n- Protocol Buffers: Rejected (schema compilation complexity, not zero-copy)\n- MessagePack: Rejected (parsing overhead)\n\n#### 4. MPHF (Minimal Perfect Hash Function) for Lookup\n**Decision**: Use boomphf CHD algorithm for O(1) key lookup\n\n**Rationale**:\n- Guaranteed O(1) lookup (no hash collisions)\n- Compact representation (sparse keyspace → dense array)\n- Build time negligible (compile phase only)\n- Cache-friendly (sequential array access)\n\n**Alternatives Considered**:\n- std::HashMap: Rejected (non-deterministic, worst-case O(n), resize overhead)\n- Direct array indexing: Rejected (sparse keyspace wastes memory)\n- B-tree: Rejected (O(log n) lookup, not constant-time)\n\n#### 5. no_std Core Design\n**Decision**: keyrx_core is `#![no_std]` (no standard library)\n\n**Rationale**:\n- WASM compilation without std (smaller binary, faster)\n- Eliminates accidental heap allocation in hot path\n- Forces explicit dependency management (better for AI code analysis)\n- Proves core logic is OS-agnostic\n\n**Alternatives Considered**:\n- Full std support: Rejected (couples core to OS, harder to verify)\n\n#### 6. React + WASM Frontend (Not Electron/Tauri Initially)\n**Decision**: Web-based UI with WASM, packaged as local HTML later\n\n**Rationale**:\n- WASM simulation shares exact core code with daemon (no drift)\n- Faster iteration (web dev tools, HMR)\n- Cross-platform by default (same UI on Linux/Windows)\n- Lighter weight than Electron (future Tauri packaging possible)\n\n**Alternatives Considered**:\n- Native GUI (GTK/Qt): Rejected (platform-specific, no WASM simulation)\n- Electron: Rejected (bloat, slower startup)\n- TUI (terminal UI): Rejected (insufficient visualization for DFA/state)\n\n## Known Limitations\n\n### 1. Windows Hook Timeout Risk\n**Impact**: If keyrx_daemon processing exceeds ~300ms, Windows may silently unhook\n\n**Mitigation**: Lock-free event queue + immediate CallNextHookEx return\n\n**Future Solution**: Kernel driver (requires signing, deployment complexity)\n\n### 2. macOS Not Supported\n**Impact**: macOS users cannot use keyrx\n\n**Why**: Requires CGEventTap API research and implementation\n\n**Timeline**: Post-1.0 (after Linux/Windows stabilization)\n\n### 3. WASM Simulation Cannot Test OS-Specific Quirks\n**Impact**: evdev/Windows hook edge cases not testable in browser\n\n**Mitigation**: E2E tests on real OS (GitHub Actions matrix)\n\n**Future Solution**: Record/replay of OS events for deterministic testing\n\n### 4. 255 Modifiers/Locks May Exceed OS Virtual Key Limits\n**Impact**: Some OS key codes may conflict with custom modifier IDs\n\n**Mitigation**: Namespace separation (custom IDs start at 0x8000, above standard range)\n\n**Future Solution**: Virtual key remapping table (if needed)\n\n### 5. No Multi-User Support\n**Impact**: One keyrx_daemon per system (not per user session)\n\n**Why**: Global input hooks are system-wide (Windows) or require device grab (Linux)\n\n**Future Solution**: User-session isolation via systemd user services (Linux) or per-session hooks (Windows, complex)\n",
  "fileStats": {
    "size": 26590,
    "lines": 619,
    "lastModified": "2025-12-21T04:16:50.534Z"
  },
  "comments": []
}