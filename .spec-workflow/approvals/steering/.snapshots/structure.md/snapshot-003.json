{
  "id": "snapshot_1764442667735_adn5a4nam",
  "approvalId": "approval_1764442551053_msb6xdogs",
  "approvalTitle": "KeyRx Project Structure (Revised)",
  "version": 3,
  "timestamp": "2025-11-29T18:57:47.735Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Project Structure\n\n## Directory Organization\n\n```\nkeyrx/\n├── core/                       # Rust backend (primary logic)\n│   ├── src/\n│   │   ├── lib.rs             # Library root, public API\n│   │   ├── engine/            # Event loop and processing\n│   │   │   ├── mod.rs\n│   │   │   ├── event_loop.rs  # Tokio async event loop\n│   │   │   └── state.rs       # Layer state machine\n│   │   ├── scripting/         # Rhai integration\n│   │   │   ├── mod.rs\n│   │   │   ├── runtime.rs     # Rhai engine setup\n│   │   │   └── bindings.rs    # Rust-Rhai type bindings\n│   │   ├── drivers/           # OS adapter traits\n│   │   │   ├── mod.rs\n│   │   │   ├── traits.rs      # InputSource trait definition\n│   │   │   ├── windows.rs     # WH_KEYBOARD_LL implementation\n│   │   │   └── linux.rs       # uinput/evdev implementation\n│   │   └── ffi/               # C-ABI exports for Flutter\n│   │       ├── mod.rs\n│   │       └── exports.rs     # extern \"C\" functions\n│   ├── tests/                 # Integration tests\n│   ├── benches/               # Criterion benchmarks\n│   └── Cargo.toml\n│\n├── ui/                         # Flutter frontend\n│   ├── lib/\n│   │   ├── main.dart          # Application entry point\n│   │   ├── ffi/               # Dart FFI bindings\n│   │   │   ├── bindings.dart  # Generated FFI bindings\n│   │   │   └── bridge.dart    # High-level Rust bridge\n│   │   ├── pages/             # UI screens\n│   │   │   ├── editor.dart    # Visual keymap editor\n│   │   │   ├── debugger.dart  # Real-time state visualizer\n│   │   │   └── console.dart   # Rhai REPL terminal\n│   │   ├── widgets/           # Reusable UI components\n│   │   │   ├── keyboard.dart  # Visual keyboard widget\n│   │   │   └── layer_panel.dart\n│   │   └── state/             # Application state management\n│   ├── test/                  # Widget tests\n│   └── pubspec.yaml\n│\n├── scripts/                    # User Rhai configurations\n│   └── std/                   # Standard library\n│       ├── layouts/           # Keyboard layout definitions\n│       │   ├── 109.rhai       # JIS 109-key layout\n│       │   └── ansi.rhai      # ANSI layout\n│       ├── layers.rhai        # Layer management utilities\n│       └── modifiers.rhai     # Custom modifier helpers\n│\n├── docs/                       # Documentation\n│   ├── ARCHITECTURE.md        # Technical architecture\n│   └── STEERING.md            # Project steering document\n│\n├── .spec-workflow/            # Spec workflow artifacts\n│   ├── steering/              # Steering documents\n│   └── specs/                 # Feature specifications\n│\n└── README.md                  # Project overview\n```\n\n## Naming Conventions\n\n### Files\n- **Rust modules**: `snake_case.rs` (e.g., `event_loop.rs`, `state_machine.rs`)\n- **Dart files**: `snake_case.dart` (e.g., `keymap_editor.dart`)\n- **Rhai scripts**: `snake_case.rhai` (e.g., `user_config.rhai`)\n- **Tests**: `[module]_test.rs` (Rust), `[file]_test.dart` (Dart)\n\n### Code\n\n#### Rust\n- **Structs/Enums**: `PascalCase` (e.g., `Engine`, `LayerState`)\n- **Functions/Methods**: `snake_case` (e.g., `process_event`, `activate_layer`)\n- **Constants**: `UPPER_SNAKE_CASE` (e.g., `MAX_MODIFIERS`, `DEFAULT_LATENCY`)\n- **Traits (Interfaces)**: `PascalCase` descriptive names (e.g., `InputSource`, `ScriptRuntime`, `StateStore`)\n- **Mock Implementations**: `Mock` + trait name (e.g., `MockInputSource`, `MockScriptRuntime`)\n\n#### Dart\n- **Classes**: `PascalCase` (e.g., `KeyboardWidget`, `RustBridge`)\n- **Functions/Methods**: `camelCase` (e.g., `processKey`, `updateState`)\n- **Constants**: `lowerCamelCase` or `UPPER_SNAKE_CASE` for compile-time\n- **Files**: `snake_case.dart`\n\n#### Rhai\n- **Functions**: `snake_case` (e.g., `on_key_press`, `activate_layer`)\n- **Variables**: `snake_case` (e.g., `current_layer`, `mod_flags`)\n\n## Import Patterns\n\n### Rust Import Order\n1. Standard library (`std::`)\n2. External crates (`tokio::`, `rhai::`)\n3. Crate modules (`crate::engine::`)\n4. Super/self imports\n\n### Dart Import Order\n1. Dart SDK (`dart:ffi`, `dart:async`)\n2. Flutter framework (`package:flutter/`)\n3. External packages\n4. Project imports (`package:keyrx/`)\n5. Relative imports\n\n### Module Organization\n- Use re-exports in `mod.rs` / `lib.rs` to create clean public APIs\n- Keep implementation details private\n- Platform-specific code behind `#[cfg(target_os = \"...\")]`\n\n## Code Structure Patterns\n\n### Rust Module Organization\n```rust\n// 1. Imports\nuse std::collections::HashMap;\nuse tokio::sync::mpsc;\n\n// 2. Constants\nconst MAX_LAYERS: usize = 32;\n\n// 3. Type definitions\npub struct Engine { ... }\npub enum Event { ... }\n\n// 4. Trait implementations\nimpl Engine { ... }\n\n// 5. Private helpers\nfn validate_input(...) { ... }\n\n// 6. Tests (in same file or tests/)\n#[cfg(test)]\nmod tests { ... }\n```\n\n### Dart File Organization\n```dart\n// 1. Imports\nimport 'dart:ffi';\nimport 'package:flutter/material.dart';\n\n// 2. Constants\nconst kMaxLayers = 32;\n\n// 3. Class definitions\nclass KeyboardEditor extends StatefulWidget { ... }\n\n// 4. State classes\nclass _KeyboardEditorState extends State<KeyboardEditor> { ... }\n\n// 5. Helper widgets/functions\nWidget _buildKeyButton(...) { ... }\n```\n\n## Code Organization Principles\n\n1. **Single Responsibility**: Each module handles one concern (e.g., `engine/` for event processing, `scripting/` for Rhai)\n2. **Modularity**: OS drivers are interchangeable via `InputSource` trait\n3. **Testability**: All external dependencies injected; MockInputSource for testing\n4. **Consistency**: Follow established patterns in each language\n5. **CLI First**: Every feature CLI-exercisable before GUI implementation\n\n## Dependency Injection Pattern\n\nAll external dependencies are abstracted behind traits and injected:\n\n```\ncore/src/\n├── traits/                    # DI interface definitions\n│   ├── mod.rs\n│   ├── input_source.rs       # pub trait InputSource\n│   ├── script_runtime.rs     # pub trait ScriptRuntime\n│   └── state_store.rs        # pub trait StateStore\n├── impl/                      # Production implementations\n│   ├── mod.rs\n│   ├── windows_input.rs      # impl InputSource for WindowsInput\n│   ├── linux_input.rs        # impl InputSource for LinuxInput\n│   ├── rhai_runtime.rs       # impl ScriptRuntime for RhaiRuntime\n│   └── memory_state.rs       # impl StateStore for InMemoryState\n└── mocks/                     # Test mocks\n    ├── mod.rs\n    ├── mock_input.rs         # impl InputSource for MockInput\n    ├── mock_runtime.rs       # impl ScriptRuntime for MockRuntime\n    └── mock_state.rs         # impl StateStore for MockState\n```\n\n**Trait Naming**: Use descriptive `PascalCase` names that describe the capability (e.g., `InputSource`, `ScriptRuntime`), not `ISomething` prefix.\n\n**Mock Naming**: Prefix with `Mock` (e.g., `MockInputSource`).\n\n## CLI Structure\n\n```\ncore/src/\n├── bin/\n│   └── keyrx.rs              # CLI entry point\n├── cli/\n│   ├── mod.rs\n│   ├── commands/\n│   │   ├── check.rs          # keyrx check - validate scripts\n│   │   ├── run.rs            # keyrx run - start engine\n│   │   ├── simulate.rs       # keyrx simulate - event simulation\n│   │   ├── state.rs          # keyrx state - inspect state\n│   │   ├── doctor.rs         # keyrx doctor - self-diagnostics\n│   │   ├── bench.rs          # keyrx bench - latency benchmark\n│   │   └── repl.rs           # keyrx repl - interactive mode\n│   └── output.rs             # JSON/human-readable output formatting\n```\n\nEvery CLI command supports:\n- `--json` flag for machine-readable output (AI agent friendly)\n- `--verbose` flag for detailed debugging\n- Exit codes for scripting (0=success, 1=error, 2=validation failure)\n\n## Module Boundaries\n\n### Core vs UI\n- Core exposes C-ABI functions only via `ffi/` module\n- UI never imports Rust types directly; uses FFI bridge\n- State synchronization via event passing, not shared memory\n\n### Core vs Drivers\n- Core defines `InputSource` trait\n- Drivers implement trait without Core knowing OS specifics\n- Drivers are compile-time selected via Cargo features\n\n### Public API vs Internal\n- `lib.rs` exports only public types\n- Internal modules use `pub(crate)` visibility\n- FFI functions are the only `extern \"C\"` exports\n\n### Platform-specific Isolation\n```rust\n#[cfg(target_os = \"windows\")]\nmod windows_driver;\n\n#[cfg(target_os = \"linux\")]\nmod linux_driver;\n```\n\n## Code Size Guidelines\n\nPer CLAUDE.md requirements:\n- **File size**: Maximum 500 lines (excluding comments/blank lines)\n- **Function size**: Maximum 50 lines\n- **Test coverage**: 80% minimum, 90% for critical paths (engine, scripting)\n- **Nesting depth**: Maximum 4 levels\n\n## Documentation Standards\n\n### Rust\n- All public items have `///` doc comments\n- Module-level `//!` documentation in `mod.rs`\n- Examples in doc comments where helpful\n\n### Dart\n- `///` doc comments for public APIs\n- Widget documentation includes usage examples\n- README in `lib/` directories for complex modules\n\n### Rhai Standard Library\n- Header comment explaining purpose\n- Inline comments for non-obvious logic\n- Usage examples in script files\n",
  "fileStats": {
    "size": 9763,
    "lines": 268,
    "lastModified": "2025-11-29T18:55:43.305Z"
  },
  "comments": []
}