{
  "id": "snapshot_1764481118936_09rllwxa7",
  "approvalId": "approval_1764481118930_xha42tqhn",
  "approvalTitle": "Device Discovery Requirements",
  "version": 1,
  "timestamp": "2025-11-30T05:38:38.936Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document: device-discovery\n\n## Introduction\n\nDevice Discovery is the foundation of KeyRx's \"True Blank Canvas\" philosophy. Rather than assuming keyboard layouts based on OS conventions (QWERTY, AZERTY, ISO, ANSI), this feature allows users to discover their physical keyboard layout by pressing keys in order, creating a per-device profile that maps scan codes to physical positions (row, column).\n\n**Core differentiator**: While other remappers inherit OS assumptions about keys, KeyRx treats every keyboard as a fresh grid of buttons. This enables truly layout-agnostic configurations that can be shared across any keyboard type.\n\n## Alignment with Product Vision\n\nFrom `product.md`:\n> \"The keyboard is treated as a pure grid of buttons with physical positions, not OS-defined key names. Through device discovery, each physical key is mapped by its position (row, column), eliminating assumptions about what a key 'should' be.\"\n\nFrom `tech.md`:\n> \"scan_code is generated by keyboard firmware, same across OS. Represents physical button position on keyboard matrix. This is our path to true blank canvas.\"\n\nThis spec implements the Device Discovery Flow defined in the steering documents:\n1. Detect keyboard by (vendor_id, product_id)\n2. Prompt user to discover physical layout\n3. User presses keys in order: top-left → right, then next row\n4. Each key registered by physical position: KEY_0_0, KEY_0_1, etc.\n5. Profile saved per-device for future sessions\n\n## Requirements\n\n### REQ-1: Device Detection\n\n**User Story:** As a user, I want KeyRx to automatically detect connected keyboards by their hardware identifiers, so that each device can have its own profile.\n\n#### Acceptance Criteria\n\n1. WHEN a keyboard is connected THEN the system SHALL detect its vendor_id and product_id\n2. WHEN the system starts THEN it SHALL enumerate all connected input devices\n3. WHEN a device is detected THEN the system SHALL check if a profile exists for (vendor_id, product_id)\n4. IF no profile exists THEN the system SHALL prompt the user to run discovery or use default fallback\n5. WHEN multiple keyboards are connected THEN the system SHALL track each independently by device_id\n\n### REQ-2: Discovery Wizard CLI\n\n**User Story:** As a power user, I want a CLI-based discovery wizard that guides me through mapping my keyboard layout, so that I can set up KeyRx headlessly.\n\n#### Acceptance Criteria\n\n1. WHEN `keyrx discover` is run THEN the system SHALL list detected keyboards and prompt selection\n2. WHEN `keyrx discover --device <vendor:product>` is run THEN the system SHALL start discovery for that device\n3. WHEN discovery starts THEN the system SHALL instruct: \"Press keys from top-left to right, then next row\"\n4. WHEN a key is pressed during discovery THEN the system SHALL:\n   - Record the scan_code\n   - Assign position (current_row, current_col)\n   - Display: \"KEY_0_0 (scan: 0x1) registered\"\n   - Advance to next column\n5. WHEN Enter/Return is pressed THEN the system SHALL advance to the next row\n6. WHEN `keyrx discover --save` is complete THEN the system SHALL save the profile to devices/ directory\n7. IF the user presses Escape THEN the system SHALL abort discovery without saving\n8. WHEN discovery completes THEN the system SHALL display a summary of all registered keys\n\n### REQ-3: Profile Storage\n\n**User Story:** As a user, I want my keyboard profiles persisted, so that I don't have to re-discover on every startup.\n\n#### Acceptance Criteria\n\n1. WHEN a profile is saved THEN it SHALL be stored at `~/.config/keyrx/devices/<vendor>_<product>.json`\n2. WHEN saving THEN the profile SHALL include:\n   - vendor_id, product_id, name\n   - rows count, cols_per_row array\n   - keymap (scan_code → position + alias)\n   - discovered_at timestamp\n3. WHEN KeyRx starts THEN it SHALL load all profiles from the devices/ directory\n4. IF a profile is corrupted THEN the system SHALL log a warning and use default fallback\n5. WHEN a user runs `keyrx devices list` THEN the system SHALL display all saved profiles\n\n### REQ-4: scan_code as Primary Identifier\n\n**User Story:** As a developer, I want scan_code to be the canonical key identifier in profiles, so that mappings work consistently across operating systems.\n\n#### Acceptance Criteria\n\n1. WHEN processing key events THEN the system SHALL extract scan_code from the event\n2. WHEN storing key mappings THEN the key identifier SHALL be scan_code (not OS keycode)\n3. WHEN looking up physical key info THEN the query SHALL be by scan_code\n4. IF scan_code is unavailable (synthetic events) THEN the system SHALL fall back to OS keycode with warning\n5. WHEN exporting profiles THEN scan_codes SHALL be stored as hex strings (e.g., \"0x1E\")\n\n### REQ-5: Position-Based Naming\n\n**User Story:** As a user, I want keys named by physical position (KEY_0_0, KEY_2_5), so that my configs are layout-agnostic.\n\n#### Acceptance Criteria\n\n1. WHEN a key is discovered THEN it SHALL be assigned name format `KEY_{row}_{col}`\n2. WHEN rendering key names THEN the system SHALL use the position-based name by default\n3. WHEN a Rhai script references KEY_r_c THEN the system SHALL resolve it to the correct scan_code\n4. WHEN displaying unknown keys THEN the system SHALL fall back to `SCAN_{hex}` format\n5. WHEN comparing positions THEN row 0 SHALL be top row, col 0 SHALL be leftmost key\n\n### REQ-6: User Alias System\n\n**User Story:** As a user, I want to define custom aliases for keys (e.g., \"LeftPinky\", \"ThumbCluster\"), so that my scripts are readable.\n\n#### Acceptance Criteria\n\n1. WHEN `alias(position, name)` is called in Rhai THEN the system SHALL register the alias\n2. WHEN a script references an alias THEN the system SHALL resolve it to the physical position\n3. WHEN multiple aliases exist for a key THEN all SHALL be valid references\n4. WHEN `keyrx aliases list` is run THEN the system SHALL display all defined aliases\n5. WHEN aliases conflict with built-in names THEN the user alias SHALL take precedence\n6. WHEN saving config THEN aliases SHALL be persisted in the device profile or script\n\n### REQ-7: Multiple Keyboard Support\n\n**User Story:** As a user with multiple keyboards, I want each to have its own profile and behave independently, so that my gaming keyboard and typing keyboard work differently.\n\n#### Acceptance Criteria\n\n1. WHEN multiple keyboards are connected THEN each SHALL be identified by unique device_id\n2. WHEN an event arrives THEN the system SHALL include device_id in the InputEvent\n3. WHEN looking up profiles THEN the system SHALL use (vendor_id, product_id) from device_id\n4. WHEN routing events to scripts THEN the script SHALL have access to source device info\n5. WHEN a profile is missing THEN only that specific device SHALL use the fallback\n\n### REQ-8: Default Fallback Profile\n\n**User Story:** As a new user, I want KeyRx to work immediately without discovery, so that I can try it before committing to setup.\n\n#### Acceptance Criteria\n\n1. WHEN no profile exists for a device THEN the system SHALL use default.json fallback\n2. WHEN using fallback THEN keys SHALL be identified by OS key name (CapsLock, A, etc.)\n3. WHEN running in fallback mode THEN the system SHALL display a notice recommending discovery\n4. WHEN `keyrx discover --generate-default` is run THEN a fallback profile SHALL be created from OS mappings\n5. IF default.json doesn't exist THEN the system SHALL create it with standard layout on first run\n\n### REQ-9: Discovery Re-run and Edit\n\n**User Story:** As a user, I want to re-run discovery or edit specific keys, so that I can fix mistakes without starting over.\n\n#### Acceptance Criteria\n\n1. WHEN `keyrx discover --overwrite` is run THEN existing profile SHALL be replaced\n2. WHEN `keyrx discover --edit KEY_2_3` is run THEN the system SHALL prompt for new key press at that position\n3. WHEN editing THEN only the specified key(s) SHALL be modified\n4. WHEN `keyrx discover --from-file layout.json` is run THEN the system SHALL import the profile\n5. WHEN a profile is edited THEN the system SHALL update discovered_at timestamp\n\n### REQ-10: Device Naming\n\n**User Story:** As a user with multiple keyboards of the same model, I want to give them unique names, so that I can distinguish them in configs.\n\n#### Acceptance Criteria\n\n1. WHEN a device is first discovered THEN the system SHALL prompt for a friendly name\n2. WHEN `keyrx devices rename <vendor:product> \"New Name\"` is run THEN the name SHALL be updated\n3. WHEN displaying devices THEN the system SHALL show friendly name alongside vendor:product\n4. IF multiple devices share vendor:product THEN the system SHALL distinguish by device_id suffix\n5. WHEN referencing device in scripts THEN both friendly name and vendor:product SHALL be valid\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility**: Device detection, profile storage, and discovery wizard are separate modules\n- **Modular Design**: Profile format is versioned and extensible\n- **Dependency Management**: No platform-specific code in profile logic\n- **Clear Interfaces**: DeviceRegistry trait enables mock testing\n\n### Performance\n\n- Profile loading: < 50ms for 10 device profiles\n- Device enumeration: < 100ms on startup\n- Key event to device lookup: O(1) hash table access\n- Profile saving: Non-blocking async I/O\n\n### Security\n\n- Profile files stored in user-writable config directory only\n- No network access required for discovery\n- Profile JSON validated on load (malformed = rejected)\n- No code execution from profile files (data only)\n\n### Reliability\n\n- Corrupted profile files logged and skipped (not crash)\n- Missing devices gracefully handled (use fallback)\n- Discovery can be interrupted safely (no partial state)\n- Atomic profile writes (write temp, then rename)\n\n### Usability\n\n- Discovery wizard provides clear, step-by-step instructions\n- Progress shown during discovery (X of Y keys registered)\n- Mistakes can be undone (--edit, --overwrite)\n- Works headlessly (no GUI required)\n",
  "fileStats": {
    "size": 9977,
    "lines": 194,
    "lastModified": "2025-11-30T05:38:34.197Z"
  },
  "comments": []
}