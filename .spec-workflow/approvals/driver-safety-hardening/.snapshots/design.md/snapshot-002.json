{
  "id": "snapshot_1764768206192_oj6mj8jbp",
  "approvalId": "approval_1764767194644_r87mzzkau",
  "approvalTitle": "Driver Safety Hardening - Design",
  "version": 2,
  "timestamp": "2025-12-03T13:23:26.192Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design isolates all unsafe code into minimal safety wrapper modules with comprehensive SAFETY documentation. Each unsafe operation gets a dedicated wrapper type that encapsulates the invariants. The core innovation is the `SafeHook` type that manages Windows hook lifecycle and the `SafeDevice` type for Linux evdev operations.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Minimize unsafe blocks**: Each unsafe block has one purpose\n- **SAFETY comments**: Every unsafe block documents invariants\n- **Error Handling**: Structured errors for all platform operations\n\n### Project Structure (structure.md)\n- Windows safety: `core/src/drivers/windows/safety/`\n- Linux safety: `core/src/drivers/linux/safety/`\n- Shared patterns: `core/src/drivers/common/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **windows-rs**: Already provides some safe wrappers\n- **evdev crate**: Has safe APIs to use where possible\n- **anyhow::Result**: For error propagation\n\n### Integration Points\n- **WindowsInputSource**: Uses SafeHook internally\n- **LinuxInputSource**: Uses SafeDevice internally\n- **Engine**: Receives errors from drivers\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Driver Layer\"\n        WIS[WindowsInputSource] --> SH[SafeHook]\n        LIS[LinuxInputSource] --> SD[SafeDevice]\n    end\n\n    subgraph \"Windows Safety\"\n        SH --> HW[HookWrapper]\n        SH --> TL[ThreadLocalState]\n        HW --> API[Windows API]\n    end\n\n    subgraph \"Linux Safety\"\n        SD --> EV[EvdevWrapper]\n        SD --> UI[UinputWrapper]\n        EV --> DEV[/dev/input/*]\n        UI --> UDEV[/dev/uinput]\n    end\n\n    subgraph \"Common\"\n        WIS --> ER[DriverError]\n        LIS --> ER\n        ER --> REC[Recovery]\n    end\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each safety wrapper in its own file\n- **Component Isolation**: Wrappers don't know about each other\n- **Minimal Unsafe**: Only necessary operations are unsafe\n- **SAFETY Documentation**: Every unsafe block is documented\n\n## Components and Interfaces\n\n### Component 1: SafeHook (Windows)\n\n- **Purpose:** Safe wrapper for Windows keyboard hooks\n- **Interfaces:**\n  ```rust\n  /// Safe wrapper for Windows low-level keyboard hook.\n  ///\n  /// # Safety Invariants\n  /// - Hook handle is valid while SafeHook exists\n  /// - Callback never panics (caught internally)\n  /// - Hook is unset on Drop\n  pub struct SafeHook {\n      handle: HHOOK,\n      callback_id: usize,\n  }\n\n  impl SafeHook {\n      /// Install a keyboard hook.\n      ///\n      /// # Errors\n      /// Returns error if SetWindowsHookEx fails.\n      pub fn install(callback: HookCallback) -> Result<Self, DriverError>;\n\n      /// Check if hook is still valid.\n      pub fn is_valid(&self) -> bool;\n  }\n\n  impl Drop for SafeHook {\n      fn drop(&mut self) {\n          // SAFETY: handle is valid, UnhookWindowsHookEx is thread-safe\n          unsafe { UnhookWindowsHookEx(self.handle) };\n      }\n  }\n  ```\n- **Dependencies:** windows-rs\n- **Reuses:** Windows API patterns\n\n### Component 2: ThreadLocalState (Windows)\n\n- **Purpose:** Safe thread-local storage for hook context\n- **Interfaces:**\n  ```rust\n  /// Thread-local state for routing hook events.\n  ///\n  /// # Safety Invariants\n  /// - State is only accessed from hook callback thread\n  /// - Initialization is atomic\n  /// - Access never panics\n  pub struct ThreadLocalState {\n      sender: Option<Sender<KeyEvent>>,\n  }\n\n  impl ThreadLocalState {\n      /// Get the thread-local state, initializing if needed.\n      pub fn get() -> &'static Self;\n\n      /// Set the event sender.\n      pub fn set_sender(&self, sender: Sender<KeyEvent>);\n\n      /// Send an event through the channel.\n      pub fn send(&self, event: KeyEvent) -> Result<(), DriverError>;\n  }\n  ```\n- **Dependencies:** std::cell, crossbeam\n- **Reuses:** Thread-local patterns\n\n### Component 3: HookCallback (Windows)\n\n- **Purpose:** Panic-safe hook callback wrapper\n- **Interfaces:**\n  ```rust\n  /// Panic-catching wrapper for hook callback.\n  ///\n  /// # Safety\n  /// - Catches all panics to prevent UB\n  /// - Logs panic info for debugging\n  /// - Returns valid LRESULT even on panic\n  pub struct HookCallback {\n      inner: Box<dyn Fn(KeyEvent) -> HookAction + Send>,\n  }\n\n  impl HookCallback {\n      pub fn new<F>(f: F) -> Self\n      where\n          F: Fn(KeyEvent) -> HookAction + Send + 'static;\n\n      /// Invoke callback with panic catching.\n      pub fn invoke(&self, event: KeyEvent) -> HookAction {\n          std::panic::catch_unwind(|| (self.inner)(event))\n              .unwrap_or_else(|panic| {\n                  log::error!(\"Hook callback panicked: {:?}\", panic);\n                  HookAction::PassThrough\n              })\n      }\n  }\n  ```\n- **Dependencies:** std::panic\n- **Reuses:** Panic catching pattern\n\n### Component 4: SafeDevice (Linux)\n\n- **Purpose:** Safe wrapper for evdev device operations\n- **Interfaces:**\n  ```rust\n  /// Safe wrapper for Linux evdev device.\n  ///\n  /// # Safety Invariants\n  /// - Device file descriptor is valid while SafeDevice exists\n  /// - Exclusive grab is held\n  /// - Device is released on Drop\n  pub struct SafeDevice {\n      device: evdev::Device,\n      path: PathBuf,\n      grabbed: bool,\n  }\n\n  impl SafeDevice {\n      /// Open and grab a device.\n      ///\n      /// # Errors\n      /// - DeviceNotFound if path doesn't exist\n      /// - PermissionDenied if no read access\n      /// - GrabFailed if exclusive access denied\n      pub fn open(path: impl AsRef<Path>) -> Result<Self, DriverError>;\n\n      /// Read next event with timeout.\n      pub fn read_event(&mut self, timeout: Duration) -> Result<Option<InputEvent>, DriverError>;\n\n      /// Check if device is still connected.\n      pub fn is_connected(&self) -> bool;\n  }\n\n  impl Drop for SafeDevice {\n      fn drop(&mut self) {\n          if self.grabbed {\n              let _ = self.device.ungrab();\n          }\n      }\n  }\n  ```\n- **Dependencies:** evdev crate\n- **Reuses:** evdev safe APIs\n\n### Component 5: SafeUinput (Linux)\n\n- **Purpose:** Safe wrapper for uinput virtual device\n- **Interfaces:**\n  ```rust\n  /// Safe wrapper for Linux uinput virtual device.\n  ///\n  /// # Safety Invariants\n  /// - Virtual device is created on construction\n  /// - Device is destroyed on Drop\n  /// - Events are validated before injection\n  pub struct SafeUinput {\n      device: UInputDevice,\n  }\n\n  impl SafeUinput {\n      /// Create a virtual keyboard device.\n      pub fn create_keyboard(name: &str) -> Result<Self, DriverError>;\n\n      /// Inject a key event.\n      pub fn inject(&mut self, event: KeyEvent) -> Result<(), DriverError>;\n\n      /// Sync events (required after injection).\n      pub fn sync(&mut self) -> Result<(), DriverError>;\n  }\n  ```\n- **Dependencies:** uinput crate\n- **Reuses:** uinput safe APIs\n\n### Component 6: DriverError\n\n- **Purpose:** Unified driver errors with recovery hints\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, thiserror::Error)]\n  pub enum DriverError {\n      #[error(\"Device not found: {path}\")]\n      DeviceNotFound { path: PathBuf },\n\n      #[error(\"Permission denied: {resource} (hint: {hint})\")]\n      PermissionDenied { resource: String, hint: String },\n\n      #[error(\"Device disconnected: {device}\")]\n      DeviceDisconnected { device: String },\n\n      #[error(\"Hook installation failed: {code}\")]\n      HookFailed { code: u32 },\n\n      #[error(\"Grab failed: {reason}\")]\n      GrabFailed { reason: String },\n\n      #[error(\"Temporary error (retryable): {message}\")]\n      Temporary { message: String, retry_after: Duration },\n\n      #[error(\"Platform error: {0}\")]\n      Platform(#[from] std::io::Error),\n  }\n\n  impl DriverError {\n      pub fn is_retryable(&self) -> bool;\n      pub fn suggested_action(&self) -> &'static str;\n  }\n  ```\n- **Dependencies:** thiserror\n- **Reuses:** Error patterns\n\n## Data Models\n\n### KeyEvent\n```rust\n#[derive(Debug, Clone)]\npub struct KeyEvent {\n    pub key: KeyCode,\n    pub pressed: bool,\n    pub timestamp: u64,\n    pub scan_code: u16,\n}\n```\n\n### HookAction\n```rust\n#[derive(Debug, Clone, Copy)]\npub enum HookAction {\n    Block,\n    PassThrough,\n    Replace(KeyCode),\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Hook installation fails**\n   - **Handling:** Return `DriverError::HookFailed` with Windows error code\n   - **User Impact:** Clear message about what failed\n\n2. **Device disconnection**\n   - **Handling:** Return `DriverError::DeviceDisconnected`, engine reconnects\n   - **User Impact:** Brief interruption, auto-recovery\n\n3. **Permission denied on Linux**\n   - **Handling:** Return error with hint about input group membership\n   - **User Impact:** Actionable fix suggestion\n\n4. **Panic in hook callback**\n   - **Handling:** Catch, log, return PassThrough\n   - **User Impact:** Key works normally, bug is logged\n\n## Testing Strategy\n\n### Unit Testing\n- Test error type construction\n- Test recovery suggestions\n- Test is_retryable logic\n\n### Integration Testing\n- Test hook lifecycle (install/uninstall)\n- Test device open/close\n- Test error handling paths\n\n### Platform Testing\n- Test on Windows 10/11\n- Test on Linux with various kernels\n- Test device disconnection scenarios\n",
  "fileStats": {
    "size": 9221,
    "lines": 336,
    "lastModified": "2025-12-03T13:05:55.060Z"
  },
  "comments": []
}