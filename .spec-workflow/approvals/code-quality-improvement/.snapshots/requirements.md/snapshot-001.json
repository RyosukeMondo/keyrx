{
  "id": "snapshot_1764717707209_518z3bk7b",
  "approvalId": "approval_1764717707204_irzrjaxcc",
  "approvalTitle": "Code Quality Improvement - Requirements Document",
  "version": 1,
  "timestamp": "2025-12-02T23:21:47.209Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThis spec addresses critical code quality issues identified in the KeyRx codebase that block testability, violate architectural principles, and create maintenance burden. These issues must be resolved before implementing new features to ensure a solid foundation.\n\n**Philosophy:** Clean code enables velocity. Fixing these issues now prevents compounding technical debt.\n\n## Alignment with CLAUDE.md Guidelines\n\nFrom CLAUDE.md:\n- **Code Metrics**: Max 500 lines/file, Max 50 lines/function, 80% test coverage\n- **Architecture**: SOLID, DI mandatory, SSOT, KISS, SLAP\n- **All external deps injected**: APIs, DBs, queues\n- **No testability blockers**: No globals, mockable dependencies\n\n## Issue Categories\n\n### Priority 1: Testability Blockers (Must Fix)\nIssues that prevent proper unit testing:\n- Global state requiring serial test execution\n- Non-injectable dependencies\n- Hardcoded service access\n\n### Priority 2: SSOT Violations (Must Fix)\nMultiple sources of truth causing data inconsistency:\n- Duplicate state representations\n- Unsynchronized data copies\n\n### Priority 3: SLAP/SRP Violations (Should Fix)\nCode organization issues:\n- Functions mixing abstraction levels\n- Files with too many responsibilities\n\n### Priority 4: DRY Violations (Should Fix)\nCode duplication creating maintenance burden\n\n---\n\n## Requirements\n\n### Requirement 1: Eliminate Global Runtime State (Rust)\n\n**User Story:** As a developer, I want to run tests in parallel without interference, so that CI is fast and reliable.\n\n#### Acceptance Criteria\n\n1. WHEN tests run, THEN they SHALL execute in parallel without `#[serial]` attribute\n2. WHEN a test needs a runtime, THEN it SHALL create its own isolated instance\n3. WHEN the engine initializes, THEN runtime SHALL be passed via dependency injection\n4. WHEN bypass mode is tested, THEN each test SHALL have independent state\n5. WHEN FFI callbacks are tested, THEN they SHALL be mockable per test\n\n### Requirement 2: Injectable Services in Flutter (Flutter)\n\n**User Story:** As a developer, I want to inject mock services into widgets, so that I can test UI components in isolation.\n\n#### Acceptance Criteria\n\n1. WHEN a page needs a service, THEN it SHALL accept it via constructor parameter\n2. WHEN a page is constructed, THEN required services SHALL NOT be nullable\n3. WHEN testing a page, THEN mock services SHALL be injectable without Provider\n4. WHEN TextEditingControllers are needed, THEN they SHALL be injectable or created in a testable pattern\n5. WHEN services are accessed, THEN it SHALL NOT be via Provider.of in initState\n\n### Requirement 3: Single Source of Truth for State (Flutter)\n\n**User Story:** As a developer, I want one canonical source for each piece of state, so that data is always consistent.\n\n#### Acceptance Criteria\n\n1. WHEN layer configuration exists, THEN it SHALL be stored ONLY in AppState\n2. WHEN editor pages need layers, THEN they SHALL read from AppState\n3. WHEN mappings are edited, THEN a single MappingRepository SHALL be the source\n4. WHEN switching between editors, THEN mappings SHALL persist correctly\n5. WHEN classification results stream, THEN a single buffer SHALL exist in service layer\n\n### Requirement 4: Consolidate Rust State Representations\n\n**User Story:** As a developer, I want one state model, so that changes don't require updating multiple structs.\n\n#### Acceptance Criteria\n\n1. WHEN engine state is serialized, THEN ONE struct SHALL represent it\n2. WHEN `EngineState` and `PendingDecisionState` overlap, THEN they SHALL be unified\n3. WHEN state is converted for FFI, THEN conversion SHALL happen at boundary only\n4. WHEN state snapshots are created, THEN they SHALL derive from single source\n\n### Requirement 5: Reduce Function Complexity (Rust)\n\n**User Story:** As a developer, I want functions under 50 lines, so that code is readable and testable.\n\n#### Acceptance Criteria\n\n1. WHEN `process_event_traced()` is refactored, THEN it SHALL be ≤50 lines\n2. WHEN the function is split, THEN each sub-function SHALL have single responsibility\n3. WHEN sub-functions are created, THEN they SHALL be independently testable\n4. WHEN abstraction levels are mixed, THEN they SHALL be separated into layers\n\n### Requirement 6: Reduce File Size (Rust)\n\n**User Story:** As a developer, I want files under 500 lines, so that code is navigable and maintainable.\n\n#### Acceptance Criteria\n\n1. WHEN `run.rs` is refactored, THEN it SHALL be ≤500 lines\n2. WHEN `discover.rs` is refactored, THEN it SHALL be ≤500 lines\n3. WHEN `runtime.rs` is refactored, THEN it SHALL be ≤500 lines\n4. WHEN `exports.rs` is refactored, THEN it SHALL be ≤500 lines\n5. WHEN files are split, THEN each new file SHALL have clear single purpose\n\n### Requirement 7: Reduce Page Complexity (Flutter)\n\n**User Story:** As a developer, I want pages focused on UI composition only, so that business logic is testable separately.\n\n#### Acceptance Criteria\n\n1. WHEN `editor_page.dart` is refactored, THEN business logic SHALL move to services\n2. WHEN `visual_editor_page.dart` is refactored, THEN file I/O SHALL move to services\n3. WHEN `console.dart` is refactored, THEN command parsing SHALL move to services\n4. WHEN pages are refactored, THEN each SHALL be ≤300 lines\n5. WHEN validation logic exists, THEN it SHALL be in dedicated validator classes\n\n### Requirement 8: Eliminate Duplicate Code Patterns\n\n**User Story:** As a developer, I want shared patterns extracted, so that fixes apply everywhere.\n\n#### Acceptance Criteria\n\n1. WHEN layer action handling is needed, THEN ONE function SHALL handle both cases\n2. WHEN error handling follows a pattern, THEN a helper SHALL be used\n3. WHEN service initialization is needed, THEN a mixin/base class SHALL provide it\n4. WHEN stream subscriptions are created, THEN a helper pattern SHALL be used\n5. WHEN duplicated code is found, THEN it SHALL be extracted to shared location\n\n### Requirement 9: Improve Dependency Injection (Rust)\n\n**User Story:** As a developer, I want all engine dependencies injectable, so that I can test with mocks.\n\n#### Acceptance Criteria\n\n1. WHEN AdvancedEngine is created, THEN key state tracker SHALL be injectable\n2. WHEN AdvancedEngine is created, THEN modifier state SHALL be injectable\n3. WHEN AdvancedEngine is created, THEN layer stack SHALL be injectable\n4. WHEN testing engine, THEN mock implementations SHALL be substitutable\n5. WHEN traits exist, THEN they SHALL follow interface segregation principle\n\n---\n\n## Non-Functional Requirements\n\n### Test Coverage\n- After refactoring, test coverage SHALL be ≥80%\n- All new extracted functions SHALL have unit tests\n- Parallel test execution SHALL work without failures\n\n### Performance\n- Refactoring SHALL NOT introduce performance regression\n- Benchmark results SHALL remain within 5% of baseline\n\n### Compatibility\n- All existing tests SHALL continue to pass\n- All CLI commands SHALL work identically\n- All UI features SHALL work identically\n",
  "fileStats": {
    "size": 6972,
    "lines": 165,
    "lastModified": "2025-12-02T23:21:36.992Z"
  },
  "comments": []
}