{
  "id": "snapshot_1764729444278_m4tmt7dbu",
  "approvalId": "approval_1764717707254_nfd6ru2eu",
  "approvalTitle": "Code Quality Improvement - Design Document",
  "version": 2,
  "timestamp": "2025-12-03T02:37:24.278Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design addresses critical code quality issues across both Rust core and Flutter UI. The refactoring follows a systematic approach: first eliminate testability blockers, then consolidate state, then reduce complexity, and finally eliminate duplication.\n\n## Steering Document Alignment\n\n### Technical Standards (CLAUDE.md)\n\n- **Max 500 lines/file**: Split 4 oversized Rust files, 3 oversized Flutter pages\n- **Max 50 lines/function**: Refactor `process_event_traced()` (98 lines)\n- **SOLID/DI mandatory**: Add trait-based injection to AdvancedEngine\n- **SSOT**: Consolidate duplicate state in Flutter AppState\n- **No testability blockers**: Remove globals, enable parallel tests\n\n## Architecture\n\n### Refactoring Strategy\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                        Phase 1: Testability                                  │\n│  Remove globals → Enable DI → Enable parallel tests                         │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                        Phase 2: SSOT                                         │\n│  Consolidate state → Single MappingRepository → Unified EngineState         │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                        Phase 3: Complexity                                   │\n│  Split functions → Split files → Extract services                           │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                        Phase 4: DRY                                          │\n│  Extract helpers → Create mixins → Unify patterns                           │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n## Components and Interfaces\n\n### Component 1: Runtime Context (Rust)\n\n**Purpose:** Replace global `RUNTIME_SLOT` with injectable context\n\n**Current (Bad):**\n```rust\n// Global static with unsafe\nstatic RUNTIME_SLOT: RuntimeSlot = RuntimeSlot { ... };\n```\n\n**New Design:**\n```rust\n// core/src/scripting/context.rs (new)\npub struct RuntimeContext {\n    engine: Engine,\n    pending_ops: Vec<PendingOp>,\n    registry: Registry,\n}\n\nimpl RuntimeContext {\n    pub fn new() -> Self { ... }\n    pub fn with_registry(registry: Registry) -> Self { ... }\n}\n\n// Passed to functions that need it\npub fn process_script(ctx: &mut RuntimeContext, script: &str) -> Result<()>\n```\n\n**Files:**\n- `core/src/scripting/context.rs` (new)\n- `core/src/scripting/runtime.rs` (modify - remove global)\n- `core/src/scripting/mod.rs` (modify - export context)\n\n### Component 2: Bypass State Injection (Rust)\n\n**Purpose:** Make bypass mode testable without global state\n\n**Current (Bad):**\n```rust\nstatic BYPASS_MODE: AtomicBool = AtomicBool::new(false);\n```\n\n**New Design:**\n```rust\n// core/src/drivers/bypass.rs (new)\npub struct BypassController {\n    active: AtomicBool,\n    callback: Option<Box<dyn Fn() + Send + Sync>>,\n}\n\nimpl BypassController {\n    pub fn new() -> Self { ... }\n    pub fn activate(&self) { ... }\n    pub fn is_active(&self) -> bool { ... }\n}\n\n// Injected into engine\npub struct Engine<B: BypassControl> {\n    bypass: B,\n    // ...\n}\n```\n\n**Files:**\n- `core/src/drivers/bypass.rs` (new)\n- `core/src/drivers/emergency_exit.rs` (modify)\n- `core/src/engine/mod.rs` (modify - accept bypass)\n\n### Component 3: Engine Dependency Traits (Rust)\n\n**Purpose:** Enable injection of all engine dependencies\n\n**New Design:**\n```rust\n// core/src/traits/state.rs (new)\npub trait KeyStateProvider {\n    fn is_pressed(&self, key: KeyCode) -> bool;\n    fn press(&mut self, key: KeyCode);\n    fn release(&mut self, key: KeyCode);\n}\n\npub trait ModifierProvider {\n    fn is_active(&self, modifier: Modifier) -> bool;\n    fn activate(&mut self, modifier: Modifier);\n    fn deactivate(&mut self, modifier: Modifier);\n}\n\npub trait LayerProvider {\n    fn active_layer(&self) -> &str;\n    fn push(&mut self, layer: &str);\n    fn pop(&mut self);\n}\n\n// Engine accepts trait objects\npub struct AdvancedEngine<S, K, M, L>\nwhere\n    S: ScriptRuntime,\n    K: KeyStateProvider,\n    M: ModifierProvider,\n    L: LayerProvider,\n{\n    script: S,\n    key_state: K,\n    modifiers: M,\n    layers: L,\n    // ...\n}\n```\n\n**Files:**\n- `core/src/traits/state.rs` (new)\n- `core/src/traits/mod.rs` (modify)\n- `core/src/engine/advanced.rs` (modify)\n\n### Component 4: Split process_event_traced (Rust)\n\n**Purpose:** Reduce 98-line function to ≤50 lines each\n\n**Current Structure:**\n```rust\nfn process_event_traced() {\n    // 1. Input validation (10 lines)\n    // 2. Safe mode check (10 lines)\n    // 3. Key state update (10 lines)\n    // 4. Combo handling (15 lines)\n    // 5. Decision resolution (15 lines)\n    // 6. Layer lookup (15 lines)\n    // 7. Output composition (15 lines)\n    // 8. Tracing (8 lines)\n}\n```\n\n**New Design:**\n```rust\n// core/src/engine/processing.rs (new)\nfn process_event_traced(&mut self, event: KeyEvent) -> ProcessResult {\n    self.validate_and_check_safe_mode(&event)?;\n    self.update_key_state(&event);\n\n    let decision = self.resolve_decision(&event);\n    let outputs = self.apply_decision(decision);\n\n    self.trace_event(&event, &outputs);\n    Ok(outputs)\n}\n\nfn validate_and_check_safe_mode(&self, event: &KeyEvent) -> Result<()> { ... }\nfn update_key_state(&mut self, event: &KeyEvent) { ... }\nfn resolve_decision(&mut self, event: &KeyEvent) -> Decision { ... }\nfn apply_decision(&mut self, decision: Decision) -> Vec<Output> { ... }\nfn trace_event(&self, event: &KeyEvent, outputs: &[Output]) { ... }\n```\n\n**Files:**\n- `core/src/engine/processing.rs` (new)\n- `core/src/engine/advanced.rs` (modify - delegate to processing)\n\n### Component 5: Split Oversized Rust Files\n\n**Purpose:** Reduce files to ≤500 lines\n\n| Current File | Lines | Split Into |\n|--------------|-------|------------|\n| `run.rs` (713) | 713 | `run.rs` (200), `run_builder.rs` (200), `run_recorder.rs` (150), `run_tracer.rs` (150) |\n| `discover.rs` (712) | 712 | `discover.rs` (200), `discover_session.rs` (250), `discover_validation.rs` (200) |\n| `runtime.rs` (683) | 683 | `runtime.rs` (250), `pending_ops.rs` (200), `registry_sync.rs` (200) |\n| `exports.rs` (635) | 635 | `exports.rs` (200), `exports_device.rs` (150), `exports_session.rs` (150), `exports_engine.rs` (150) |\n\n### Component 6: Flutter Service Injection Pattern\n\n**Purpose:** Enable constructor-based dependency injection\n\n**Current (Bad):**\n```dart\nclass EditorPage extends StatefulWidget {\n  @override\n  _EditorPageState createState() => _EditorPageState();\n}\n\nclass _EditorPageState extends State<EditorPage> {\n  EngineService? _engine;  // Nullable!\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      _engine = Provider.of<ServiceRegistry>(context).engineService;\n    });\n  }\n}\n```\n\n**New Design:**\n```dart\n// ui/lib/pages/editor_page.dart\nclass EditorPage extends StatefulWidget {\n  final EngineService engine;  // Required!\n  final MappingRepository mappings;\n\n  const EditorPage({\n    required this.engine,\n    required this.mappings,\n    super.key,\n  });\n\n  @override\n  _EditorPageState createState() => _EditorPageState();\n}\n\n// In main.dart or router\nEditorPage(\n  engine: registry.engineService,\n  mappings: registry.mappingRepository,\n)\n```\n\n**Files:**\n- `ui/lib/pages/editor_page.dart` (modify)\n- `ui/lib/pages/console.dart` (modify)\n- `ui/lib/pages/debugger_page.dart` (modify)\n- `ui/lib/pages/training_screen.dart` (modify)\n- `ui/lib/main.dart` (modify - pass dependencies)\n\n### Component 7: MappingRepository (Flutter)\n\n**Purpose:** Single source of truth for key mappings\n\n**New Design:**\n```dart\n// ui/lib/repositories/mapping_repository.dart (new)\nclass MappingRepository extends ChangeNotifier {\n  final Map<String, KeyMapping> _mappings = {};\n  final List<ComboMapping> _combos = [];\n  final List<TapHoldConfig> _tapHolds = [];\n\n  // Single source of truth\n  UnmodifiableMapView<String, KeyMapping> get mappings =>\n      UnmodifiableMapView(_mappings);\n\n  void addMapping(String key, KeyMapping mapping) {\n    _mappings[key] = mapping;\n    notifyListeners();\n  }\n\n  void removeMapping(String key) {\n    _mappings.remove(key);\n    notifyListeners();\n  }\n\n  String generateScript() {\n    return ScriptGenerator.build(_mappings, _combos, _tapHolds);\n  }\n}\n```\n\n**Files:**\n- `ui/lib/repositories/mapping_repository.dart` (new)\n- `ui/lib/repositories/mod.dart` (new - barrel export)\n- `ui/lib/services/service_registry.dart` (modify - add repository)\n\n### Component 8: Consolidate Layer State (Flutter)\n\n**Purpose:** Remove duplicate layer state from EditorPage\n\n**Current (Bad):**\n```dart\n// editor_page.dart\nList<LayerInfo> _layers = [LayerInfo(name: 'base', ...)];\n\n// app_state.dart\nList<LayerInfo> _layers = [];\n```\n\n**New Design:**\n```dart\n// app_state.dart - ONLY source\nclass AppState extends ChangeNotifier {\n  List<LayerInfo> _layers = [LayerInfo(name: 'base', active: true, priority: 0)];\n\n  UnmodifiableListView<LayerInfo> get layers => UnmodifiableListView(_layers);\n\n  void addLayer(LayerInfo layer) { ... }\n  void removeLayer(String name) { ... }\n  void setLayerActive(String name, bool active) { ... }\n}\n\n// editor_page.dart - reads from AppState\nclass _EditorPageState extends State<EditorPage> {\n  // NO local _layers field!\n\n  @override\n  Widget build(BuildContext context) {\n    final appState = context.watch<AppState>();\n    final layers = appState.layers;  // Read from single source\n    // ...\n  }\n}\n```\n\n**Files:**\n- `ui/lib/state/app_state.dart` (modify)\n- `ui/lib/pages/editor_page.dart` (modify - remove local layers)\n- `ui/lib/pages/visual_editor_page.dart` (modify - use AppState)\n\n### Component 9: Extract Business Logic from Pages (Flutter)\n\n**Purpose:** Move validation/parsing to dedicated services\n\n**New Services:**\n```dart\n// ui/lib/services/mapping_validator.dart (new)\nclass MappingValidator {\n  final KeyRegistry keyRegistry;\n\n  MappingValidator(this.keyRegistry);\n\n  ValidationResult validate(String fromKey, KeyMapping mapping) {\n    if (!keyRegistry.isKnownKey(fromKey)) {\n      return ValidationResult.error('Unknown key: $fromKey');\n    }\n    // ... more validation\n    return ValidationResult.success();\n  }\n}\n\n// ui/lib/services/console_parser.dart (new)\nclass ConsoleParser {\n  ConsoleEntryType classify(String text) {\n    final lower = text.toLowerCase();\n    if (lower.startsWith('error:')) return ConsoleEntryType.error;\n    if (lower.startsWith('ok:')) return ConsoleEntryType.success;\n    return ConsoleEntryType.output;\n  }\n\n  bool needsInitButton(String text) {\n    return text.toLowerCase().contains('not initialized');\n  }\n}\n\n// ui/lib/services/script_file_service.dart (new)\nclass ScriptFileService {\n  Future<void> saveScript(String path, String content) async {\n    final file = File(path);\n    await file.parent.create(recursive: true);\n    await file.writeAsString(content);\n  }\n\n  Future<String> loadScript(String path) async {\n    return File(path).readAsString();\n  }\n}\n```\n\n**Files:**\n- `ui/lib/services/mapping_validator.dart` (new)\n- `ui/lib/services/console_parser.dart` (new)\n- `ui/lib/services/script_file_service.dart` (new)\n\n### Component 10: Stream Subscription Mixin (Flutter)\n\n**Purpose:** Extract repeated stream subscription pattern\n\n**New Design:**\n```dart\n// ui/lib/mixins/stream_subscriber.dart (new)\nmixin StreamSubscriber<T extends StatefulWidget> on State<T> {\n  final List<StreamSubscription> _subscriptions = [];\n\n  void subscribe<S>(Stream<S> stream, void Function(S) onData, {\n    void Function(Object)? onError,\n  }) {\n    final sub = stream.listen(\n      (data) {\n        if (!mounted) return;\n        onData(data);\n      },\n      onError: onError ?? (e) => debugPrint('Stream error: $e'),\n    );\n    _subscriptions.add(sub);\n  }\n\n  @override\n  void dispose() {\n    for (final sub in _subscriptions) {\n      sub.cancel();\n    }\n    super.dispose();\n  }\n}\n\n// Usage in pages:\nclass _DebuggerPageState extends State<DebuggerPage>\n    with StreamSubscriber {\n\n  @override\n  void initState() {\n    super.initState();\n    subscribe(widget.engine.stateStream, _handleSnapshot);\n  }\n\n  void _handleSnapshot(EngineSnapshot snapshot) {\n    setState(() => _recent.insert(0, snapshot));\n  }\n}\n```\n\n**Files:**\n- `ui/lib/mixins/stream_subscriber.dart` (new)\n- `ui/lib/mixins/mod.dart` (new)\n\n### Component 11: Unify Layer Action Handlers (Rust)\n\n**Purpose:** Remove 95% duplicate code\n\n**Current (Bad):**\n```rust\n// Two nearly identical functions\npub fn handle_layer_action(..., event, action) -> LayerActionResult { ... }\npub fn execute_layer_action(..., action) -> Vec<OutputAction> { ... }\n```\n\n**New Design:**\n```rust\n// core/src/engine/layer_actions.rs (new)\npub fn apply_layer_action(\n    action: &LayerAction,\n    modifiers: &mut ModifierState,\n    layers: &mut LayerStack,\n    event: Option<&KeyEvent>,  // Optional context\n) -> LayerActionResult {\n    match action {\n        LayerAction::Push(name) => { ... }\n        LayerAction::Pop => { ... }\n        LayerAction::Toggle(name) => { ... }\n        // ... unified handling\n    }\n}\n\n// Wrappers for backward compatibility\npub fn handle_layer_action(...) -> LayerActionResult {\n    apply_layer_action(action, modifiers, layers, Some(event))\n}\n\npub fn execute_layer_action(...) -> Vec<OutputAction> {\n    apply_layer_action(action, modifiers, layers, None).into_outputs()\n}\n```\n\n**Files:**\n- `core/src/engine/layer_actions.rs` (new)\n- `core/src/engine/decision_engine.rs` (modify - use unified function)\n\n## Data Models\n\nNo new data models required - this refactoring reorganizes existing code.\n\n## Error Handling\n\n- All refactored functions maintain existing error handling behavior\n- New extracted functions propagate errors via `Result<T, E>`\n- Flutter services use typed exceptions\n\n## Testing Strategy\n\n### Unit Testing\n- Each extracted Rust function gets dedicated unit tests\n- Each new Flutter service gets widget tests with mocks\n- Dependency injection enables isolated testing\n\n### Integration Testing\n- Existing integration tests must continue passing\n- New parallel test execution validates removal of globals\n\n### Regression Testing\n- All CLI commands tested before/after\n- All UI flows tested before/after\n- Benchmark comparison for performance regression\n\n## Implementation Sequence\n\n1. **Rust Testability** (Tasks 1-4) - Remove globals, add DI\n2. **Rust Complexity** (Tasks 5-8) - Split functions, split files\n3. **Rust DRY** (Tasks 9-10) - Unify duplicates\n4. **Flutter Testability** (Tasks 11-14) - Constructor injection\n5. **Flutter SSOT** (Tasks 15-17) - Consolidate state\n6. **Flutter Complexity** (Tasks 18-21) - Extract services\n7. **Flutter DRY** (Tasks 22-23) - Create mixins\n8. **Verification** (Tasks 24-25) - Tests, coverage\n",
  "fileStats": {
    "size": 15636,
    "lines": 527,
    "lastModified": "2025-12-02T23:21:37.053Z"
  },
  "comments": []
}