{
  "id": "snapshot_1764767191572_lsxio0yc3",
  "approvalId": "approval_1764767191552_f3sywiy3i",
  "approvalTitle": "Validation Decomposition - Design",
  "version": 1,
  "timestamp": "2025-12-03T13:06:31.572Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design decomposes the monolithic `conflicts.rs` (1,321 LOC) into focused submodules organized by detection concern. The core innovation is the `Detector` trait that allows the validation engine to orchestrate multiple detection passes uniformly while each detector focuses on its specific concern.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Single Responsibility**: Each detector handles one concern\n- **Modular Design**: Detectors are pluggable\n- **Dependency Injection**: Detectors receive operations, don't fetch them\n\n### Project Structure (structure.md)\n- New structure: `validation/detectors/{conflicts,shadowing,cycles}.rs`\n- Shared utilities: `validation/common/{visitor,error,report}.rs`\n- Tests: `validation/tests/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`PendingOp`**: Operation type already well-defined\n- **`ValidationEngine`**: Orchestrator that will consume detectors\n- **`Span`/location types**: Reuse for error reporting\n\n### Integration Points\n- **ValidationEngine**: Calls each detector in sequence\n- **CLI check command**: Receives detector results\n- **Flutter validation display**: Consumes structured errors\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Validation Engine\"\n        VE[ValidationEngine] --> DO[Detector Orchestrator]\n    end\n\n    subgraph \"Detectors\"\n        DO --> CD[ConflictDetector]\n        DO --> SD[ShadowingDetector]\n        DO --> CYD[CycleDetector]\n    end\n\n    subgraph \"Common\"\n        CD --> OV[OperationVisitor]\n        SD --> OV\n        CYD --> OV\n        CD --> RB[ReportBuilder]\n        SD --> RB\n        CYD --> RB\n    end\n\n    subgraph \"Output\"\n        RB --> VR[ValidationReport]\n        VR --> ERR[ValidationError]\n    end\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each detector file handles one detection type\n- **Component Isolation**: Detectors communicate only through common types\n- **Service Layer Separation**: Engine (orchestration) → Detectors (analysis) → Common (utilities)\n- **Utility Modularity**: Shared visitor, error, report building\n\n## Components and Interfaces\n\n### Component 1: Detector Trait\n\n- **Purpose:** Common interface for all validation detectors\n- **Interfaces:**\n  ```rust\n  pub trait Detector: Send + Sync {\n      /// Detector name for reporting\n      fn name(&self) -> &'static str;\n\n      /// Run detection on operations\n      fn detect(&self, ops: &[PendingOp], ctx: &DetectorContext) -> DetectorResult;\n\n      /// Whether this detector can be skipped (for performance)\n      fn is_skippable(&self) -> bool { false }\n  }\n\n  pub struct DetectorContext {\n      pub script_path: Option<PathBuf>,\n      pub config: ValidationConfig,\n  }\n\n  pub struct DetectorResult {\n      pub issues: Vec<ValidationIssue>,\n      pub stats: DetectorStats,\n  }\n  ```\n- **Dependencies:** None (trait definition)\n- **Reuses:** Rust trait pattern\n\n### Component 2: ConflictDetector\n\n- **Purpose:** Detect remap/block conflicts for same key\n- **Interfaces:**\n  ```rust\n  pub struct ConflictDetector;\n\n  impl Detector for ConflictDetector {\n      fn name(&self) -> &'static str { \"conflict\" }\n\n      fn detect(&self, ops: &[PendingOp], ctx: &DetectorContext) -> DetectorResult {\n          let mut issues = Vec::new();\n          let mut key_ops: HashMap<KeyCode, Vec<&PendingOp>> = HashMap::new();\n\n          // Group operations by target key\n          for op in ops {\n              key_ops.entry(op.target_key()).or_default().push(op);\n          }\n\n          // Detect conflicts within each group\n          for (key, ops) in key_ops {\n              if ops.len() > 1 {\n                  issues.push(self.build_conflict_issue(key, &ops));\n              }\n          }\n\n          DetectorResult { issues, stats: self.stats() }\n      }\n  }\n  ```\n- **Dependencies:** `Detector` trait, `PendingOp`, `ValidationIssue`\n- **Reuses:** Logic from current `conflicts.rs` conflict detection\n\n### Component 3: ShadowingDetector\n\n- **Purpose:** Detect combo shadowing by individual remaps\n- **Interfaces:**\n  ```rust\n  pub struct ShadowingDetector;\n\n  impl Detector for ShadowingDetector {\n      fn name(&self) -> &'static str { \"shadowing\" }\n\n      fn detect(&self, ops: &[PendingOp], ctx: &DetectorContext) -> DetectorResult {\n          let combos: Vec<_> = ops.iter().filter(|op| op.is_combo()).collect();\n          let remaps: Vec<_> = ops.iter().filter(|op| op.is_remap()).collect();\n\n          let mut issues = Vec::new();\n\n          for combo in &combos {\n              // Check if any combo key is individually remapped\n              for key in combo.keys() {\n                  if let Some(remap) = remaps.iter().find(|r| r.source_key() == key) {\n                      issues.push(self.build_shadowing_issue(combo, remap));\n                  }\n              }\n          }\n\n          DetectorResult { issues, stats: self.stats() }\n      }\n\n      fn is_skippable(&self) -> bool { true }  // Can skip for performance\n  }\n  ```\n- **Dependencies:** `Detector` trait, combo/remap operation types\n- **Reuses:** Logic from current shadowing detection\n\n### Component 4: CycleDetector\n\n- **Purpose:** Detect circular remap dependencies using DFS\n- **Interfaces:**\n  ```rust\n  pub struct CycleDetector;\n\n  impl Detector for CycleDetector {\n      fn name(&self) -> &'static str { \"cycle\" }\n\n      fn detect(&self, ops: &[PendingOp], ctx: &DetectorContext) -> DetectorResult {\n          // Build adjacency list from remaps\n          let graph = self.build_remap_graph(ops);\n\n          // DFS to find cycles\n          let cycles = self.find_cycles(&graph);\n\n          let issues = cycles.into_iter()\n              .map(|cycle| self.build_cycle_issue(cycle))\n              .collect();\n\n          DetectorResult { issues, stats: self.stats() }\n      }\n  }\n\n  impl CycleDetector {\n      fn find_cycles(&self, graph: &HashMap<KeyCode, KeyCode>) -> Vec<Vec<KeyCode>> {\n          // Tarjan's or simple DFS with coloring\n          let mut cycles = Vec::new();\n          let mut visited = HashSet::new();\n          let mut rec_stack = HashSet::new();\n\n          for &start in graph.keys() {\n              if !visited.contains(&start) {\n                  self.dfs(start, graph, &mut visited, &mut rec_stack, &mut cycles);\n              }\n          }\n\n          cycles\n      }\n  }\n  ```\n- **Dependencies:** `Detector` trait, graph algorithms\n- **Reuses:** Logic from current cycle detection\n\n### Component 5: OperationVisitor\n\n- **Purpose:** Shared utility for traversing operations\n- **Interfaces:**\n  ```rust\n  pub trait OperationVisitor {\n      fn visit_remap(&mut self, op: &RemapOp);\n      fn visit_block(&mut self, op: &BlockOp);\n      fn visit_combo(&mut self, op: &ComboOp);\n      fn visit_pass(&mut self, op: &PassOp);\n  }\n\n  pub fn visit_all(ops: &[PendingOp], visitor: &mut impl OperationVisitor) {\n      for op in ops {\n          match op {\n              PendingOp::Remap(r) => visitor.visit_remap(r),\n              PendingOp::Block(b) => visitor.visit_block(b),\n              PendingOp::Combo(c) => visitor.visit_combo(c),\n              PendingOp::Pass(p) => visitor.visit_pass(p),\n          }\n      }\n  }\n  ```\n- **Dependencies:** `PendingOp` variants\n- **Reuses:** Visitor pattern\n\n## Data Models\n\n### ValidationIssue\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct ValidationIssue {\n    pub severity: Severity,\n    pub detector: &'static str,\n    pub message: String,\n    pub locations: Vec<SourceLocation>,\n    pub suggestion: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, Serialize)]\npub enum Severity {\n    Error,\n    Warning,\n    Info,\n}\n```\n\n### DetectorStats\n```rust\n#[derive(Debug, Default)]\npub struct DetectorStats {\n    pub operations_checked: usize,\n    pub issues_found: usize,\n    pub duration_us: u64,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Multiple conflicts for same key**\n   - **Handling:** Group into single issue with all conflicting operations\n   - **User Impact:** See all conflicts at once\n\n2. **Complex cycle (3+ keys)**\n   - **Handling:** Report full cycle path\n   - **User Impact:** Understand complete dependency chain\n\n3. **Performance timeout**\n   - **Handling:** Skip expensive detectors if flagged\n   - **User Impact:** Faster validation, warning about skipped checks\n\n## Testing Strategy\n\n### Unit Testing\n- Test each detector in isolation with mock operations\n- Verify issue detection accuracy\n- Test edge cases (empty ops, single op, etc.)\n\n### Integration Testing\n- Test full validation pipeline with all detectors\n- Verify detector ordering doesn't affect results\n- Test with real Rhai scripts\n\n### Performance Testing\n- Benchmark each detector with large operation sets\n- Verify O(n) or O(V+E) complexity claims\n- Test detector skipping mechanism\n",
  "fileStats": {
    "size": 8781,
    "lines": 298,
    "lastModified": "2025-12-03T12:59:42.974Z"
  },
  "comments": []
}