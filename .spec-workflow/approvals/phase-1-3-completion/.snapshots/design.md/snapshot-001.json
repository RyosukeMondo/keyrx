{
  "id": "snapshot_1764682514896_7ftdw5aod",
  "approvalId": "approval_1764682514888_zyuqqwkgb",
  "approvalTitle": "Phase 1-3 Completion Design",
  "version": 1,
  "timestamp": "2025-12-02T13:35:14.896Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Phase 1-3 Completion: Design Document\n\n## Overview\n\nThis design document details the technical implementation of Phase 1-3 completion features: script testing, REPL console, session recording/replay, FFI fixes, event tracing, and Flutter UI enhancements. The implementation follows KeyRx's CLI-first philosophy, modular architecture, and CLAUDE.md code quality standards.\n\n**Key Design Principles:**\n- Reuse existing Rhai runtime infrastructure (no reimplementation)\n- CLI commands separate from core logic (injectable dependencies)\n- Event recording as optional middleware to engine loop\n- Flutter UI as thin client over FFI bridge\n- Strict adherence to file/function size limits (≤500/50 lines)\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **CLI-First Development**: All features implemented as CLI commands first (§158-192)\n- **Rhai Scripting**: Leverage existing RhaiRuntime for all script evaluation (§193-240)\n- **FFI Bridge**: Extend existing keyrx_* FFI exports for new functionality (§241-292)\n- **Error Handling**: Structured JSON logging with timestamp, level, service, event (§449-508)\n- **Observability**: OpenTelemetry integration for tracing (§529-610)\n\n### Project Structure (structure.md)\n- **core/src/**: Rust engine and CLI commands\n  - `cli/commands/`: New `test.rs`, `repl.rs`, `replay.rs`, `record.rs`, `analyze.rs`\n  - `scripting/`: Extend `runtime.rs` → split into `runtime.rs`, `bindings.rs`, `builtins.rs`, `test_harness.rs`\n  - `engine/`: Add `event_recording.rs` module\n  - `ffi/`: Complete `exports.rs` script loading\n- **ui/lib/**: Flutter application\n  - `pages/`: Refactor `editor.dart` → `editor_page.dart` + `editor_widgets.dart`\n  - New pages: `training_screen.dart`, `trade_off_visualizer.dart`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n1. **RhaiRuntime** (`core/src/scripting/runtime.rs`)\n   - **How reused**: REPL, script testing, and FFI load_script all use the same runtime instance via shared Arc<Mutex<>>\n   - **Extension needed**: Export test primitives (simulate_tap, assert_output) as Rhai functions\n\n2. **Engine State & Decision** (`core/src/engine/`)\n   - **How reused**: Event recording intercepts process_event calls; state snapshots reuse existing state accessors\n   - **Extension needed**: Add `to_snapshot_json()` method to EngineState\n\n3. **Input Source Trait** (`core/src/traits/input_source.rs`)\n   - **How reused**: Session replay implements InputSource trait to inject recorded events\n   - **Extension needed**: None; replay_session will be a mock InputSource\n\n4. **FFI Exports** (`core/src/ffi/exports.rs`)\n   - **How reused**: Complete keyrx_load_script; add keyrx_eval_rhai for REPL/Flutter\n   - **Extension needed**: Add new FFI functions for recording/replay status\n\n5. **Flutter Bridge** (`ui/lib/ffi/bridge.dart`, `bindings.dart`)\n   - **How reused**: Extend BridgeState to include new fields from state snapshots\n   - **Extension needed**: Add bridge methods for training, trade-off data\n\n6. **Debugger Page** (`ui/lib/pages/debugger.dart`)\n   - **How reused**: Replace static demo data with live state stream\n   - **Extension needed**: Subscribe to keyrx_on_state callback\n\n### Integration Points\n\n- **Engine Event Loop** → Event Recording Middleware\n- **Rhai Runtime** → Test Harness (inject test functions)\n- **FFI Boundary** → REPL/Script Loading (string marshaling)\n- **Flutter UI** → State Snapshots (via keyrx_on_state callback stream)\n- **OpenTelemetry** → Engine Decision Points (emit spans on tap-hold, combo, layer changes)\n\n## Architecture\n\n### Phase 1: Iron Core - CLI-First Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    RhaiRuntime (Arc<Mutex>)                      │\n│  - Shared instance across test, repl, and runtime commands      │\n└───────────┬──────────────────┬──────────────────┬────────────────┘\n            │                  │                  │\n    ┌───────v──────┐   ┌──────v──────┐   ┌──────v─────┐\n    │ keyrx test   │   │ keyrx repl   │   │ keyrx run  │\n    │ --script     │   │              │   │ --record   │\n    └──────┬───────┘   └──────┬───────┘   └──────┬─────┘\n           │                  │                  │\n    ┌──────v──────────────────v──────────────────v──────┐\n    │      Test Harness API                             │\n    │  - simulate_tap(key)                              │\n    │  - simulate_hold(key, duration_ms)                │\n    │  - assert_output(key)                             │\n    │  - assert_mapping(from, to)                       │\n    └─────────────────────────────────────────────────────┘\n           │                  │\n    ┌──────v──────────┐  ┌────v─────────────┐\n    │ Engine           │  │ Event Recording  │\n    │ process_event()  │  │ write_session.krx│\n    └──────┬───────────┘  └────┬─────────────┘\n           │                   │\n    ┌──────v───────────────────v──────┐\n    │ Output Generation                │\n    │ (keyrx_inject_key, etc.)         │\n    └──────────────────────────────────┘\n```\n\n### Phase 2: Event Tracing Integration\n\n```\n┌────────────────────────────────────────────┐\n│ engine::process_event()                     │\n└────────────┬───────────────────────────────┘\n             │\n             v\n    ┌────────────────────────┐\n    │ OpenTelemetry Span     │\n    │ - event_id             │\n    │ - input_key            │\n    │ - timestamp            │\n    └────────────┬───────────┘\n                 │\n    ┌────────────v──────────────────┐\n    │ Decision Making                │\n    │ (tap-hold, combo, layer)       │\n    │ emit decision span             │\n    └────────────┬───────────────────┘\n                 │\n    ┌────────────v──────────────────┐\n    │ Output + Span Export           │\n    │ send to OpenTelemetry backend  │\n    └────────────────────────────────┘\n```\n\n### Phase 3: Flutter UI Architecture\n\n```\n┌────────────────────────────────────┐\n│ Flutter App Shell (main.dart)       │\n└────────────┬───────────────────────┘\n             │\n    ┌────────v──────────────┐\n    │ Page Router            │\n    ├───────────────────────┤\n    │ debugger_page.dart    │\n    │ training_screen.dart  │\n    │ trade_off_visual.dart │\n    │ editor_page.dart      │\n    │ console_page.dart     │\n    └────────┬──────────────┘\n             │\n    ┌────────v──────────────────────┐\n    │ FFI Bridge (bridge.dart)       │\n    │ - keyrx_on_state stream        │\n    │ - keyrx_eval_rhai              │\n    │ - keyrx_load_script            │\n    │ - keyrx_list_keys              │\n    └────────┬───────────────────────┘\n             │\n    ┌────────v──────────────────────┐\n    │ Rust FFI Layer (exports.rs)    │\n    │ - keyrx_on_state_callback      │\n    │ - keyrx_eval (eval_rhai)       │\n    │ - keyrx_load_script (FIXED)    │\n    └────────────────────────────────┘\n```\n\n## Components and Interfaces\n\n### 1. Script Test Harness (`core/src/scripting/test_harness.rs`)\n\n**Purpose:** Provide test functions (simulate_*, assert_*) to Rhai scripts; collect test results\n\n**Interfaces:**\n```rust\npub fn register_test_functions(runtime: &mut RhaiRuntime) -> Result<()>\npub fn run_test_function(runtime: &RhaiRuntime, fn_name: &str) -> TestResult\npub struct TestResult {\n    pub name: String,\n    pub passed: bool,\n    pub error: Option<String>,\n    pub duration_µs: u64,\n}\n```\n\n**Dependencies:** RhaiRuntime, Engine (for simulate operations)\n\n**Reuses:** Existing event injection, state getters\n\n### 2. REPL Command (`core/src/cli/commands/repl.rs`)\n\n**Purpose:** Interactive command-line interface for script evaluation and state inspection\n\n**Interfaces:**\n```rust\npub struct ReplCommand;\nimpl ReplCommand {\n    pub fn execute() -> Result<()>\n}\n\n// REPL supports:\n// > load_script(path)\n// > simulate(key_sequence)\n// > state()\n// > layers\n// > eval(\"rhai_code\")\n// > help\n// > exit\n```\n\n**Dependencies:** RhaiRuntime (shared), Engine, StandardInput\n\n**Reuses:** Existing script loading, event simulation\n\n### 3. Session Recording Middleware (`core/src/engine/event_recording.rs`)\n\n**Purpose:** Intercept events and outputs; serialize to .krx file\n\n**Interfaces:**\n```rust\npub struct EventRecorder {\n    file: File,\n    session_start: Instant,\n    event_count: u64,\n}\n\npub struct EventRecord {\n    pub seq: u64,\n    pub timestamp_µs: u64,\n    pub input: InputEvent,\n    pub output: Option<OutputAction>,\n    pub decision_type: String,  // \"pass\", \"remap\", \"tap\", \"hold\", \"combo\"\n    pub latency_µs: u64,\n}\n\nimpl EventRecorder {\n    pub fn record_event(&mut self, record: EventRecord) -> Result<()>\n    pub fn finish(&mut self, final_state: EngineSnapshot) -> Result<()>\n}\n```\n\n**Dependencies:** File I/O, Engine (state snapshots)\n\n**Reuses:** Existing event types, state serialization\n\n### 4. Session Replay (`core/src/cli/commands/replay.rs`)\n\n**Purpose:** Read .krx file and inject events deterministically\n\n**Interfaces:**\n```rust\npub struct ReplaySession {\n    events: Vec<EventRecord>,\n    timing_offset_µs: u64,\n}\n\nimpl InputSource for ReplaySession {\n    fn start(&mut self) -> Result<()>\n    fn poll(&mut self) -> Result<Option<InputEvent>>\n    fn stop(&mut self) -> Result<()>\n}\n\npub fn verify_replay(original: &str, replayed: &str) -> Result<ReplayDiff>\n```\n\n**Dependencies:** File I/O, InputSource trait\n\n**Reuses:** Existing input injection mechanisms\n\n### 5. Timing Diagram Generator (`core/src/cli/commands/analyze.rs`)\n\n**Purpose:** Parse .krx file and generate ASCII timing diagrams\n\n**Interfaces:**\n```rust\npub struct TimingAnalyzer;\nimpl TimingAnalyzer {\n    pub fn generate_diagram(session_path: &str) -> Result<String>\n}\n\n// Output format:\n// Event │ Input │ Decision │ Output │ Latency (µs)\n// ──────┼───────┼──────────┼────────┼──────────────\n// 1     │ KeyA  │ Remap    │ KeyB   │ 142\n// 2     │ KeyC  │ Hold...  │ (wait) │ 2500 (pending)\n// 3     │ KeyC↑ │ Hold→Tap │ KeyC   │ 2501\n```\n\n**Dependencies:** File I/O, EventRecord structures\n\n**Reuses:** Existing serialization\n\n### 6. FFI Script Loading Complete (`core/src/ffi/exports.rs`)\n\n**Purpose:** Load script file into active runtime via FFI\n\n**Interfaces:**\n```rust\n#[no_mangle]\npub unsafe extern \"C\" fn keyrx_load_script(path: *const c_char) -> i32\n// Returns: 0 (success), -1 (invalid path), -2 (invalid UTF8), -3 (syntax error)\n// Side effect: script loaded into runtime, hooks registered\n```\n\n**Dependencies:** RhaiRuntime (shared), CStr marshaling\n\n**Reuses:** Existing script loading logic from keyrx check command\n\n### 7. OpenTelemetry Tracing (`core/src/engine/tracing.rs`)\n\n**Purpose:** Emit spans for input→decision→output flow\n\n**Interfaces:**\n```rust\npub struct EngineTracer {\n    tracer: opentelemetry::trace::Tracer,\n}\n\nimpl EngineTracer {\n    pub fn span_input_received(&self, event: &InputEvent) -> Span\n    pub fn span_decision_made(&self, decision: &str, latency_µs: u64) -> Span\n    pub fn span_output_generated(&self, action: &OutputAction) -> Span\n}\n```\n\n**Dependencies:** opentelemetry crate, optional at runtime\n\n**Reuses:** None (new feature)\n\n### 8. Flutter State Subscription (`ui/lib/ffi/state_stream.dart`)\n\n**Purpose:** Receive state snapshots via FFI callback; emit Dart Stream\n\n**Interfaces:**\n```dart\nclass EngineStateStream {\n  Stream<EngineSnapshot> get snapshot stream\n  void _onStateCallback(String jsonPayload) // invoked from FFI\n}\n\nclass EngineSnapshot {\n  List<String> activeLayers\n  List<String> heldKeys\n  Map<String, bool> modifiers\n  Map<String, dynamic> pending\n  int latencyMicroseconds\n  Map<String, dynamic> timing\n}\n```\n\n**Dependencies:** bridge.dart, FFI bindings\n\n**Reuses:** Existing keyrx_on_state callback\n\n### 9. Debugger Page Enhancement (`ui/lib/pages/debugger.dart`)\n\n**Purpose:** Display real-time engine state with live updates\n\n**Separation Plan:** Split into:\n- `debugger_page.dart` (440 lines) - State management, layout\n- `debugger_widgets.dart` (300 lines) - Component widgets (timeline, layer panel, modifier display)\n\n**Key Widgets:**\n- `DebuggerTimelineWidget` - Animated timeline of recent events\n- `LayerPanelWidget` - Active layer stack display\n- `ModifierDisplayWidget` - Current modifier state\n- `LatencyMeterWidget` - Real-time latency visualization\n\n**Dependencies:** state_stream, bridge\n\n**Reuses:** Existing timeline components\n\n### 10. Training Screen (`ui/lib/pages/training_screen.dart`)\n\n**Purpose:** Interactive guided lessons for KeyRx configuration\n\n**Lesson Structure:**\n```dart\nclass TrainingLesson {\n  String title\n  String description\n  String objective\n  List<TrainingStep> steps\n}\n\nclass TrainingStep {\n  String instruction\n  Function validator  // returns bool\n  String hint\n  String feedbackSuccess\n  String feedbackFailure\n}\n```\n\n**Dependencies:** engine service, key registry, state stream\n\n**Reuses:** Existing key validation logic\n\n### 11. Trade-off Visualizer (`ui/lib/pages/trade_off_visualizer.dart`)\n\n**Purpose:** Interactive chart showing timing threshold vs. miss rate trade-offs\n\n**Chart Data:**\n```dart\nclass TradeOffPoint {\n  double tapHoldTimeoutMs\n  double missRatePercent\n  String label  // \"Gaming\", \"Typing\", etc.\n}\n\nclass UserTypingProfile {\n  double avgInterKeyDelayMs\n  double stdDevMs\n  int samplesCollected\n}\n```\n\n**Dependencies:** charts_flutter package, bridge\n\n**Reuses:** None (new)\n\n## Data Models\n\n### EventRecord (Rust)\n```rust\n#[derive(Serialize, Deserialize)]\npub struct EventRecord {\n    pub seq: u64,\n    pub timestamp_µs: u64,\n    pub input: InputEvent,\n    pub output: Option<OutputAction>,\n    pub decision_type: String,\n    pub active_layers: Vec<String>,\n    pub modifiers_state: serde_json::Value,\n    pub latency_µs: u64,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct SessionFile {\n    pub version: String,\n    pub created_at: SystemTime,\n    pub script_used: String,\n    pub timing_config: TimingConfiguration,\n    pub initial_state: EngineSnapshot,\n    pub events: Vec<EventRecord>,\n}\n```\n\n### EngineSnapshot (Dart/Rust)\n```rust\n#[derive(Serialize, Deserialize, Clone)]\npub struct EngineSnapshot {\n    pub active_layers: Vec<String>,\n    pub held_keys: Vec<String>,\n    pub modifiers: Map<String, bool>,\n    pub pending_decisions: Vec<PendingDecision>,\n    pub event_summary: String,\n    pub latency_µs: u64,\n    pub timing: TimingConfiguration,\n}\n```\n\n### TestResult\n```rust\npub struct TestResult {\n    pub name: String,\n    pub passed: bool,\n    pub message: String,\n    pub duration_µs: u64,\n    pub line_number: Option<usize>,\n}\n```\n\n## Error Handling\n\n### Phase 1 Error Scenarios\n\n1. **Script Syntax Error in Test**\n   - **Handling:** Catch RhaiError, extract location (file:line:col)\n   - **User Impact:** `keyrx test` exits code 1, prints error with context\n   - **Example:** `config.rhai:45: Unknown variable 'simulate_hold'`\n\n2. **Test Function Not Found**\n   - **Handling:** Check runtime registry before executing\n   - **User Impact:** `keyrx test` exits code 1, suggests available test functions\n   - **Example:** `No test function named 'test_remap_a_to_b' found`\n\n3. **REPL Runtime Not Initialized**\n   - **Handling:** Lazy-initialize on first REPL command\n   - **User Impact:** User sees `keyrx> ` prompt; first command initializes runtime\n   - **Example:** `(Loading runtime...)`\n\n4. **Session File Corrupted**\n   - **Handling:** Validate JSON schema before replay\n   - **User Impact:** `keyrx replay` exits code 1, reports corruption location\n   - **Example:** `session.krx: Invalid event at record 42 (missing 'timestamp_µs')`\n\n### Phase 2 Error Scenarios\n\n5. **OpenTelemetry Backend Unavailable**\n   - **Handling:** Skip span emission; continue running\n   - **User Impact:** No visible failure; tracing simply unavailable\n   - **Example:** (silent; tracing is optional)\n\n### Phase 3 Error Scenarios\n\n6. **State Snapshot Stream Disconnected**\n   - **Handling:** Debugger detects empty stream; show error banner\n   - **User Impact:** Debugger shows \"Disconnected. Reconnect?\" button\n   - **Example:** Reconnect trigger: user presses button or refreshes page\n\n7. **Key Registry Fetch Failed**\n   - **Handling:** Training/editor use fallback set; warn user\n   - **User Impact:** Editor shows \"Some keys unavailable\" warning\n   - **Example:** Still allows mapping but without validation\n\n## Testing Strategy\n\n### Unit Testing\n\n**Phase 1:**\n- Test harness: `#[test] fn test_simulate_tap_generates_event()` → verify event injection\n- REPL: `#[test] fn repl_parse_command_load_script()` → verify command parsing\n- Recording: `#[test] fn event_record_serializes_to_json()` → verify serialization\n- Replay: `#[test] fn replay_injects_events_in_order()` → verify event sequence\n- Test discovery: `#[test] fn discover_test_functions_from_script()` → verify #[test] parsing\n\n**Coverage Target:** 85%\n\n### Integration Testing\n\n**Phase 1:**\n- End-to-end test: `keyrx test tests/example_test.rhai` → full test cycle\n- Recording + Replay: Record 100 events, replay, verify outputs match\n- REPL + Script Load: Load script in REPL, verify mappings active\n\n**Phase 2:**\n- Tracing + Engine: Generate 1000 events, verify spans emitted\n- OpenTelemetry export: Verify spans exported to mock backend\n\n**Phase 3:**\n- Flutter + State Stream: Debugger connected, verify state updates within 50ms\n- Training completion: Complete all lessons, verify state transitions\n\n**Coverage Target:** 80%\n\n### End-to-End Testing\n\n**User Scenarios:**\n1. Developer writes test in script, runs `keyrx test`, sees results\n2. User records session with `keyrx run --record`, replays with `keyrx replay`\n3. User opens Flutter debugger, sees live state updating as they press keys\n4. User completes training lessons, applies knowledge to editor\n5. User adjusts timing thresholds, sees trade-off visualization update\n\n**Coverage Target:** 75%\n\n## Implementation Sequence\n\n**Phase 1 (Weeks 1-2):**\n1. Refactor scripting/runtime.rs → split into 4 modules (500 line limit)\n2. Implement test harness (register_test_functions, test discovery)\n3. Implement keyrx test command\n4. Implement keyrx repl command\n5. Implement event recording middleware\n6. Implement keyrx replay command\n7. Implement keyrx analyze command\n8. Fix keyrx_load_script FFI function\n9. Unit + integration tests (85% coverage)\n\n**Phase 2 (Week 3):**\n1. Add OpenTelemetry dependency\n2. Implement EngineTracer\n3. Integrate tracing into engine::process_event\n4. Implement trace export\n5. Tests (80% coverage)\n\n**Phase 3 (Weeks 4-5):**\n1. Refactor editor.dart → split into 2 files (500 line limit)\n2. Enhance debugger page with state stream subscription\n3. Implement training_screen.dart with lesson framework\n4. Implement trade_off_visualizer.dart with chart\n5. Add console error styling\n6. Flutter tests (75% coverage)\n\n",
  "fileStats": {
    "size": 21085,
    "lines": 581,
    "lastModified": "2025-12-02T13:35:11.209Z"
  },
  "comments": []
}