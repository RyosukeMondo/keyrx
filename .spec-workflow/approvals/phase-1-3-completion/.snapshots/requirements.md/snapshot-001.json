{
  "id": "snapshot_1764682274453_uzeeihedv",
  "approvalId": "approval_1764682274438_8w9g2smer",
  "approvalTitle": "Phase 1-3 Completion Requirements",
  "version": 1,
  "timestamp": "2025-12-02T13:31:14.453Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Phase 1-3 Completion: Core Features & GUI Requirements\n\n## Introduction\n\nThis specification addresses the critical gaps between KeyRx's documented architecture (product.md, tech.md) and current implementation. It covers three implementation phases to complete the Rust backend (Phase 1), driver integration (Phase 2), and Flutter UI (Phase 3). The focus is on developer tooling, observability, and user-facing visualization of the key remapping engine's state and capabilities.\n\n## Alignment with Product Vision\n\nThis spec directly enables the product vision outlined in `product.md`:\n- **Phase 1**: Completes \"Iron Core - Headless\" with script testing and REPL for developer iteration\n- **Phase 2**: Implements \"Nervous System - Drivers\" observability through event tracing\n- **Phase 3**: Delivers \"Flutter GUI\" features for real-time debugging and configuration trade-offs\n\nThese features are critical for the \"Developer-Friendly Remapping\" differentiation stated in product.md §10-40.\n\n## Requirements\n\n### Phase 1: Iron Core Completion\n\n#### Requirement 1.1: Script Testing Framework\n\n**User Story:** As a Rhai script developer, I want to write deterministic tests for my key remapping scripts, so that I can validate behavior without manual testing.\n\n**Description:** Implement a test framework that allows users to write tests in Rhai scripts using a simple test harness with assertions.\n\n#### Acceptance Criteria\n\n1. WHEN a user creates a `.rhai` file with `#[test]` functions, THEN `keyrx test --script <file>` SHALL execute all test functions\n2. WHEN a test function calls `simulate_tap(\"KeyA\")`, THEN the system SHALL inject a keydown+keyup event pair with current timestamp\n3. WHEN a test function calls `assert_output(\"KeyB\")`, THEN the assertion SHALL pass if the last output event is KeyB, else fail with clear message\n4. WHEN a test calls `assert_mapping(\"A\", \"B\")`, THEN it SHALL verify the configured mapping by checking the registry\n5. WHEN a test suite has 5 passing tests and 2 failing, THEN `keyrx test` SHALL exit with code=2 and report both counts\n6. WHEN a test calls `assert_duration(100..200)`, THEN it SHALL verify the last action completed within ±100-200µs (assuming deterministic timing)\n7. IF a user's script has a syntax error in a test function, THEN `keyrx test` SHALL report the error location with line number\n\n**Test File Example:**\n```rhai\n#[test]\nfn capslock_tap_produces_escape() {\n    // Load or configure mapping here if needed\n    simulate_tap(\"CapsLock\");\n    assert_output(\"Escape\");\n}\n\n#[test]\nfn ctrl_a_selects_all() {\n    simulate_key_with_mods(\"KeyA\", [\"Control\"]);\n    assert_output(\"SelectAll\");\n}\n```\n\n#### Requirement 1.2: REPL Console (Interactive Script Evaluation)\n\n**User Story:** As a developer, I want an interactive REPL where I can execute Rhai scripts and inspect engine state in real-time, so that I can iterate quickly during development.\n\n**Description:** Implement a command-line REPL that allows users to load the active runtime and execute Rhai code interactively, with support for inspecting state.\n\n#### Acceptance Criteria\n\n1. WHEN a user runs `keyrx repl`, THEN a prompt `keyrx> ` SHALL appear and accept Rhai input\n2. WHEN a user types `load_script(\"path/to/script.rhai\")`, THEN the script SHALL be loaded into the runtime and any hooks/remaps registered\n3. WHEN a user types `simulate(\"a\")` in REPL, THEN the input SHALL be processed by the engine and output shown\n4. WHEN a user types `state()`, THEN the REPL SHALL display current layers, modifiers, held keys as JSON\n5. WHEN a user types `eval \"remap('a', 'b')\"`, THEN the Rhai code SHALL execute in the current runtime context\n6. WHEN a user types `layers`, THEN the REPL SHALL list active layer stack with names and priorities\n7. WHEN a user types `help`, THEN REPL SHALL show available REPL commands\n8. WHEN a user types `exit`, THEN REPL SHALL cleanly shut down and return to shell\n9. IF a user inputs invalid Rhai syntax, THEN REPL SHALL show error with line/column and keep prompt open\n\n#### Requirement 1.3: Session Recording & Replay Infrastructure\n\n**User Story:** As a developer debugging a key remapping issue, I want to record a session of key events, then replay them deterministically to reproduce the issue, so that I can verify fixes without manual retesting.\n\n**Description:** Implement event recording to `.krx` files and a replay mechanism to deterministically re-execute sequences with full state snapshots.\n\n#### Acceptance Criteria\n\n1. WHEN `keyrx run --record session.krx` is executed, THEN all input events SHALL be serialized to `.krx` file with timestamps and input data\n2. WHEN the session completes, THEN the `.krx` file SHALL contain: event sequence, initial engine state, timing configuration, script used\n3. WHEN `keyrx replay session.krx` is executed, THEN events SHALL be injected in order with accurate inter-event timing\n4. WHEN a replay completes, THEN outputs SHALL match the original recorded outputs byte-for-byte (deterministic)\n5. WHEN a user modifies a script and replays an old session, THEN the modified behavior SHALL be visible in the new outputs\n6. WHEN `keyrx analyze session.krx --diagram`, THEN ASCII timing diagram SHALL show input→decision→output latency for each event\n7. WHEN a `.krx` file is corrupted, THEN `keyrx replay` SHALL report the corruption and refuse to load\n8. IF a user records a session with 1000+ events, THEN `.krx` file size SHALL not exceed 500KB (compressed or optimized format)\n\n#### Requirement 1.4: FFI Script Loading Fix\n\n**User Story:** As a Flutter UI user, I want to load custom Rhai scripts through the UI without reimplementation, so that the engine-UI integration works end-to-end.\n\n**Description:** Complete the incomplete `keyrx_load_script` FFI function to actually load and execute scripts from file paths.\n\n#### Acceptance Criteria\n\n1. WHEN Flutter calls `keyrx_load_script(\"path/to/config.rhai\")`, THEN the script SHALL be loaded into the active runtime\n2. WHEN the script loads successfully, THEN the function SHALL return 0 (success) and any hooks/remaps are registered\n3. WHEN the script path is invalid, THEN the function SHALL return -1 with error logged\n4. WHEN the script has syntax errors, THEN the function SHALL return -3 and log the error location\n5. WHEN the script loads after engine initialization, THEN previously registered mappings SHALL still be active\n\n### Phase 2: Nervous System - Driver Integration\n\n#### Requirement 2.1: Event Tracing & Observability\n\n**User Story:** As a user experiencing issues with key remapping on complex setups, I want the engine to emit structured observability data (traces, spans) that integration developers can analyze, so that debugging difficult driver interactions is possible.\n\n**Description:** Integrate OpenTelemetry-compatible event tracing to emit detailed spans for input processing, decision-making, and output generation.\n\n#### Acceptance Criteria\n\n1. WHEN an input event is processed, THEN a trace span SHALL record: event type, timestamp, duration from ingress to output\n2. WHEN a tap-hold decision completes, THEN a span SHALL be emitted with: input key, timeout decision, output action, total latency_µs\n3. WHEN combo matching occurs, THEN a span SHALL record: combo name, matched keys, decision timestamp, whether combo fired\n4. WHEN a decision is made, THEN the span SHALL include: active layers, modifiers state, script execution time (if applicable)\n5. WHEN `keyrx run --trace <trace-file>` is used, THEN all spans SHALL be exported to trace-file in OpenTelemetry format\n6. IF OpenTelemetry is unavailable, THEN the engine SHALL continue operating normally (observability is optional)\n7. WHEN a user examines a trace in compatible tool (Jaeger, etc.), THEN they SHALL see full causal chain: input→decision→output\n\n### Phase 3: Flutter GUI Completion\n\n#### Requirement 3.1: Enhanced Debugger with Real-Time State\n\n**User Story:** As a user testing my key remapping configuration, I want to see the engine's real-time state (layers, modifiers, timing) updating as I press keys, so that I can understand what the engine is doing.\n\n**Description:** Integrate the state snapshot stream (from live-ui-ffi-hardening spec) into the debugger page to display live engine state with thresholds and latency visualization.\n\n#### Acceptance Criteria\n\n1. WHEN the debugger page opens, THEN it SHALL fetch initial state snapshot via FFI and display: active layers, held keys, modifiers\n2. WHEN a key is pressed, THEN the debugger SHALL update within 50ms to show: key in \"held\" state, any triggered layers/modifiers\n3. WHEN a key is released, THEN the debugger SHALL show: output event generated, timing latency_µs, decision type (pass/remap/tap/hold/combo)\n4. WHEN a tap-hold is pending, THEN the debugger SHALL display countdown timer and highlight affected keys\n5. WHEN tap-hold timeout occurs, THEN the debugger SHALL show transition: \"pending\" → \"hold\" with timestamp\n6. WHEN a combo is matched, THEN the debugger SHALL highlight all combo keys and show matched combo name\n7. WHEN the state updates, THEN animation SHALL fade in new values (no jarring jumps)\n8. IF state snapshot stream disconnects, THEN debugger SHALL show error and offer \"Reconnect\" button\n\n#### Requirement 3.2: Training Screen Implementation\n\n**User Story:** As a user new to KeyRx, I want a guided tutorial/training mode that teaches me how to configure key remappings, so that I can learn the system interactively.\n\n**Description:** Create an interactive training screen with guided exercises and immediate feedback for learning KeyRx configuration.\n\n#### Acceptance Criteria\n\n1. WHEN training screen opens, THEN it SHALL present step-by-step lessons on: remapping, layers, modifiers, tap-hold, combos\n2. WHEN a user completes a \"remap A→B\" exercise, THEN they SHALL be prompted to press 'A' and see 'B' output\n3. WHEN the user presses 'A' and 'B' is correctly output, THEN the exercise SHALL mark as complete with checkmark\n4. IF the user presses 'A' and gets wrong output, THEN feedback SHALL explain why (e.g., \"Layer not active\")\n5. WHEN all lessons are complete, THEN training screen SHALL offer \"Start with blank canvas\" to apply knowledge\n6. WHEN a user clicks \"Show console output during exercise\", THEN the console panel SHALL appear inline showing eval results\n7. IF a user is stuck, THEN a \"Hint\" button SHALL provide guidance without spoiling the answer\n8. WHEN training completes, THEN a \"Certificate\" modal SHALL appear (visual achievement, can be dismissed)\n\n#### Requirement 3.3: Configuration Trade-off Visualizer\n\n**User Story:** As a user configuring timing-sensitive features (tap-hold thresholds), I want to see how my timing choices affect latency and reliability, so that I can make informed trade-offs.\n\n**Description:** Create a visualization showing the relationship between timing configuration choices (thresholds, timeouts) and resulting latency/responsiveness characteristics.\n\n#### Acceptance Criteria\n\n1. WHEN user opens \"Settings → Timing & Trade-offs\" page, THEN an interactive chart SHALL show: X-axis (tap timeout ms), Y-axis (miss rate %)\n2. WHEN user adjusts tap_hold_timeout slider, THEN the chart SHALL update to show predicted miss rate range\n3. WHEN user hovers over a point on the curve, THEN a tooltip SHALL show: \"500ms timeout → 8% miss rate on fast typists, 2% on average\"\n4. WHEN a user loads a timing preset (e.g., \"Gaming\", \"Typing\"), THEN the chart SHALL highlight the recommended region\n5. WHEN timing_duration threshold is < 100µs, THEN UI SHALL warn: \"Very tight timing - may not work on all hardware\"\n6. WHEN user clicks \"Simulate my typing speed\", THEN a test sequence SHALL run and measure their actual typing patterns\n7. WHEN simulation completes, THEN the chart SHALL overlay: user's typing speed distribution and recommended thresholds\n8. WHEN user exports config, THEN a comment SHALL be added: \"Optimized for X typing speed, see trade-offs at line Y\"\n\n#### Requirement 3.4: Console Error Styling Enhancement\n\n**User Story:** As a user, I want the console to visually distinguish between successful commands and errors, so that I can quickly identify issues.\n\n**Description:** Update console page to style responses based on ok:/error: prefix from eval results.\n\n#### Acceptance Criteria\n\n1. WHEN a console command returns `ok:<value>`, THEN the response SHALL appear in green/success styling\n2. WHEN a console command returns `error:<message>`, THEN the response SHALL appear in red/error styling with icon\n3. WHEN an error is `error:Engine not initialized`, THEN console SHALL offer \"Initialize Engine\" quick action\n4. WHEN error contains file path, THEN the path SHALL be a link to open in editor (if applicable)\n5. WHEN user types `remap('a', 'b')` and it succeeds, THEN console SHALL show: `✓ Remapping created: a → b`\n6. WHEN user selects an error message, THEN pressing Ctrl+C SHALL copy just the message without prefix\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **CLAUDE.md Compliance**:\n  - All files shall remain ≤ 500 lines (excluding comments/blank lines)\n  - All functions shall remain ≤ 50 lines\n  - Panic macros in test code shall use proper assertions (assert!, assert_eq!, expect)\n  - `core/src/scripting/runtime.rs` (currently 1654 lines) must be refactored into smaller modules\n  - `ui/lib/pages/editor.dart` (currently 844 lines) must be refactored into editor_widgets.dart + editor_page.dart\n\n- **Single Responsibility**: Script testing, REPL, and replay shall be separate CLI commands with reusable internal APIs\n- **Dependency Injection**: All external dependencies (FFI, file I/O, tracing) shall be injectable for testing\n- **Error Handling**: Structured JSON logging with timestamp, level, service, event, context per CLAUDE.md\n\n### Performance\n\n- **REPL Responsiveness**: REPL commands shall execute within 100ms (excluding I/O)\n- **State Snapshot Latency**: State updates shall reach debugger within 50ms\n- **Session Recording Overhead**: Recording shall add <5% CPU overhead\n- **Trace Export**: Exporting 10K events to OpenTelemetry format shall complete in <2 seconds\n\n### Reliability\n\n- **Deterministic Replay**: Replayed sessions shall produce byte-identical outputs to original recording\n- **Error Recovery**: Session loading errors shall not crash the engine; graceful degradation required\n- **Script Syntax Error Handling**: All syntax errors shall be reported with file:line:column location\n- **FFI Safety**: All FFI functions shall prevent panics across boundary; return error codes instead\n\n### Test Coverage\n\n- **Phase 1**: Script testing framework and REPL code shall have ≥85% coverage\n- **Phase 2**: Event tracing shall have ≥80% coverage (non-critical path)\n- **Phase 3**: Flutter UI pages shall have ≥75% widget/integration test coverage\n- **Integration**: End-to-end tests for session record→replay cycle\n\n### Usability\n\n- **Error Messages**: All errors shall explain the problem and suggest corrective action\n- **REPL Help**: Built-in `help` command shall list all REPL functions with examples\n- **Training**: Guided training shall take <15 minutes to complete all lessons\n- **Visualization**: Charts/diagrams shall be readable at 1024x768 resolution and mobile-friendly\n\n### Security\n\n- **Session File Validation**: `.krx` files shall be validated before replay (prevent injection)\n- **REPL Isolation**: REPL shall not expose internal Rust APIs or private engine state unintentionally\n- **FFI Boundary**: All FFI string pointers shall be bounds-checked; prevent buffer overflows\n\n",
  "fileStats": {
    "size": 15608,
    "lines": 236,
    "lastModified": "2025-12-02T13:31:09.616Z"
  },
  "comments": []
}