{
  "id": "snapshot_1765468833194_csjmw48br",
  "approvalId": "approval_1765468653599_yx4j5hi9y",
  "approvalTitle": "Split Large Files - Requirements Document",
  "version": 2,
  "timestamp": "2025-12-11T16:00:33.194Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe KeyRx codebase has **56 files exceeding the 500-line limit** mandated by user guidelines (max 500 lines/file excluding comments/blank lines). This spec addresses the #2 priority improvement: systematically splitting large files into smaller, focused modules to improve maintainability, compilation speed, and code organization.\n\n**Problem Statement:**\n- 56 files violate 500-line limit (worst: 1,893 lines)\n- Large files slow incremental compilation\n- Difficult to review and understand (cognitive overload)\n- Higher merge conflict probability\n- Violates Single Responsibility Principle\n- Top 10 files contain 10,000+ lines that should be ~4,000 lines\n\n**Value Proposition:**\n- **20-30% faster incremental builds** (only changed modules recompile)\n- **Easier code review** (smaller, focused diffs)\n- **Better code organization** (clear domain boundaries)\n- **Reduced merge conflicts** (changes isolated to smaller files)\n- **Improved maintainability** (easier to find and understand code)\n- **Compliance with code quality standards** (max 500 lines/file)\n\n## Alignment with Product Vision\n\nThis feature supports the core development principles outlined in `~/.claude/CLAUDE.md`:\n\n- **Code Metrics (KPI)**: Enforces max 500 lines/file guideline\n- **Architecture**: SOLID principles - Single Responsibility Principle per file\n- **Code Quality**: Modular design with clear boundaries\n- **Maintainability**: Smaller files are easier to understand and modify\n\n## Requirements\n\n### Requirement 1: File Size Audit and Prioritization\n\n**User Story:** As a developer, I want a comprehensive audit of all oversized files, so that I can prioritize which files to split first based on impact.\n\n#### Acceptance Criteria\n\n1. WHEN file size audit is run THEN it SHALL identify all Rust source files exceeding 500 lines\n2. WHEN files are identified THEN they SHALL be ranked by size (largest first)\n3. WHEN ranking is complete THEN top 10 files SHALL be prioritized for immediate action\n4. IF a file is identified for splitting THEN its logical structure SHALL be analyzed to find split points\n5. WHEN analysis is complete THEN a splitting plan SHALL be documented for each file\n\n**Success Metrics:**\n- Complete list of 56+ files exceeding 500-line limit\n- Files ranked by size with line counts\n- Top 10 files identified for immediate action (1,893 → 505 lines)\n- Logical split points identified for each priority file\n- Splitting plans documented with proposed module structure\n\n### Requirement 2: Split Large Files into Logical Modules\n\n**User Story:** As a developer, I want oversized files split into focused modules along natural boundaries, so that each module has a single, clear responsibility.\n\n#### Acceptance Criteria\n\n1. WHEN a file is split THEN each resulting module SHALL be under 500 lines (ideally under 400 lines)\n2. WHEN a file is split THEN split SHALL follow logical domain boundaries (not arbitrary line counts)\n3. WHEN modules are created THEN each SHALL have a single, well-defined purpose\n4. IF related functionality exists THEN it SHALL be grouped together in the same module\n5. WHEN split is complete THEN public API SHALL remain identical (re-exported from parent module)\n6. IF types are shared THEN they SHALL be moved to appropriate shared module or parent\n\n**Logical Splitting Strategies:**\n- **By domain:** Group related functions (e.g., keyboard bindings, layer management, modifiers)\n- **By type:** Separate data types, implementations, and utilities\n- **By responsibility:** Each module handles one aspect of functionality\n- **By abstraction level:** Separate high-level and low-level concerns\n\n**Success Metrics:**\n- All files under 500-line limit after splitting\n- Each module has clear, single responsibility\n- Public APIs unchanged (consumers unaffected)\n- Logical grouping improves code discoverability\n- Module names clearly describe their purpose\n\n### Requirement 3: Maintain API Compatibility\n\n**User Story:** As a code consumer, I want the public API to remain unchanged after file splitting, so that my code continues working without modifications.\n\n#### Acceptance Criteria\n\n1. WHEN a file is split THEN all public items SHALL be re-exported from the parent module\n2. WHEN imports are used THEN existing `use` statements SHALL continue working unchanged\n3. IF a public function is moved THEN it SHALL be re-exported with identical signature\n4. WHEN a public type is moved THEN it SHALL be re-exported with identical definition\n5. IF visibility is changed THEN it SHALL only be for internal reorganization, not public API\n\n**Re-export Pattern:**\n```rust\n// Before split: core/src/example.rs\npub fn function_a() { }\npub fn function_b() { }\n\n// After split:\n// core/src/example/mod.rs\npub mod submodule_a;\npub mod submodule_b;\npub use submodule_a::function_a;\npub use submodule_b::function_b;\n\n// Users still write: use keyrx_core::example::function_a;\n```\n\n**Success Metrics:**\n- Zero breaking changes to public API\n- All existing imports continue working\n- Cargo build succeeds without changes to consuming code\n- Tests pass without modification\n- Documentation links remain valid\n\n### Requirement 4: Update Internal Imports\n\n**User Story:** As a developer maintaining the codebase, I want internal imports updated to reflect new module structure, so that the code is clean and uses the new organization correctly.\n\n#### Acceptance Criteria\n\n1. WHEN a file is split THEN internal imports SHALL be updated to use new module paths\n2. WHEN a module imports from sibling THEN it SHALL use relative or absolute path as appropriate\n3. IF circular dependencies exist THEN they SHALL be resolved through proper module organization\n4. WHEN imports are updated THEN unused imports SHALL be removed\n5. IF a module uses many items from another THEN glob imports MAY be used judiciously\n\n**Import Organization:**\n```rust\n// Good: Clear, organized imports\nuse crate::config::models::{DeviceInstanceId, HardwareProfile, Keymap};\nuse super::types::StateSnapshot;\nuse super::layers::LayerState;\n\n// Avoid: Glob imports unless truly many items needed\nuse super::keyboard::*; // Only if >10 items used\n```\n\n**Success Metrics:**\n- All imports reference correct module paths\n- No unused imports remain (clippy clean)\n- No circular dependency errors\n- Import groups are logical (std, external crates, internal)\n- Code compiles without warnings\n\n### Requirement 5: Document Module Organization\n\n**User Story:** As a new contributor, I want module structure documented, so that I can understand the organization and find code quickly.\n\n#### Acceptance Criteria\n\n1. WHEN a file is split THEN the parent module SHALL have doc comments explaining structure\n2. WHEN a submodule is created THEN it SHALL have doc comments explaining its purpose\n3. IF module structure is complex THEN a diagram or explanation SHALL be provided\n4. WHEN documentation is written THEN it SHALL explain what each module contains\n5. IF modules have dependencies THEN relationships SHALL be documented\n\n**Module Documentation Pattern:**\n```rust\n//! Scripting engine bindings.\n//!\n//! This module provides Rhai script bindings for KeyRx functionality.\n//! Split into focused submodules:\n//!\n//! - [`keyboard`] - Keyboard event and key code bindings\n//! - [`layers`] - Layer management and state bindings\n//! - [`modifiers`] - Modifier key state bindings\n//! - [`utilities`] - Utility functions for scripting\n```\n\n**Success Metrics:**\n- All parent modules have doc comments explaining structure\n- All submodules have doc comments explaining purpose\n- Module relationships are clear\n- New contributors can navigate code easily\n- Documentation is up-to-date after splits\n\n### Requirement 6: Test All Splits\n\n**User Story:** As a quality assurance engineer, I want comprehensive testing after file splits, so that I can verify functionality remains correct.\n\n#### Acceptance Criteria\n\n1. WHEN a file is split THEN all existing tests SHALL pass without modification\n2. WHEN tests are run THEN compilation SHALL succeed with zero errors\n3. IF tests fail THEN root cause SHALL be identified and fixed before proceeding\n4. WHEN clippy is run THEN it SHALL pass with zero warnings\n5. WHEN formatter is run THEN code SHALL be properly formatted\n6. IF benchmarks exist THEN performance SHALL be verified as unchanged\n\n**Testing Checklist Per Split:**\n- [ ] `cargo build` succeeds\n- [ ] `cargo test` passes (all tests)\n- [ ] `cargo clippy` passes (no warnings)\n- [ ] `cargo fmt --check` passes\n- [ ] No new compiler warnings\n- [ ] Documentation builds (`cargo doc`)\n\n**Success Metrics:**\n- All tests pass after each split\n- Zero compilation errors or warnings\n- No performance regressions\n- Clippy clean\n- Formatting correct\n- Documentation builds successfully\n\n### Requirement 7: Incremental Implementation\n\n**User Story:** As a project maintainer, I want file splitting done incrementally, so that the codebase remains stable and changes are reviewable.\n\n#### Acceptance Criteria\n\n1. WHEN splitting begins THEN top 10 largest files SHALL be split first\n2. WHEN a file is split THEN changes SHALL be committed separately per file\n3. IF issues arise THEN previous splits SHALL not block progress on other files\n4. WHEN a split is complete THEN it SHALL be verified before moving to next file\n5. IF conflicts occur THEN split SHALL be rebased/merged before proceeding\n\n**Split Order (by priority/size):**\n1. `scripting/bindings.rs` (1,893 lines) → 4 modules\n2. `engine/state/mod.rs` (1,570 lines) → 3 modules\n3. `engine/transitions/log.rs` (1,403 lines) → 3 modules\n4. `bin/keyrx.rs` (1,382 lines) → 3 modules\n5. `scripting/docs/generators/html.rs` (1,069 lines) → 2 modules\n6. `validation/engine.rs` (968 lines) → 2 modules\n7. `config/loader.rs` (949 lines) → 2 modules\n8. `registry/profile.rs` (918 lines) → 2 modules\n9. `engine/advanced.rs` (906 lines) → 2 modules\n10. `cli/commands/run.rs` (899 lines) → 2 modules\n\n**Success Metrics:**\n- Top 10 files split and verified\n- Each split committed separately\n- No blocking issues between splits\n- All intermediate states are stable\n- Changes are reviewable in isolation\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: Each module file has one well-defined purpose\n- **Module Cohesion**: Related functionality grouped together\n- **Module Coupling**: Minimal dependencies between modules\n- **Clear Boundaries**: Domain boundaries aligned with module boundaries\n- **Logical Organization**: File structure mirrors conceptual structure\n\n**Target Module Organization:**\n```\nexample/\n├── mod.rs           (100-200 lines) - Public API + re-exports\n├── domain_a.rs      (200-400 lines) - Domain A functionality\n├── domain_b.rs      (200-400 lines) - Domain B functionality\n└── utilities.rs     (100-300 lines) - Shared utilities\n```\n\n### Performance\n\n- **Compilation Speed**: Incremental builds 20-30% faster\n- **Incremental Recompilation**: Only changed modules recompile\n- **Binary Size**: No increase in final binary size\n- **Runtime Performance**: Zero impact on runtime performance\n- **Module Loading**: No additional overhead\n\n**Benchmark Targets:**\n```\nBefore: Touch large file → 5-10s recompile (entire file)\nAfter:  Touch submodule → 3-5s recompile (only that module)\nImprovement: ~30-50% faster incremental builds\n```\n\n### Maintainability\n\n- **Discoverability**: Easy to find relevant code\n- **Readability**: Smaller files easier to read and understand\n- **Review**: Smaller diffs easier to review\n- **Conflicts**: Reduced probability of merge conflicts\n- **Navigation**: IDE navigation faster with smaller files\n- **Cognitive Load**: Reduced complexity per file\n\n### Compatibility\n\n- **API Stability**: Zero breaking changes\n- **Import Compatibility**: Existing imports continue working\n- **Test Compatibility**: Tests pass without modification\n- **Documentation Compatibility**: Doc links remain valid\n- **Binary Compatibility**: FFI and ABI unchanged\n\n### Code Quality\n\n- **File Size**: All files ≤ 500 lines (target ≤ 400 lines)\n- **Function Size**: All functions ≤ 50 lines (maintained)\n- **Formatting**: Consistent with `cargo fmt`\n- **Linting**: Passes `cargo clippy` with no warnings\n- **Documentation**: All public items documented\n\n### Reliability\n\n- **Zero Regressions**: All tests pass after splits\n- **Deterministic**: Splits are repeatable and verifiable\n- **Reversible**: Changes can be backed out if issues arise\n- **Safe**: No undefined behavior introduced\n- **Stable**: Intermediate states all compile and test\n\n### Usability (Developer Experience)\n\n- **Clear Structure**: Module organization is intuitive\n- **Easy Navigation**: Developers can find code quickly\n- **Self-Documenting**: Module names describe contents\n- **Minimal Friction**: Splits don't disrupt workflow\n- **Good Examples**: Documentation shows how to use new structure\n",
  "fileStats": {
    "size": 12932,
    "lines": 310,
    "lastModified": "2025-12-11T15:53:27.980Z"
  },
  "comments": []
}