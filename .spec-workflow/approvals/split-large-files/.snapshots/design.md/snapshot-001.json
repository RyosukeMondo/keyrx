{
  "id": "snapshot_1765468653799_7hwmir4ye",
  "approvalId": "approval_1765468653728_y6qrghae3",
  "approvalTitle": "Split Large Files - Design Document",
  "version": 1,
  "timestamp": "2025-12-11T15:57:33.799Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design implements systematic file splitting for 56 files exceeding 500-line limit, prioritizing the top 10 largest files (10,000+ lines total). Each split follows logical domain boundaries while maintaining 100% API compatibility through re-exports.\n\n**Core Design Principles:**\n1. **Split by domain** - Group related functionality\n2. **Maintain API compatibility** - Re-export all public items\n3. **Single responsibility** - Each module has one clear purpose\n4. **Incremental approach** - One file at a time, test after each\n5. **Target 300-400 lines** - Leave buffer below 500-line limit\n\n## Steering Document Alignment\n\n### Technical Standards (~/.claude/CLAUDE.md)\n\n**Code Metrics Met:**\n- ✅ **Max 500 lines/file**: All files comply after splits\n- ✅ **SOLID - SRP**: Each module has single responsibility\n- ✅ **Modular Design**: Clear boundaries between modules\n\n## Code Reuse Analysis\n\n### Existing Patterns to Leverage\n\n- **Module Organization**: KeyRx already uses submodule pattern in many places\n  - Example: `engine/state/` is already a directory with `mod.rs`\n  - Reuse: Apply same pattern to split other large files\n\n- **Re-export Pattern**: Project already re-exports types for convenience\n  - Example: `services/mod.rs` re-exports service types\n  - Reuse: Apply to maintain API after splits\n\n- **Conditional Compilation**: Project uses `#[cfg(test)]` effectively\n  - Example: Test mocks conditionally compiled\n  - Reuse: Keep test modules organized in splits\n\n## Architecture\n\n### File Splitting Strategy\n\n```mermaid\ngraph TD\n    A[Large File 1893 lines] -->|Split by Domain| B[mod.rs 200 lines]\n    B -->|Re-export| C[domain_a.rs 400 lines]\n    B -->|Re-export| D[domain_b.rs 400 lines]\n    B -->|Re-export| E[domain_c.rs 400 lines]\n    B -->|Re-export| F[utilities.rs 400 lines]\n\n    style A fill:#ffcccc\n    style B fill:#ccffcc\n    style C fill:#ccffcc\n    style D fill:#ccffcc\n    style E fill:#ccffcc\n    style F fill:#ccffcc\n```\n\n### General Pattern for All Splits\n\n**Before:**\n```\ncore/src/\n└── example.rs (1,000 lines)\n```\n\n**After:**\n```\ncore/src/\n└── example/\n    ├── mod.rs           (100-200 lines) - Re-exports\n    ├── domain_a.rs      (300-400 lines) - Domain A\n    ├── domain_b.rs      (300-400 lines) - Domain B\n    └── utilities.rs     (200-300 lines) - Shared utils\n```\n\n**mod.rs Template:**\n```rust\n//! Module description explaining overall purpose.\n//!\n//! Organized into focused submodules:\n//! - [`domain_a`] - Description of domain A\n//! - [`domain_b`] - Description of domain B\n//! - [`utilities`] - Shared utility functions\n\npub mod domain_a;\npub mod domain_b;\npub mod utilities;\n\n// Re-export public API\npub use domain_a::{PublicType1, public_function1};\npub use domain_b::{PublicType2, public_function2};\npub use utilities::*;\n```\n\n## Top 10 File Splitting Plans\n\n### 1. scripting/bindings.rs (1,893 lines → 4 modules)\n\n**Analysis:** Contains Rhai bindings for different functional domains: keyboard, layers, modifiers, timing, combos.\n\n**Split Plan:**\n```\nscripting/bindings/\n├── mod.rs                (200 lines) - register_all_functions + re-exports\n├── keyboard.rs           (450 lines) - remap, block, pass, tap_hold bindings\n├── layers.rs             (450 lines) - layer_define, layer_map, layer_push/pop/toggle\n├── modifiers.rs          (450 lines) - modifier definitions, one_shot\n├── timing.rs             (250 lines) - timeout configuration functions\n└── row_col.rs            (400 lines) - row-column API functions (_rc variants)\n```\n\n**Public API Re-exports:**\n- All `register_*` functions remain callable from `scripting::bindings::`\n- `register_all_functions` stays at top level\n\n### 2. engine/state/mod.rs (1,570 lines → 3 modules)\n\n**Analysis:** State management split across key state, layer state, modifier state.\n\n**Split Plan:**\n```\nengine/state/\n├── mod.rs                (200 lines) - Main EngineState struct + re-exports\n├── key_state.rs          (500 lines) - Physical/virtual key tracking\n├── layer_state.rs        (450 lines) - Layer stack and activation\n├── modifier_state.rs     (420 lines) - Modifier tracking and application\n```\n\n**API Preservation:**\n- `EngineState` struct remains in `mod.rs` with public methods\n- Internal state moved to submodules, accessed via private fields\n\n### 3. engine/transitions/log.rs (1,403 lines → 3 modules)\n\n**Analysis:** Transition logging with formatting, querying, and analysis.\n\n**Split Plan:**\n```\nengine/transitions/\n├── log.rs                (200 lines) - TransitionLog struct + API\n├── log_entry.rs          (450 lines) - Entry types and formatting\n├── log_query.rs          (400 lines) - Query and filtering\n└── log_analysis.rs       (450 lines) - Analysis and reporting\n```\n\n**API Preservation:**\n- `TransitionLog` public API unchanged\n- Internal implementation split across submodules\n\n### 4. bin/keyrx.rs (1,382 lines → 3 modules)\n\n**Analysis:** CLI with many subcommands.\n\n**Split Plan:**\n```\nbin/\n├── keyrx.rs              (200 lines) - main(), CLI args, dispatch\n├── commands_core.rs      (450 lines) - run, simulate, check, discover\n├── commands_config.rs    (400 lines) - devices, hardware, layout, keymap\n└── commands_test.rs      (450 lines) - test, replay, analyze, uat, regression\n```\n\n**API Preservation:**\n- N/A (binary, no library API)\n- Just ensure all commands still work\n\n### 5. scripting/docs/generators/html.rs (1,069 lines → 2 modules)\n\n**Analysis:** HTML doc generation with rendering and template logic.\n\n**Split Plan:**\n```\nscripting/docs/generators/\n├── html.rs               (200 lines) - Public API, HtmlGenerator struct\n├── html_templates.rs     (450 lines) - HTML template functions\n└── html_rendering.rs     (450 lines) - Rendering logic\n```\n\n### 6. validation/engine.rs (968 lines → 2 modules)\n\n**Analysis:** Engine validation with rules and reporting.\n\n**Split Plan:**\n```\nvalidation/\n├── engine.rs             (200 lines) - Public validation API\n├── engine_rules.rs       (400 lines) - Validation rule implementations\n└── engine_report.rs      (400 lines) - Error reporting and formatting\n```\n\n### 7. config/loader.rs (949 lines → 2 modules)\n\n**Analysis:** Config loading for multiple types (layout, keymap, hardware).\n\n**Split Plan:**\n```\nconfig/\n├── loader.rs             (200 lines) - ConfigManager + high-level API\n├── loader_parsing.rs     (400 lines) - YAML/TOML parsing logic\n└── loader_validation.rs  (400 lines) - Config validation and normalization\n```\n\n### 8. registry/profile.rs (918 lines → 2 modules)\n\n**Analysis:** Profile registry with CRUD and resolution logic.\n\n**Split Plan:**\n```\nregistry/\n├── profile.rs            (200 lines) - ProfileRegistry struct + public API\n├── profile_storage.rs    (400 lines) - Persistence and loading\n└── profile_resolution.rs (400 lines) - Profile resolution and priority\n```\n\n### 9. engine/advanced.rs (906 lines → 2 modules)\n\n**Analysis:** Advanced engine features (combos, macros, sequences).\n\n**Split Plan:**\n```\nengine/\n├── advanced.rs           (200 lines) - Public advanced features API\n├── combos.rs             (400 lines) - Combo detection and handling\n└── sequences.rs          (400 lines) - Macro and sequence playback\n```\n\n### 10. cli/commands/run.rs (899 lines → 2 modules)\n\n**Analysis:** Run command with setup and execution logic.\n\n**Split Plan:**\n```\ncli/commands/\n├── run.rs                (200 lines) - RunCommand + args + dispatch\n├── run_setup.rs          (400 lines) - Engine setup and initialization\n└── run_execution.rs      (400 lines) - Main execution loop\n```\n\n## Module Organization Patterns\n\n### Pattern 1: Domain-Based Split\n\n**When to use:** File contains multiple distinct functional domains\n\n**Example:** `scripting/bindings.rs` → keyboard, layers, modifiers\n\n```rust\n// mod.rs\npub mod keyboard;\npub mod layers;\npub mod modifiers;\n\npub use keyboard::*;\npub use layers::*;\npub use modifiers::*;\n```\n\n### Pattern 2: Layered Split\n\n**When to use:** File has distinct layers (API, implementation, utilities)\n\n**Example:** `config/loader.rs` → API, parsing, validation\n\n```rust\n// loader.rs (mod.rs)\nmod parsing;\nmod validation;\n\nuse parsing::parse_config;\nuse validation::validate_config;\n\npub struct ConfigManager {\n    // Public struct stays here\n}\n\nimpl ConfigManager {\n    pub fn load(&self) -> Result<Config> {\n        let raw = parsing::parse_config()?;\n        validation::validate_config(&raw)?;\n        Ok(raw)\n    }\n}\n```\n\n### Pattern 3: Type-Based Split\n\n**When to use:** File has multiple complex types with implementations\n\n**Example:** `engine/state/mod.rs` → key_state, layer_state, modifier_state\n\n```rust\n// mod.rs\nmod key_state;\nmod layer_state;\nmod modifier_state;\n\npub use key_state::KeyState;\npub use layer_state::LayerState;\npub use modifier_state::ModifierState;\n\npub struct EngineState {\n    key_state: KeyState,\n    layer_state: LayerState,\n    modifier_state: ModifierState,\n}\n```\n\n## Import Management Strategy\n\n### Internal Imports (within split modules)\n\n```rust\n// In submodule: scripting/bindings/keyboard.rs\nuse super::utilities::parse_key; // From sibling module\nuse crate::engine::HoldAction;  // From other crate module\n```\n\n### Re-exporting for Compatibility\n\n```rust\n// In mod.rs\npub use keyboard::{\n    register_remap,\n    register_block,\n    register_tap_hold,\n};\n\n// External code still works:\nuse keyrx_core::scripting::bindings::register_remap;\n```\n\n### Avoiding Circular Dependencies\n\n**Problem:** Module A needs Module B, Module B needs Module A\n\n**Solution 1:** Extract shared types to parent or separate module\n```rust\n// types.rs (or mod.rs)\npub struct SharedType;\n\n// module_a.rs\nuse super::types::SharedType;\n\n// module_b.rs\nuse super::types::SharedType;\n```\n\n**Solution 2:** Use trait abstraction\n```rust\n// module_a.rs\npub trait Interface { }\n\n// module_b.rs\nuse super::module_a::Interface;\n```\n\n## Testing Strategy\n\n### Per-File Testing Checklist\n\nAfter each file split:\n\n1. **Compilation:**\n```bash\ncargo build --lib          # Verify library compiles\ncargo build --all          # Verify entire project compiles\n```\n\n2. **Tests:**\n```bash\ncargo test --lib           # Run unit tests\ncargo test --all           # Run all tests\n```\n\n3. **Linting:**\n```bash\ncargo clippy --all-targets # Check for warnings\ncargo fmt --check          # Check formatting\n```\n\n4. **Documentation:**\n```bash\ncargo doc --no-deps        # Verify doc generation\n```\n\n5. **Incremental Build Test:**\n```bash\ntouch core/src/path/to/new_submodule.rs\ncargo build --lib          # Should be fast (<5s)\n```\n\n### Verification Tests\n\n**Test 1: API Compatibility**\n```rust\n// Ensure all previous imports still work\nuse keyrx_core::scripting::bindings::register_all_functions;\nuse keyrx_core::engine::state::EngineState;\n// etc.\n```\n\n**Test 2: No Duplicate Symbols**\n```bash\n# Should not produce \"multiple definitions\" errors\ncargo build\n```\n\n**Test 3: Documentation Links**\n```bash\ncargo doc --no-deps\n# Check that intra-doc links work (no broken links)\n```\n\n## Error Handling\n\n### Common Split Errors and Solutions\n\n**Error 1: Cannot find import**\n```\nerror[E0432]: unresolved import `crate::example::Type`\n```\n\n**Solution:** Check re-exports in mod.rs, ensure type is public\n\n**Error 2: Circular dependency**\n```\nerror[E0391]: cycle detected when processing `module_a`\n```\n\n**Solution:** Extract shared types to parent module or separate file\n\n**Error 3: Private type in public interface**\n```\nerror[E0446]: private type `InternalType` in public interface\n```\n\n**Solution:** Make type public or use it only internally\n\n**Error 4: Unused imports**\n```\nwarning: unused import: `Type`\n```\n\n**Solution:** Remove unused imports, run `cargo clippy --fix`\n\n## Performance Impact\n\n### Compilation Time Improvement\n\n**Before Split (example: bindings.rs):**\n- Touch bindings.rs → Recompile entire 1,893-line file\n- Incremental build time: ~8-10s\n\n**After Split:**\n- Touch bindings/keyboard.rs → Recompile only 450-line file\n- Incremental build time: ~3-4s\n- **Improvement: 50-60% faster**\n\n### Overall Project Impact\n\n**Estimated Improvements:**\n- Top 10 files: 10,000 lines → ~4,000 lines across 30 modules\n- Average module size: ~300 lines (vs ~1,000 before)\n- Incremental builds: 20-30% faster overall\n- Parallel compilation: Better utilization (more independent units)\n\n## Migration Plan\n\n### Phase 1: Split Top 3 Files (3,866 lines → 12 modules)\n\n1. `scripting/bindings.rs` (1,893 lines → 6 modules)\n2. `engine/state/mod.rs` (1,570 lines → 4 modules)\n3. `engine/transitions/log.rs` (1,403 lines → 4 modules)\n\n**Estimated time:** 1 day (3-4 hours per file)\n\n### Phase 2: Split Files 4-7 (4,368 lines → 10 modules)\n\n4. `bin/keyrx.rs` (1,382 lines → 4 modules)\n5. `scripting/docs/generators/html.rs` (1,069 lines → 3 modules)\n6. `validation/engine.rs` (968 lines → 3 modules)\n7. `config/loader.rs` (949 lines → 3 modules)\n\n**Estimated time:** 1.5 days\n\n### Phase 3: Split Files 8-10 (2,723 lines → 6 modules)\n\n8. `registry/profile.rs` (918 lines → 3 modules)\n9. `engine/advanced.rs` (906 lines → 3 modules)\n10. `cli/commands/run.rs` (899 lines → 3 modules)\n\n**Estimated time:** 1 day\n\n### Phase 4: Split Remaining 46 Files (Optional, Lower Priority)\n\nFiles 505-900 lines can be split as time permits.\n\n**Estimated time:** 2-3 days\n\n**Total estimated time:** 1 week for top 10, 2 weeks for all 56 files\n\n## Documentation Updates\n\n### Module Documentation\n\nEach split requires:\n\n1. **Parent mod.rs doc comment:**\n```rust\n//! Module purpose and overview.\n//!\n//! # Organization\n//! - [`submodule_a`] - Description\n//! - [`submodule_b`] - Description\n//!\n//! # Examples\n//! ```\n//! use keyrx_core::example::function;\n//! function();\n//! ```\n```\n\n2. **Submodule doc comments:**\n```rust\n//! Submodule purpose.\n//!\n//! Contains functionality for X, Y, Z.\n```\n\n3. **Migration notes (if needed):**\n```rust\n//! # Migration from Previous Version\n//! If you were importing internal items, update:\n//! - Old: `use keyrx_core::example::internal_type;`\n//! - New: `use keyrx_core::example::submodule::internal_type;`\n```\n\n### README Updates\n\nAfter completing splits, update project README/docs:\n\n- Note improved module organization\n- Update architecture diagrams if they reference specific files\n- Update contributor guide with new module structure\n\n## Backward Compatibility\n\n### Guaranteed Compatibility\n\n✅ **Public API:** All public functions, types, traits remain accessible\n✅ **Imports:** Existing `use` statements continue working\n✅ **FFI:** No changes to FFI layer (uses public API)\n✅ **Binary:** keyrx binary continues working identically\n✅ **Tests:** All tests pass without modification\n\n### Potential Internal Changes\n\n⚠️ **Internal imports:** Code importing private internals may need updates\n⚠️ **Documentation links:** Some intra-doc links may need updates if they referenced line numbers\n\n**Mitigation:** These are internal details, not public API. Documented in migration notes.\n",
  "fileStats": {
    "size": 15187,
    "lines": 563,
    "lastModified": "2025-12-11T15:54:56.933Z"
  },
  "comments": []
}