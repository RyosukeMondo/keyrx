{
  "id": "snapshot_1765452225352_snl7swtlj",
  "approvalId": "approval_1765452225281_4ds35qrrw",
  "approvalTitle": "Rust FFI Code Generation - Tasks",
  "version": 1,
  "timestamp": "2025-12-11T11:23:45.352Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n## Implementation Tasks\n\n### Phase 1: Runtime Library\n\n- [ ] 1. Create keyrx_ffi_runtime crate\n  - Files: `core/keyrx_ffi_runtime/Cargo.toml`, `core/keyrx_ffi_runtime/src/lib.rs`\n  - Create new library crate for FFI runtime helpers\n  - Add dependencies: serde_json, libc\n  - Purpose: Provide reusable FFI utilities for generated code\n  - _Leverage: Existing FFI patterns from core/src/ffi_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer specializing in crate architecture and FFI | Task: Create new keyrx_ffi_runtime library crate with proper Cargo.toml configuration following requirement REQ-2 | Restrictions: Must use stable Rust, add appropriate dependencies, follow crate naming conventions | Success: Crate compiles successfully, dependencies are correctly configured, follows Rust 2021 edition | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include crate structure, dependencies), then mark the task as completed in tasks.md_\n\n- [ ] 2. Implement C string parsing helpers\n  - File: `core/keyrx_ffi_runtime/src/string.rs`\n  - Implement `parse_c_string(ptr: *const c_char, name: &str) -> Result<String, String>`\n  - Add null pointer checking and UTF-8 validation\n  - Purpose: Safely convert C strings to Rust strings\n  - _Leverage: Existing parse_c_string patterns from core/src/ffi/exports.rs_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with FFI and string handling expertise | Task: Implement safe C string parsing with null checks and UTF-8 validation following requirement REQ-2 | Restrictions: Must handle null pointers safely, provide descriptive errors, function under 50 lines | Success: Parses valid C strings correctly, returns errors for null/invalid UTF-8, safe and tested | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include function signature, safety checks), then mark the task as completed in tasks.md_\n\n- [ ] 3. Implement JSON serialization helpers\n  - File: `core/keyrx_ffi_runtime/src/json.rs`\n  - Implement `serialize_to_c_string<T: Serialize>(value: &T) -> Result<*const c_char, String>`\n  - Handle serialization errors gracefully\n  - Purpose: Convert Rust types to C strings via JSON\n  - _Leverage: serde_json for serialization_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with expertise in serialization and FFI | Task: Implement JSON to C string serialization following requirement REQ-2, handling errors and memory allocation | Restrictions: Must allocate C string correctly, handle serialization failures, function under 50 lines | Success: Serializes Rust types to C strings, proper memory management, error handling works | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include function signature, memory management), then mark the task as completed in tasks.md_\n\n- [ ] 4. Implement panic catching wrapper\n  - File: `core/keyrx_ffi_runtime/src/panic.rs`\n  - Implement `handle_panic<F>(f: F) -> Result<F::Output, String>` using catch_unwind\n  - Convert panic payload to error message\n  - Purpose: Catch panics at FFI boundary\n  - _Leverage: std::panic::catch_unwind_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with expertise in panic handling and FFI safety | Task: Implement panic catching wrapper following requirement REQ-3, using catch_unwind to prevent panics crossing FFI boundary | Restrictions: Must handle all panic types, extract meaningful error messages, function under 50 lines | Success: Catches all panics, converts to error strings, prevents undefined behavior at FFI boundary | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include function signature, panic handling logic), then mark the task as completed in tasks.md_\n\n- [ ] 5. Implement complete FFI wrapper\n  - File: `core/keyrx_ffi_runtime/src/wrapper.rs`\n  - Implement `ffi_wrapper<F, T>(error: *mut *mut c_char, f: F) -> *const c_char`\n  - Combine panic catching, error handling, and serialization\n  - Purpose: Provide single wrapper for all generated FFI functions\n  - _Leverage: panic.rs, json.rs, string.rs modules_\n  - _Requirements: REQ-2, REQ-3_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with expertise in FFI and error handling | Task: Implement comprehensive FFI wrapper following requirements REQ-2 and REQ-3, integrating panic catching, Result handling, and JSON serialization | Restrictions: Must handle all error paths, set error pointer correctly, function under 50 lines | Success: Wrapper handles all scenarios (success, error, panic), memory is managed correctly, error pointer set appropriately | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include function signature, error handling flow), then mark the task as completed in tasks.md_\n\n- [ ] 6. Add runtime library unit tests\n  - File: `core/keyrx_ffi_runtime/src/tests.rs`\n  - Test all helper functions with success and error cases\n  - Test panic catching, null handling, invalid UTF-8\n  - Purpose: Ensure runtime reliability\n  - _Leverage: None (new test module)_\n  - _Requirements: REQ-2, REQ-3_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with Rust testing expertise | Task: Create comprehensive unit tests for FFI runtime library following requirements REQ-2 and REQ-3, testing all helper functions and error paths | Restrictions: Test both success and failure scenarios, test panic catching, maintain test isolation | Success: All runtime functions tested, edge cases covered, tests run reliably | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool, then mark the task as completed in tasks.md_\n\n### Phase 2: Procedural Macro Crate\n\n- [ ] 7. Create keyrx_ffi_macro crate\n  - Files: `core/keyrx_ffi_macro/Cargo.toml`, `core/keyrx_ffi_macro/src/lib.rs`\n  - Create proc-macro crate with `proc-macro = true`\n  - Add dependencies: syn, quote, proc-macro2, serde_json\n  - Purpose: Provide procedural macro for FFI code generation\n  - _Leverage: None (new crate)_\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer specializing in procedural macros | Task: Create keyrx_ffi_macro proc-macro crate following requirement REQ-1, configuring Cargo.toml for proc-macro type | Restrictions: Must set proc-macro = true, add correct dependencies, follow macro crate conventions | Success: Proc-macro crate compiles, dependencies correct, ready for macro implementation | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include crate structure), then mark the task as completed in tasks.md_\n\n- [ ] 8. Implement macro attribute parsing\n  - File: `core/keyrx_ffi_macro/src/parse.rs`\n  - Parse `#[keyrx_ffi(domain = \"...\")]` attribute\n  - Extract domain parameter\n  - Purpose: Parse macro invocation and extract configuration\n  - _Leverage: syn for attribute parsing_\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust macro developer with syn expertise | Task: Implement attribute parsing for keyrx_ffi macro following requirement REQ-1, extracting domain parameter from macro attributes | Restrictions: Must validate domain parameter exists, provide clear errors for invalid usage, function under 50 lines | Success: Parses domain parameter correctly, validates input, provides helpful error messages | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include function signature, parsing logic), then mark the task as completed in tasks.md_\n\n- [ ] 9. Implement contract loader\n  - File: `core/keyrx_ffi_macro/src/contract_loader.rs`\n  - Implement `load_contract_for_domain(domain: &str) -> Result<FfiContract, syn::Error>`\n  - Load and parse JSON contract files at compile time\n  - Purpose: Read contracts during macro expansion\n  - _Leverage: FfiContract from core/src/ffi/contract.rs, serde_json_\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with compile-time file I/O and macro expertise | Task: Implement contract loader following requirement REQ-1, reading and parsing JSON contracts during macro expansion | Restrictions: Must use CARGO_MANIFEST_DIR, handle file not found, provide clear compile errors, function under 50 lines | Success: Loads contracts at compile time, parses JSON correctly, provides helpful errors for missing/invalid files | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include function signature, file loading logic), then mark the task as completed in tasks.md_\n\n- [ ] 10. Create type mapping for code generation\n  - File: `core/keyrx_ffi_macro/src/type_mapper.rs`\n  - Implement `map_contract_type_to_ffi(contract_type: &str) -> TokenStream`\n  - Generate Rust FFI type tokens from contract types\n  - Purpose: Convert contract types to Rust code tokens\n  - _Leverage: quote crate for token generation_\n  - _Requirements: REQ-2, REQ-4_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust macro developer with quote and FFI expertise | Task: Implement type mapper for code generation following requirements REQ-2 and REQ-4, converting contract types to Rust token streams | Restrictions: Must handle all contract types, generate correct FFI types, function under 50 lines | Success: Generates correct Rust FFI types for all contract types, token streams compile correctly | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include type mappings, token generation), then mark the task as completed in tasks.md_\n\n- [ ] 11. Implement parameter parser generation\n  - File: `core/keyrx_ffi_macro/src/codegen.rs`\n  - Generate code for parsing FFI parameters\n  - Handle string, int, bool, and JSON types\n  - Purpose: Generate parameter parsing code\n  - _Leverage: type_mapper.rs, keyrx_ffi_runtime helpers_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust code generation expert | Task: Generate parameter parsing code following requirement REQ-2, creating code that converts FFI parameters to Rust types | Restrictions: Must use runtime helpers, handle all parameter types, generate safe code, function under 50 lines | Success: Generated parsing code compiles and works correctly, handles all parameter types, uses runtime helpers appropriately | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include code generation logic), then mark the task as completed in tasks.md_\n\n- [ ] 12. Implement result serializer generation\n  - File: `core/keyrx_ffi_macro/src/codegen.rs`\n  - Generate code for serializing return values\n  - Handle void, primitives, and custom types\n  - Purpose: Generate result serialization code\n  - _Leverage: type_mapper.rs, keyrx_ffi_runtime::serialize_to_c_string_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust code generation expert | Task: Generate result serialization code following requirement REQ-2, creating code that converts Rust return values to FFI types | Restrictions: Must handle void returns, use serialization helpers, generate correct code, function under 50 lines | Success: Generated serialization code works for all return types, handles void correctly, uses runtime helpers | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include code templates), then mark the task as completed in tasks.md_\n\n- [ ] 13. Implement FFI function generation\n  - File: `core/keyrx_ffi_macro/src/codegen.rs`\n  - Generate complete `extern \"C\"` function wrapper\n  - Include #[no_mangle], error pointer, panic handling\n  - Purpose: Generate complete FFI function from contract\n  - _Leverage: All codegen components_\n  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-4_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust macro developer with comprehensive FFI expertise | Task: Implement complete FFI function generation following all requirements, creating extern C wrappers with panic handling and error management | Restrictions: Must use ffi_wrapper from runtime, follow contract signatures exactly, function under 50 lines | Success: Generated FFI functions compile correctly, match contract signatures, handle all error scenarios | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include generated function template, key features), then mark the task as completed in tasks.md_\n\n- [ ] 14. Implement macro entry point\n  - File: `core/keyrx_ffi_macro/src/lib.rs`\n  - Implement `#[proc_macro_attribute]` for keyrx_ffi\n  - Orchestrate parsing, loading, and code generation\n  - Purpose: Main entry point for the macro\n  - _Leverage: All previous macro components_\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust macro developer | Task: Implement main macro entry point following requirement REQ-1, orchestrating all components to generate FFI code | Restrictions: Must handle errors gracefully with syn::Error, validate impl structure, function under 50 lines | Success: Macro compiles and expands correctly, generates valid Rust code, provides clear errors | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include macro flow, error handling), then mark the task as completed in tasks.md_\n\n### Phase 3: Testing & Integration\n\n- [ ] 15. Add trybuild tests for macro\n  - File: `core/keyrx_ffi_macro/tests/compile_tests.rs`\n  - Create trybuild tests for successful expansions\n  - Create trybuild tests for error cases\n  - Purpose: Test macro compilation behavior\n  - _Leverage: trybuild crate_\n  - _Requirements: REQ-1, REQ-6_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with Rust macro testing expertise | Task: Create trybuild tests for macro following requirements REQ-1 and REQ-6, testing both successful and failing compilations | Restrictions: Test valid and invalid macro usage, verify error messages, organize test files clearly | Success: Macro behavior is fully tested, error cases produce expected errors, tests catch regressions | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool, then mark the task as completed in tasks.md_\n\n- [ ] 16. Create integration test with real contract\n  - File: `core/tests/ffi_macro_integration.rs`\n  - Use macro with config domain contract\n  - Verify generated code compiles and works\n  - Purpose: Test end-to-end macro functionality\n  - _Leverage: Existing config.ffi-contract.json_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Integration test engineer with Rust expertise | Task: Create integration test using real contracts, verifying generated FFI functions work correctly end-to-end | Restrictions: Must use real contracts, test actual FFI calls, verify results, test under 100 lines | Success: Generated code works with real contracts, FFI calls succeed, demonstrates full functionality | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include test scenarios), then mark the task as completed in tasks.md_\n\n- [ ] 17. Apply macro to config domain\n  - File: `core/src/ffi/domains/config.rs`\n  - Replace manual FFI functions with macro-generated ones\n  - Verify all config functions work identically\n  - Purpose: Migrate first domain to use macro\n  - _Leverage: config.ffi-contract.json, generated code_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with migration expertise | Task: Migrate config domain to use keyrx_ffi macro, replacing manual FFI with generated code while maintaining identical behavior | Restrictions: Must not break existing functionality, test thoroughly, keep implementation clean | Success: Config domain uses macro, all functions work identically, code is cleaner and shorter | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool (include migration changes, before/after comparison), then mark the task as completed in tasks.md_\n\n- [ ] 18. Add documentation and examples\n  - Files: `core/keyrx_ffi_macro/README.md`, inline docs\n  - Document macro usage with examples\n  - Create migration guide from manual FFI\n  - Purpose: Enable developers to use the macro\n  - _Leverage: None (new documentation)_\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec rust-ffi-codegen, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with Rust FFI expertise | Task: Create comprehensive documentation for FFI macro following requirement REQ-5, including usage examples and migration guide | Restrictions: Provide clear examples, explain contract requirements, document error cases | Success: Documentation is complete, examples are clear, migration guide is helpful | Instructions: Mark this task as in-progress in tasks.md before starting. After completion, log the implementation with detailed artifacts using the log-implementation tool, then mark the task as completed in tasks.md_\n",
  "fileStats": {
    "size": 20327,
    "lines": 172,
    "lastModified": "2025-12-11T11:22:15.660Z"
  },
  "comments": []
}