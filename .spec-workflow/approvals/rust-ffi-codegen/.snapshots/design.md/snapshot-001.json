{
  "id": "snapshot_1765451763030_vqpygzhvz",
  "approvalId": "approval_1765451762961_aa7wskjfv",
  "approvalTitle": "Rust FFI Code Generation - Design",
  "version": 1,
  "timestamp": "2025-12-11T11:16:03.030Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Rust FFI Code Generation feature uses procedural macros to automatically generate `extern \"C\"` FFI wrapper functions from JSON contracts. Developers write clean Rust implementation functions, and the macro generates all FFI boilerplate including panic catching, type marshaling, error handling, and JSON serialization.\n\nThis eliminates 300+ lines of repetitive FFI code and makes contract violations compile-time errors instead of runtime crashes.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **Dependency Injection**: Generated code preserves DI patterns; implementations remain testable\n- **Error Handling**: Generated wrappers catch panics and convert `Result<T, E>` to FFI error pointers\n- **Performance**: Zero-cost abstractions; generated code is as fast as hand-written FFI\n- **Rust Stability**: Uses stable Rust proc macros; no nightly features required\n\n### Project Structure (structure.md)\n\n- **New Crate**: `keyrx_ffi_macro/` - Procedural macro crate (required for proc macros)\n- **Runtime Crate**: `keyrx_ffi_runtime/` - Runtime marshaling helpers shared between macro and core\n- **Integration**: Core uses `#[keyrx_ffi]` macro to generate FFI exports\n- **Naming**: Generated functions follow `keyrx_{domain}_{function}` convention\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **ContractRegistry**: Load and parse JSON contracts at compile time\n- **FfiContract / FunctionContract**: Already models contract structure\n- **TypeDefinition**: Contract type information for code generation\n- **Error Handling**: Existing `FfiError` and `FfiResult` types\n\n### Integration Points\n\n- **FFI Exports**: Replace manual `extern \"C\"` functions in `core/src/ffi/exports.rs` and domain modules\n- **Contracts**: Read from `core/src/ffi/contracts/*.ffi-contract.json`\n- **Serialization**: Use existing `serde_json` for JSON marshaling\n\n## Architecture\n\nThe code generation system follows a compile-time transformation pipeline:\n\n```\nContract JSON → Macro Expansion → AST Generation → Rust Compilation\n```\n\n### Modular Design Principles\n\n- **Separation**: Macro crate (`keyrx_ffi_macro`) and runtime crate (`keyrx_ffi_runtime`) are separate\n- **Single Responsibility**: Macro generates code; runtime provides marshaling utilities\n- **Composability**: Individual functions can use the macro independently\n\n```mermaid\ngraph TD\n    A[Developer writes impl] --> B[#[keyrx_ffi] macro]\n    B --> C[Load contract.json]\n    C --> D[Validate impl signature]\n    D --> E[Generate extern C wrapper]\n    E --> F[Insert panic handling]\n    F --> G[Insert type marshaling]\n    G --> H[Compile to binary]\n```\n\n## Components and Interfaces\n\n### Component 1: Procedural Macro (`keyrx_ffi_macro`)\n- **Purpose:** Attribute macro that generates FFI wrappers from contracts\n- **Interfaces:**\n  - `#[keyrx_ffi(domain = \"config\")]` attribute on `impl` blocks or functions\n- **Dependencies:** `syn`, `quote`, `proc_macro2`, `serde_json`\n- **Reuses:** Contract loading logic from `ContractRegistry`\n\n**Macro Expansion Example:**\n```rust\n// Developer writes:\n#[keyrx_ffi(domain = \"config\")]\nimpl ConfigFfi {\n    fn save_hardware_profile(profile_json: String) -> Result<HardwareProfile, String> {\n        // Implementation\n    }\n}\n\n// Macro generates:\n#[no_mangle]\npub unsafe extern \"C\" fn keyrx_config_save_hardware_profile(\n    profile_json: *const c_char,\n    error: *mut *mut c_char,\n) -> *const c_char {\n    keyrx_ffi_runtime::ffi_wrapper(error, || {\n        let profile_json = keyrx_ffi_runtime::parse_c_string(profile_json, \"profile_json\")?;\n        let result = ConfigFfi::save_hardware_profile(profile_json)?;\n        keyrx_ffi_runtime::serialize_to_c_string(&result)\n    })\n}\n```\n\n### Component 2: Runtime Marshaling Library (`keyrx_ffi_runtime`)\n- **Purpose:** Provide reusable FFI utilities for generated code\n- **Interfaces:**\n  - `ffi_wrapper<F>(error: *mut *mut c_char, f: F) -> ReturnType`\n  - `parse_c_string(ptr: *const c_char, name: &str) -> Result<String>`\n  - `serialize_to_c_string<T: Serialize>(value: &T) -> Result<*const c_char>`\n  - `handle_panic<F>(f: F) -> Result<F::Output>`\n- **Dependencies:** `serde_json`, `libc`\n- **Reuses:** Existing FFI error handling patterns\n\n**Key Functions:**\n```rust\n// Panic-catching wrapper\npub fn ffi_wrapper<F, T>(error: *mut *mut c_char, f: F) -> *const c_char\nwhere\n    F: FnOnce() -> Result<T, String> + std::panic::UnwindSafe,\n    T: Serialize,\n{\n    match handle_panic(|| f()) {\n        Ok(Ok(value)) => match serialize_to_c_string(&value) {\n            Ok(ptr) => ptr,\n            Err(e) => {\n                set_error_pointer(error, &e);\n                ptr::null()\n            }\n        },\n        Ok(Err(e)) => {\n            set_error_pointer(error, &e);\n            ptr::null()\n        }\n        Err(panic_msg) => {\n            set_error_pointer(error, &format!(\"Panic: {}\", panic_msg));\n            ptr::null()\n        }\n    }\n}\n\n// Parse C string safely\npub fn parse_c_string(ptr: *const c_char, param_name: &str) -> Result<String, String> {\n    if ptr.is_null() {\n        return Err(format!(\"Null pointer for parameter '{}'\", param_name));\n    }\n    unsafe {\n        CStr::from_ptr(ptr)\n            .to_str()\n            .map(|s| s.to_string())\n            .map_err(|_| format!(\"Invalid UTF-8 in parameter '{}'\", param_name))\n    }\n}\n```\n\n### Component 3: Contract Loader (Compile-time)\n- **Purpose:** Load and parse contracts during macro expansion\n- **Interfaces:**\n  - `load_contract(domain: &str) -> Result<FfiContract, Error>`\n- **Dependencies:** File I/O, `serde_json`\n- **Reuses:** `ContractRegistry` parsing logic\n\n**Implementation:**\n```rust\nfn load_contract_for_domain(domain: &str) -> Result<FfiContract, syn::Error> {\n    let manifest_dir = env::var(\"CARGO_MANIFEST_DIR\")\n        .map_err(|_| syn::Error::new(Span::call_site(), \"CARGO_MANIFEST_DIR not set\"))?;\n\n    let contract_path = PathBuf::from(manifest_dir)\n        .join(\"src/ffi/contracts\")\n        .join(format!(\"{}.ffi-contract.json\", domain));\n\n    let content = std::fs::read_to_string(&contract_path)\n        .map_err(|e| syn::Error::new(\n            Span::call_site(),\n            format!(\"Failed to load contract {}: {}\", contract_path.display(), e)\n        ))?;\n\n    serde_json::from_str(&content)\n        .map_err(|e| syn::Error::new(\n            Span::call_site(),\n            format!(\"Invalid contract JSON: {}\", e)\n        ))\n}\n```\n\n### Component 4: Code Generator\n- **Purpose:** Generate Rust AST for FFI wrapper functions\n- **Interfaces:**\n  - `generate_ffi_function(func_contract: &FunctionContract, impl_fn: &ImplItemFn) -> TokenStream`\n- **Dependencies:** `quote`, `syn`\n- **Reuses:** None (new functionality)\n\n**Generation Strategy:**\n1. Extract function name from contract\n2. Map parameter types from contract to FFI types\n3. Generate parameter parsing code\n4. Generate implementation call\n5. Generate return value serialization\n6. Wrap everything in panic handler\n\n**Code Template:**\n```rust\n#[no_mangle]\npub unsafe extern \"C\" fn {ffi_name}(\n    {params},\n    error: *mut *mut c_char,\n) -> {return_type} {\n    keyrx_ffi_runtime::ffi_wrapper(error, || {\n        {parse_params}\n        {call_impl}\n        {serialize_result}\n    })\n}\n```\n\n### Component 5: Type Mapper\n- **Purpose:** Convert contract types to Rust FFI types\n- **Interfaces:**\n  - `map_contract_type_to_ffi(contract_type: &str) -> TokenStream`\n  - `generate_parser_for_type(contract_type: &str, param_name: &str) -> TokenStream`\n  - `generate_serializer_for_type(contract_type: &str) -> TokenStream`\n- **Dependencies:** `quote`\n- **Reuses:** Type mapping rules from validation\n\n**Type Mapping:**\n| Contract Type | FFI Parameter | Parser | Serializer |\n|--------------|---------------|--------|------------|\n| `string` | `*const c_char` | `parse_c_string(ptr, name)?` | `string_to_c_char(s)` |\n| `int` | `i32` | Direct pass | Direct pass |\n| `bool` | `bool` | Direct pass | Direct pass |\n| `void` | - | - | Return `()` |\n| Custom struct | `*const c_char` | `serde_json::from_str(&parse_c_string(ptr, name)?)?` | `serialize_to_c_string(&value)?` |\n| `Vec<T>` | `*const c_char` | `serde_json::from_str(&parse_c_string(ptr, name)?)?` | `serialize_to_c_string(&vec)?` |\n\n## Data Models\n\n### MacroContext\n```rust\nstruct MacroContext {\n    domain: String,\n    contract: FfiContract,\n    impl_items: Vec<ImplItemFn>,\n}\n```\n\n### GeneratedFunction\n```rust\nstruct GeneratedFunction {\n    ffi_name: Ident,\n    params: Vec<FnArg>,\n    return_type: ReturnType,\n    body: Block,\n}\n```\n\n### TypeMapping\n```rust\nenum TypeMapping {\n    Direct { rust_type: Type },\n    CString { requires_parse: bool },\n    Json { inner_type: Type },\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Contract File Not Found**\n   - **Handling:** Compile error with clear message about missing contract\n   - **User Impact:** `error: Contract file not found: core/src/ffi/contracts/config.ffi-contract.json`\n\n2. **Invalid Contract JSON**\n   - **Handling:** Compile error with JSON parse error\n   - **User Impact:** `error: Invalid contract JSON: expected '}' at line 45`\n\n3. **Implementation Function Missing**\n   - **Handling:** Compile error indicating which contract function has no implementation\n   - **User Impact:** `error: No implementation found for contract function 'save_profile'`\n\n4. **Type Mismatch Between Contract and Impl**\n   - **Handling:** Compile error with type mismatch details\n   - **User Impact:** `error: Implementation returns 'Result<Profile, String>' but contract expects 'void'`\n\n5. **Runtime Panic in Implementation**\n   - **Handling:** Catch panic, set error pointer, return null/error code\n   - **User Impact:** Dart receives `FfiException: Panic: index out of bounds`\n\n6. **Serialization Error**\n   - **Handling:** Set error pointer with serialization error message\n   - **User Impact:** Dart receives `FfiException: Failed to serialize result`\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Macro Expansion Tests**: Use `trybuild` to test macro expansion\n  - Input: Rust code with `#[keyrx_ffi]`\n  - Output: Verify generated code compiles\n  - Cases: Valid cases, error cases (missing contract, type mismatches)\n\n- **Runtime Helper Tests**: Test marshaling functions\n  - `parse_c_string`: Test null handling, valid strings, invalid UTF-8\n  - `serialize_to_c_string`: Test serialization of various types\n  - `ffi_wrapper`: Test panic catching, error handling\n\n### Integration Testing\n\n- **End-to-End Generation**: Test full macro expansion with real contracts\n  - Create sample contract\n  - Write implementation\n  - Verify generated FFI function works correctly\n  - Call from \"FFI\" side and verify results\n\n- **Error Propagation**: Test that errors flow correctly\n  - Implementation returns `Err`\n  - Verify error pointer is set\n  - Verify null is returned\n\n### End-to-End Testing\n\n- **Dart Integration**: Test generated FFI from Flutter\n  - Call generated FFI functions from Dart\n  - Verify results are correct\n  - Test error scenarios\n\n## Implementation Phases\n\n### Phase 1: Runtime Library\n1. Create `keyrx_ffi_runtime` crate\n2. Implement marshaling utilities\n3. Implement panic handling\n4. Unit test all runtime functions\n\n### Phase 2: Basic Macro\n1. Create `keyrx_ffi_macro` crate\n2. Implement attribute parsing (`domain` parameter)\n3. Load contract files\n4. Validate contract exists\n\n### Phase 3: Code Generation\n1. Implement type mapping\n2. Generate parameter parsing\n3. Generate function calls\n4. Generate return serialization\n\n### Phase 4: Advanced Features\n1. Handle `void` returns\n2. Handle optional parameters\n3. Handle various error types\n4. Support custom serialization\n\n### Phase 5: Testing & Documentation\n1. Add `trybuild` tests\n2. Test with real contracts\n3. Document macro usage\n4. Migration guide from manual FFI\n\n## Migration Strategy\n\n### Step-by-Step Migration\n\n1. **Keep Existing FFI Functions**: Don't break existing code\n2. **Add Macro to One Domain**: Start with `config` domain\n3. **Test Thoroughly**: Ensure generated code works identically\n4. **Deprecate Manual Functions**: Mark old functions as deprecated\n5. **Migrate Remaining Domains**: Apply macro to other domains\n6. **Remove Manual Code**: Delete old FFI boilerplate\n\n### Compatibility\n\n- Generated functions have same signatures as manual functions\n- No breaking changes to Dart bindings\n- Can run both side-by-side during migration\n",
  "fileStats": {
    "size": 12396,
    "lines": 369,
    "lastModified": "2025-12-11T11:14:39.192Z"
  },
  "comments": []
}