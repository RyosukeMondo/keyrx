{
  "id": "snapshot_1765450650483_c21quco07",
  "approvalId": "approval_1765450427641_laro5kkco",
  "approvalTitle": "Rust FFI Code Generation - Requirements",
  "version": 2,
  "timestamp": "2025-12-11T10:57:30.483Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe Rust FFI Code Generation feature eliminates manual FFI boilerplate by automatically generating `extern \"C\"` functions from JSON contracts using procedural macros. This makes it impossible to have missing functions or type mismatches, as the contract becomes the single source of truth for all FFI exports.\n\n**Current Problem**: Developers manually write FFI wrapper functions in `exports.rs`, handling JSON serialization, panic catching, and error pointer management. This is error-prone and leads to drift between contracts and implementations.\n\n**Solution**: Implement a `#[keyrx_ffi]` procedural macro that reads JSON contracts and generates FFI wrappers automatically. Developers only write the core implementation logic; the macro handles all FFI concerns.\n\n## Alignment with Product Vision\n\nThis feature embodies the \"Logic > Configuration\" principle by treating contracts as executable specifications. It supports the \"Safety First\" pillar by making FFI errors impossible through compile-time guarantees. By eliminating 300+ lines of repetitive FFI boilerplate, it allows developers to focus on core remapping logic rather than FFI plumbing.\n\nThis is the culmination of the contract-driven development plan, enabling KeyRx to scale FFI operations without increasing maintenance burden.\n\n## Requirements\n\n### Requirement 1: Procedural Macro for FFI Generation\n\n**User Story:** As a developer, I want to annotate my implementation with `#[keyrx_ffi]`, so that FFI wrappers are generated automatically without manual boilerplate.\n\n#### Acceptance Criteria\n\n1. WHEN I annotate a module with `#[keyrx_ffi(domain = \"config\")]` THEN it SHALL:\n   - Load `config.ffi-contract.json` at compile time\n   - Generate `extern \"C\"` functions for all contract entries\n   - Link generated functions to the annotated implementation\n2. WHEN the contract file is missing THEN compilation SHALL fail with: \"Contract file not found: {path}\"\n3. WHEN the contract JSON is invalid THEN compilation SHALL fail with: \"Invalid contract JSON: {error}\"\n4. WHEN the implementation function is missing THEN compilation SHALL fail with: \"No implementation found for contract function `{name}`\"\n\n### Requirement 2: Automatic Type Marshaling\n\n**User Story:** As a developer, I want automatic conversion between Rust types and FFI types, so that I can work with safe Rust types in my implementation.\n\n#### Acceptance Criteria\n\n1. WHEN a contract parameter is `string` THEN the macro SHALL:\n   - Accept `*const c_char` in the FFI signature\n   - Convert to `String` or `&str` for the implementation\n   - Handle null pointers safely\n2. WHEN a contract return type is a custom struct THEN the macro SHALL:\n   - Serialize the result to JSON\n   - Allocate a C string\n   - Return `*const c_char`\n3. WHEN marshaling fails (invalid UTF-8, serialization error) THEN it SHALL populate the error pointer with a descriptive message\n4. IF the contract specifies `nullable: true` THEN the macro SHALL handle `null` inputs gracefully\n\n### Requirement 3: Panic and Error Handling\n\n**User Story:** As a developer, I want automatic panic catching in FFI boundaries, so that Rust panics don't crash the Flutter application.\n\n#### Acceptance Criteria\n\n1. WHEN the implementation panics THEN the generated FFI wrapper SHALL:\n   - Catch the panic using `catch_unwind`\n   - Populate the error pointer with: \"Panic: {message}\"\n   - Return a safe default value (null pointer or error code)\n2. WHEN the implementation returns `Result<T, E>` THEN the macro SHALL:\n   - On `Ok(value)`: Return the marshaled value, set error pointer to null\n   - On `Err(e)`: Populate error pointer with `e.to_string()`, return null/error code\n3. WHEN the error pointer is null THEN errors SHALL be logged but not dereferenced\n\n### Requirement 4: Contract-Driven Signatures\n\n**User Story:** As a developer, I want FFI function signatures to exactly match the contract, so that validation passes automatically.\n\n#### Acceptance Criteria\n\n1. WHEN the contract specifies `parameters: [{name: \"profile_id\", type: \"string\"}]` THEN the FFI signature SHALL be:\n   ```rust\n   extern \"C\" fn keyrx_domain_function(profile_id: *const c_char, error: *mut *mut c_char) -> *const c_char\n   ```\n2. WHEN the contract specifies `returns: \"void\"` THEN the FFI signature SHALL return `()` and omit JSON serialization\n3. WHEN parameter order changes in the contract THEN the generated signature SHALL update automatically\n4. WHEN the implementation signature doesn't match the contract THEN compilation SHALL fail with a type mismatch error\n\n### Requirement 5: Developer-Friendly Implementation Interface\n\n**User Story:** As a developer, I want to write clean Rust implementations without FFI concerns, so that my code is maintainable and testable.\n\n#### Acceptance Criteria\n\n1. WHEN implementing a contract function THEN I SHALL write:\n   ```rust\n   #[keyrx_ffi(domain = \"config\")]\n   impl ConfigFfi {\n       fn save_profile(profile_id: String, profile: HardwareProfile) -> Result<HardwareProfile, String> {\n           // Pure Rust implementation\n       }\n   }\n   ```\n2. WHEN the macro expands THEN it SHALL generate:\n   ```rust\n   #[no_mangle]\n   pub unsafe extern \"C\" fn keyrx_config_save_profile(\n       profile_id: *const c_char,\n       profile: *const c_char,\n       error: *mut *mut c_char\n   ) -> *const c_char {\n       // Generated marshaling code\n   }\n   ```\n3. WHEN testing my implementation THEN I SHALL call the Rust function directly without FFI layer\n4. WHEN the contract updates THEN I SHALL update my implementation signature to match, and the macro will regenerate the FFI wrapper\n\n### Requirement 6: Code Generation Observability\n\n**User Story:** As a developer, I want to see the generated FFI code, so that I can debug issues and understand what the macro produces.\n\n#### Acceptance Criteria\n\n1. WHEN compiling with `RUSTFLAGS=\"--cfg keyrx_ffi_debug\"` THEN the macro SHALL emit the generated code to `target/keyrx_ffi_generated.rs`\n2. WHEN a generation error occurs THEN the macro SHALL provide a span pointing to the annotated implementation\n3. WHEN the contract changes THEN recompilation SHALL regenerate the FFI code (no stale generated code)\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Separation of Concerns**: Procedural macro in `keyrx_ffi_macro` crate, runtime helpers in `keyrx_ffi_runtime` crate\n- **Single Responsibility**: Macro handles code generation only; runtime crate handles marshaling and error handling\n- **Testability**: Generated code SHALL be deterministic and testable via `trybuild` tests\n\n### Performance\n\n- Macro expansion SHALL complete in under 1 second per domain\n- Generated code SHALL have zero runtime overhead compared to hand-written FFI\n- JSON serialization SHALL use `serde_json` with optimizations enabled\n\n### Reliability\n\n- Generated code SHALL never introduce memory leaks (all allocations properly freed)\n- Generated code SHALL be memory-safe (no undefined behavior)\n- Panic handling SHALL never cause undefined behavior or crashes\n\n### Usability\n\n- Macro errors SHALL provide clear guidance on how to fix implementation issues\n- Documentation SHALL include migration guide from manual FFI to macro-based FFI\n- Examples SHALL cover common patterns (Result types, optional parameters, custom types)\n\n### Security\n\n- Generated code SHALL validate all input pointers before dereferencing\n- Null checks SHALL be performed on all FFI parameters\n- Buffer overflows SHALL be impossible (safe conversions only)\n",
  "fileStats": {
    "size": 7547,
    "lines": 149,
    "lastModified": "2025-12-11T10:53:36.863Z"
  },
  "comments": []
}