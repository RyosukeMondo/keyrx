{
  "id": "snapshot_1766587950271_85es13w7k",
  "approvalId": "approval_1766587010370_ksnay4858",
  "approvalTitle": "Tasks: Windows Platform Support",
  "version": 2,
  "timestamp": "2025-12-24T14:52:30.271Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks: Windows Platform Support\n\n**Spec Name**: windows-platform-support\n**Created**: 2024-12-24\n**Status**: Draft\n**Version**: 0.1.0\n\n---\n\n## Task Overview\n\n**Total Tasks**: 10\n**Estimated Duration**: 3 weeks\n**Dependencies**: keyrx_core (already implemented), keyrx_compiler (already implemented)\n\n---\n\n## Task Breakdown\n\n### Phase 1: Core Windows Hooks (Week 1)\n\n#### Task 1: Create Virtual Key Mapping Module\n\n- **Status**: [ ] Pending\n- **Priority**: P0 (Critical)\n- **Estimated Effort**: 2 days\n- **Files**:\n  - `keyrx_daemon/src/platform/windows/keycode.rs` (NEW)\n  - `keyrx_daemon/src/platform/windows/mod.rs` (MODIFIED)\n- **Requirements**: US-2.1, US-2.2\n- **Dependencies**: None\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Rust systems programmer with Win32 API expertise\n\nTask: Create bidirectional mapping between Windows Virtual Key codes (VK_*) and KeyRx KeyCode enum. Implement compile-time constant arrays for O(1) lookup performance.\n\nContext:\n- Windows provides Virtual Key codes (u32 values like VK_A = 0x41)\n- KeyRx uses platform-agnostic KeyCode enum (defined in keyrx_core)\n- Need bidirectional mapping: VK→KeyCode for input, KeyCode→VK for output\n\nImplementation Requirements:\n1. Create `keyrx_daemon/src/platform/windows/keycode.rs`\n2. Define constant array VK_TO_KEYCODE: [Option<KeyCode>; 256]\n   - Index by VK code, returns corresponding KeyCode\n   - Use None for unmapped VK codes\n3. Define constant lookup table KEYCODE_TO_VK using phf_map! macro\n   - Maps KeyCode → VK code\n4. Implement functions:\n   ```rust\n   pub fn vk_to_keycode(vk: u32) -> Option<KeyCode>\n   pub fn keycode_to_vk(kc: KeyCode) -> Option<u32>\n   ```\n5. Support all standard keys:\n   - Letters A-Z (VK_A through VK_Z)\n   - Numbers 0-9 (VK_0 through VK_9)\n   - Modifiers (VK_SHIFT, VK_CONTROL, VK_MENU, VK_LWIN, VK_RWIN)\n   - Function keys F1-F24\n   - Arrow keys, Home/End/PgUp/PgDn\n   - Special keys (Space, Enter, Tab, Backspace, Delete, Escape)\n\nRestrictions:\n- Use const arrays (no HashMap or runtime initialization)\n- No heap allocation\n- Handle unmapped VK codes gracefully (return None, don't panic)\n- Follow existing codebase naming conventions (snake_case for functions)\n\n_Leverage:\n- keyrx_core::config::KeyCode enum (already defined)\n- windows::Win32::UI::Input::KeyboardAndMouse::* constants\n- phf crate for compile-time perfect hash maps\n\n_Requirements: US-2.1 (Virtual Key mapping), US-2.2 (Comprehensive tests)\n\nSuccess Criteria:\n- All standard VK codes mapped to KeyCode\n- vk_to_keycode(0x41) returns Some(KeyCode::A)\n- keycode_to_vk(KeyCode::A) returns Some(0x41)\n- Unmapped codes return None (no panic)\n- Roundtrip: vk_to_keycode(vk).and_then(keycode_to_vk) == Some(vk) for all valid keys\n\nInstructions:\n1. Mark this task as in-progress in tasks.md: Change [ ] to [-]\n2. Implement the code according to requirements above\n3. Write unit tests for all mappings\n4. Run tests: cargo test --target x86_64-pc-windows-msvc\n5. Log implementation with log-implementation tool:\n   - Include artifacts: functions created, test coverage\n   - Document: All VK codes mapped, bidirectional lookup implemented\n6. Mark task as complete in tasks.md: Change [-] to [x]\n```\n\n---\n\n#### Task 2: Implement Windows Keyboard Hook\n\n- **Status**: [ ] Pending\n- **Priority**: P0 (Critical)\n- **Estimated Effort**: 3 days\n- **Files**:\n  - `keyrx_daemon/src/platform/windows/hook.rs` (NEW)\n  - `keyrx_daemon/src/platform/windows/mod.rs` (MODIFIED)\n- **Requirements**: US-1.1, US-1.2\n- **Dependencies**: Task 1\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Rust systems programmer with Win32 API and unsafe code expertise\n\nTask: Implement Windows low-level keyboard hook (WH_KEYBOARD_LL) using SetWindowsHookEx API. Install hook on main thread, route events to processing thread via lock-free channel.\n\nContext:\n- Windows requires hooks to run on main thread with message loop\n- Hook callback must return <50μs to avoid input lag\n- Events need to be sent to separate processing thread for core logic\n\nImplementation Requirements:\n1. Create `keyrx_daemon/src/platform/windows/hook.rs`\n2. Define `WindowsKeyboardHook` struct:\n   ```rust\n   pub struct WindowsKeyboardHook {\n       hook_handle: HHOOK,\n       event_sender: Sender<RawKeyEvent>,\n   }\n   ```\n3. Implement constructor:\n   ```rust\n   pub fn new(event_sender: Sender<RawKeyEvent>) -> Result<Self, HookError>\n   ```\n   - Calls SetWindowsHookEx(WH_KEYBOARD_LL, callback, hInstance, 0)\n   - Stores event_sender in thread-local storage for callback access\n   - Returns hook handle\n4. Implement hook callback:\n   ```rust\n   unsafe extern \"system\" fn keyboard_proc(\n       code: i32,\n       wparam: WPARAM,\n       lparam: LPARAM,\n   ) -> LRESULT\n   ```\n   - Check code >= 0 (process event)\n   - Extract KBDLLHOOKSTRUCT from lparam\n   - Ignore injected events (LLKHF_INJECTED flag)\n   - Convert to RawKeyEvent (platform-neutral)\n   - try_send to event_sender (non-blocking)\n   - Return 1 to block original event\n5. Implement Drop trait:\n   ```rust\n   impl Drop for WindowsKeyboardHook {\n       fn drop(&mut self) {\n           unsafe { UnhookWindowsHookEx(self.hook_handle); }\n       }\n   }\n   ```\n\nRestrictions:\n- No heap allocation in callback (use try_send, not send)\n- Callback must be thread-safe (uses thread-local storage)\n- Must clean up hook even on panic (Drop trait)\n- Follow RAII pattern (hook lifetime tied to struct)\n\n_Leverage:\n- windows::Win32::UI::WindowsAndMessaging::*\n- crossbeam_channel::Sender for lock-free communication\n- keyrx_core::runtime::event::EventType\n\n_Requirements: US-1.1 (Hook installation), US-1.2 (Clean cleanup)\n\nSuccess Criteria:\n- SetWindowsHookEx returns valid handle (not NULL)\n- Keyboard events routed to callback\n- Injected events ignored (no infinite loop)\n- Hook uninstalled on drop\n- No crashes, no resource leaks\n\nInstructions:\n1. Mark this task as in-progress in tasks.md: Change [ ] to [-]\n2. Implement hook installation and callback\n3. Write tests (use mock sender to verify events sent)\n4. Test cleanup: create hook, drop it, verify no leaks\n5. Log implementation with log-implementation tool\n6. Mark task as complete: Change [-] to [x]\n```\n\n---\n\n#### Task 3: Implement Event Injection\n\n- **Status**: [ ] Pending\n- **Priority**: P0 (Critical)\n- **Estimated Effort**: 2 days\n- **Files**:\n  - `keyrx_daemon/src/platform/windows/inject.rs` (NEW)\n- **Requirements**: US-3.1, US-3.2\n- **Dependencies**: Task 1\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Rust systems programmer with Win32 input API expertise\n\nTask: Implement keyboard event injection using SendInput API. Convert KeyRx KeyCode to Windows Virtual Key codes and inject events with proper modifier handling.\n\nContext:\n- After remapping, need to inject output key into Windows input stream\n- SendInput API creates synthetic keyboard events\n- Modifiers (Shift, Ctrl, Alt, Win) must be injected separately\n\nImplementation Requirements:\n1. Create `keyrx_daemon/src/platform/windows/inject.rs`\n2. Define EventInjector struct:\n   ```rust\n   pub struct EventInjector;\n   ```\n3. Implement injection method:\n   ```rust\n   pub fn inject_key_event(\n       &self,\n       keycode: KeyCode,\n       event_type: EventType,\n       modifiers: ModifierState,\n   ) -> Result<(), InjectionError>\n   ```\n4. Implementation steps:\n   - Convert KeyCode → VK code using keycode_to_vk()\n   - Create INPUT structure with INPUT_KEYBOARD type\n   - Set KEYBDINPUT fields:\n     - wVk: Virtual Key code\n     - dwFlags: KEYEVENTF_KEYUP for Release, 0 for Press\n   - Inject modifiers first (if needed):\n     - Shift down, Ctrl down, Alt down, Win down\n   - Inject main key\n   - Release in reverse order\n   - Call SendInput with array of INPUT structures\n5. Error handling:\n   - Return InjectionError::UnmappedKey if keycode has no VK mapping\n   - Return InjectionError::SendInputFailed if SendInput returns 0\n\nRestrictions:\n- Do not inject events marked as KEYEVENTF_UNICODE (scan codes only)\n- Mark injected events with KEYEVENTF_SCANCODE to avoid hook re-processing\n- Handle extended keys (arrows, etc.) with KEYEVENTF_EXTENDEDKEY flag\n\n_Leverage:\n- windows::Win32::UI::Input::KeyboardAndMouse::SendInput\n- Task 1: keycode_to_vk() function\n- keyrx_core::runtime::event::{EventType, KeyEvent}\n\n_Requirements: US-3.1 (Event injection), US-3.2 (Modifier handling)\n\nSuccess Criteria:\n- inject_key_event(KeyCode::A, Press, ...) sends VK_A press\n- Modifiers injected before main key\n- Release events inject KEYEVENTF_KEYUP flag\n- SendInput returns non-zero (success)\n\nInstructions:\n1. Mark this task as in-progress in tasks.md\n2. Implement EventInjector with SendInput\n3. Write unit tests for simple keys and modifiers\n4. Test modifier ordering: Shift+A should inject Shift down, A down, A up, Shift up\n5. Log implementation with log-implementation tool\n6. Mark task as complete in tasks.md\n```\n\n---\n\n### Phase 2: Platform Integration (Week 2)\n\n#### Task 4: Implement InputDevice Trait for Windows\n\n- **Status**: [ ] Pending\n- **Priority**: P0 (Critical)\n- **Estimated Effort**: 2 days\n- **Files**:\n  - `keyrx_daemon/src/platform/windows/input.rs` (NEW)\n  - `keyrx_daemon/src/platform/mod.rs` (MODIFIED)\n- **Requirements**: US-5.1\n- **Dependencies**: Task 1, Task 2\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Rust platform abstraction developer\n\nTask: Implement InputDevice trait for Windows, integrating keyboard hook with platform-agnostic event interface.\n\nContext:\n- InputDevice trait (defined in keyrx_daemon/src/platform/mod.rs) provides platform-agnostic input\n- Windows implementation receives events from hook callback via channel\n- Need to convert RawKeyEvent → KeyEvent (platform-neutral)\n\nImplementation Requirements:\n1. Create `keyrx_daemon/src/platform/windows/input.rs`\n2. Define WindowsKeyboardInput struct:\n   ```rust\n   pub struct WindowsKeyboardInput {\n       hook: WindowsKeyboardHook,\n       event_rx: Receiver<RawKeyEvent>,\n   }\n   ```\n3. Implement InputDevice trait:\n   ```rust\n   impl InputDevice for WindowsKeyboardInput {\n       fn next_event(&mut self) -> Result<KeyEvent, DeviceError> {\n           // Receive RawKeyEvent from hook\n           // Convert VK → KeyCode\n           // Create KeyEvent\n       }\n\n       fn grab(&mut self) -> Result<(), DeviceError> {\n           // No-op (Windows hook is implicitly exclusive)\n       }\n\n       fn release(&mut self) -> Result<(), DeviceError> {\n           // No-op (cleanup happens in Drop)\n       }\n   }\n   ```\n4. Conversion logic:\n   - Call event_rx.recv() (blocking)\n   - vk_to_keycode(raw_event.vk_code) → KeyCode\n   - Determine EventType from flags (LLKHF_UP)\n   - Create KeyEvent::new(keycode, event_type, timestamp)\n\nRestrictions:\n- Do not create new hook inside next_event() (reuse existing)\n- Handle EndOfStream when channel closed\n- Map unmapped VK codes to DeviceError::UnmappedKey\n\n_Leverage:\n- Task 1: vk_to_keycode() function\n- Task 2: WindowsKeyboardHook\n- keyrx_daemon/src/platform/mod.rs: InputDevice trait\n\n_Requirements: US-5.1 (Platform abstraction)\n\nSuccess Criteria:\n- WindowsKeyboardInput implements InputDevice trait\n- next_event() returns KeyEvent when key pressed\n- Unmapped VK codes return error (not panic)\n- Channel close returns EndOfStream\n\nInstructions:\n1. Mark this task as in-progress in tasks.md\n2. Implement InputDevice trait\n3. Write integration test: create input, send RawKeyEvent, verify KeyEvent returned\n4. Log implementation with log-implementation tool\n5. Mark task as complete in tasks.md\n```\n\n---\n\n#### Task 5: Implement OutputDevice Trait for Windows\n\n- **Status**: [ ] Pending\n- **Priority**: P0 (Critical)\n- **Estimated Effort**: 1 day\n- **Files**:\n  - `keyrx_daemon/src/platform/windows/output.rs` (NEW)\n  - `keyrx_daemon/src/platform/mod.rs` (MODIFIED)\n- **Requirements**: US-5.1\n- **Dependencies**: Task 3\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Rust platform abstraction developer\n\nTask: Implement OutputDevice trait for Windows, wrapping EventInjector in platform-agnostic interface.\n\nContext:\n- OutputDevice trait provides send_event() method\n- Windows implementation uses EventInjector (SendInput API)\n\nImplementation Requirements:\n1. Create `keyrx_daemon/src/platform/windows/output.rs`\n2. Define WindowsKeyboardOutput struct:\n   ```rust\n   pub struct WindowsKeyboardOutput {\n       injector: EventInjector,\n   }\n   ```\n3. Implement OutputDevice trait:\n   ```rust\n   impl OutputDevice for WindowsKeyboardOutput {\n       fn send_event(&mut self, event: KeyEvent) -> Result<(), DeviceError> {\n           self.injector.inject_key_event(\n               event.keycode,\n               event.event_type,\n               ModifierState::default(), // TODO: Extract from event\n           ).map_err(|e| DeviceError::InjectionFailed(e.to_string()))\n       }\n   }\n   ```\n\nRestrictions:\n- Error conversion: InjectionError → DeviceError\n- No state modification (stateless output)\n\n_Leverage:\n- Task 3: EventInjector\n- keyrx_daemon/src/platform/mod.rs: OutputDevice trait\n\n_Requirements: US-5.1 (Platform abstraction)\n\nSuccess Criteria:\n- WindowsKeyboardOutput implements OutputDevice\n- send_event() successfully injects events\n- Errors mapped to DeviceError variants\n\nInstructions:\n1. Mark this task as in-progress in tasks.md\n2. Implement OutputDevice trait\n3. Write test: create output, send KeyEvent, verify SendInput called\n4. Log implementation with log-implementation tool\n5. Mark task as complete in tasks.md\n```\n\n---\n\n### Phase 3: System Tray (Week 2)\n\n#### Task 6: Implement System Tray Icon\n\n- **Status**: [ ] Pending\n- **Priority**: P1 (High)\n- **Estimated Effort**: 2 days\n- **Files**:\n  - `keyrx_daemon/src/windows/tray.rs` (NEW)\n  - `Cargo.toml` (MODIFIED - add tray-icon dependency)\n- **Requirements**: US-4.1, US-4.2\n- **Dependencies**: None\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Rust GUI developer with tray icon experience\n\nTask: Implement Windows system tray icon using tray-icon crate. Provide menu for daemon control (Reload Config, Exit).\n\nContext:\n- System tray icon provides UI for users who don't want CLI\n- Menu allows configuration reload without restart\n- Clicking Exit triggers graceful shutdown\n\nImplementation Requirements:\n1. Add dependency to Cargo.toml:\n   ```toml\n   [target.'cfg(windows)'.dependencies]\n   tray-icon = \"0.14\"\n   ```\n2. Create `keyrx_daemon/src/windows/tray.rs`\n3. Define TrayIconController struct:\n   ```rust\n   pub struct TrayIconController {\n       _tray_icon: TrayIcon,\n       menu_rx: Receiver<TrayMenuEvent>,\n   }\n\n   pub enum TrayMenuEvent {\n       ReloadConfig,\n       Exit,\n   }\n   ```\n4. Implement constructor:\n   ```rust\n   pub fn new() -> Result<Self, TrayError> {\n       // Create menu\n       let menu = Menu::new();\n       menu.append(MenuItem::new(\"Reload Config\", true, None))?;\n       menu.append(MenuItem::new(\"Exit\", true, None))?;\n\n       // Create tray icon\n       let tray_icon = TrayIconBuilder::new()\n           .with_menu(Box::new(menu))\n           .with_tooltip(\"KeyRx Daemon\")\n           .with_icon(Icon::from_rgba(rgba_data, width, height)?)\n           .build()?;\n\n       // Setup event channel\n       let (menu_tx, menu_rx) = crossbeam_channel::unbounded();\n\n       Ok(Self { _tray_icon: tray_icon, menu_rx })\n   }\n   ```\n5. Implement event polling:\n   ```rust\n   pub fn poll_events(&mut self) -> Option<TrayMenuEvent>\n   ```\n\nRestrictions:\n- Use default icon if custom icon not available\n- Handle menu creation errors gracefully\n- Non-blocking event poll (use try_recv)\n\n_Leverage:\n- tray-icon crate documentation\n- crossbeam_channel for event delivery\n\n_Requirements: US-4.1 (Tray icon), US-4.2 (Context menu)\n\nSuccess Criteria:\n- Tray icon appears in Windows notification area\n- Right-click shows menu with \"Reload Config\" and \"Exit\"\n- Clicking menu items triggers TrayMenuEvent\n- Tooltip shows \"KeyRx Daemon\"\n\nInstructions:\n1. Mark this task as in-progress in tasks.md\n2. Implement TrayIconController\n3. Test: Run daemon, verify icon appears, verify menu works\n4. Log implementation with log-implementation tool\n5. Mark task as complete in tasks.md\n```\n\n---\n\n### Phase 4: Main Application (Week 2-3)\n\n#### Task 7: Integrate Components in Main Function\n\n- **Status**: [ ] Pending\n- **Priority**: P0 (Critical)\n- **Estimated Effort**: 2 days\n- **Files**:\n  - `keyrx_daemon/src/main.rs` (MODIFIED)\n  - `keyrx_daemon/src/platform/mod.rs` (MODIFIED)\n- **Requirements**: US-1.1, US-6.1\n- **Dependencies**: All previous tasks\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Rust systems integration developer\n\nTask: Integrate all Windows components in main() function. Setup event loop with hook, processor thread, tray icon, and graceful shutdown.\n\nContext:\n- Windows requires message loop on main thread (for hook)\n- Event processing runs on separate thread\n- Tray events polled in message loop\n- Ctrl+C and tray Exit both trigger shutdown\n\nImplementation Requirements:\n1. Modify `keyrx_daemon/src/main.rs`\n2. Add Windows-specific main logic:\n   ```rust\n   #[cfg(windows)]\n   fn handle_run_windows(config_path: &Path, _debug: bool) -> Result<(), (i32, String)> {\n       // Load config\n       let config = load_config(config_path)?;\n\n       // Setup channels\n       let (event_tx, event_rx) = crossbeam_channel::unbounded();\n\n       // Create components\n       let hook = WindowsKeyboardHook::new(event_tx)?;\n       let input = WindowsKeyboardInput::new(hook, event_rx);\n       let output = WindowsKeyboardOutput::new();\n       let tray = TrayIconController::new()?;\n\n       // Spawn processor thread\n       let processor_handle = std::thread::spawn(move || {\n           event_processor(input, output, config)\n       });\n\n       // Main message loop\n       run_message_loop_with_tray(tray)?;\n\n       // Cleanup\n       processor_handle.join().unwrap();\n       Ok(())\n   }\n   ```\n3. Implement message loop:\n   ```rust\n   fn run_message_loop_with_tray(mut tray: TrayIconController) -> Result<()> {\n       unsafe {\n           let mut msg = MSG::default();\n           while GetMessage(&mut msg, None, 0, 0).as_bool() {\n               // Check tray events\n               if let Some(event) = tray.poll_events() {\n                   match event {\n                       TrayMenuEvent::ReloadConfig => {\n                           // TODO: Signal config reload\n                       }\n                       TrayMenuEvent::Exit => {\n                           PostQuitMessage(0);\n                       }\n                   }\n               }\n\n               TranslateMessage(&msg);\n               DispatchMessage(&msg);\n           }\n       }\n       Ok(())\n   }\n   ```\n\nRestrictions:\n- Message loop must run on main thread (Windows requirement)\n- Event processing must run on separate thread (avoid blocking hook)\n- Clean shutdown on Ctrl+C (install signal handler)\n\n_Leverage:\n- Tasks 2, 4, 5, 6 (all components)\n- windows::Win32::UI::WindowsAndMessaging::*\n\n_Requirements: US-1.1 (Hook integration), US-6.1 (Config compatibility)\n\nSuccess Criteria:\n- Running `keyrx_daemon.exe run --config test.krx` starts daemon\n- Hook installed, events processed, remapping works\n- Tray icon appears and responds to clicks\n- Ctrl+C triggers clean shutdown\n- No resource leaks on exit\n\nInstructions:\n1. Mark this task as in-progress in tasks.md\n2. Integrate all components in main()\n3. Test end-to-end: start daemon, press keys, verify remapping\n4. Test shutdown: Ctrl+C, verify clean exit\n5. Log implementation with log-implementation tool\n6. Mark task as complete in tasks.md\n```\n\n---\n\n### Phase 5: Testing & Documentation (Week 3)\n\n#### Task 8: Write Comprehensive Tests\n\n- **Status**: [ ] Pending\n- **Priority**: P1 (High)\n- **Estimated Effort**: 3 days\n- **Files**:\n  - `keyrx_daemon/src/platform/windows/tests.rs` (NEW)\n  - `keyrx_daemon/tests/windows_integration.rs` (NEW)\n- **Requirements**: US-7.1\n- **Dependencies**: All implementation tasks\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Rust test engineer with property-based testing expertise\n\nTask: Write comprehensive unit and integration tests for Windows platform. Achieve ≥95% code coverage for platform/windows/*.\n\nContext:\n- Windows-specific code needs testing on Windows target\n- Some tests require actual Windows APIs (not mockable)\n- Aim for 95% coverage to ensure reliability\n\nImplementation Requirements:\n1. Create unit tests in each module:\n   - `keycode.rs`: Test all VK mappings, roundtrip conversion\n   - `hook.rs`: Test hook installation/cleanup (limited without GUI)\n   - `inject.rs`: Test event injection (may require admin)\n   - `input.rs`, `output.rs`: Test trait implementations\n\n2. Create integration tests:\n   - Test end-to-end flow: hook → process → inject\n   - Test config loading from .krx file\n   - Test tray icon creation (visual verification)\n\n3. Test categories:\n   - **Unit tests**: Individual function correctness\n   - **Integration tests**: Component interaction\n   - **Property tests**: Use proptest for VK mapping invariants\n\n4. Example property test:\n   ```rust\n   proptest! {\n       #[test]\n       fn test_vk_roundtrip(vk in 0x08u32..=0xFE) {\n           if let Some(kc) = vk_to_keycode(vk) {\n               let vk2 = keycode_to_vk(kc).unwrap();\n               assert_eq!(vk, vk2, \"Roundtrip failed for VK {:#x}\", vk);\n           }\n       }\n   }\n   ```\n\nRestrictions:\n- Tests must run in CI (Windows runner required)\n- Avoid tests requiring user interaction (automated only)\n- Mock what cannot be tested directly (SendInput result)\n\n_Leverage:\n- proptest crate for property-based tests\n- Existing Linux tests as reference (keyrx_daemon/tests/)\n\n_Requirements: US-7.1 (Automated tests)\n\nSuccess Criteria:\n- cargo test --target x86_64-pc-windows-msvc passes all tests\n- Code coverage ≥95% for platform/windows/*\n- All VK codes tested, all edge cases covered\n\nInstructions:\n1. Mark this task as in-progress in tasks.md\n2. Write unit tests for each module\n3. Write integration tests for end-to-end flow\n4. Run tests, verify coverage with cargo tarpaulin (if available on Windows)\n5. Log implementation with log-implementation tool\n6. Mark task as complete in tasks.md\n```\n\n---\n\n#### Task 9: Update Documentation\n\n- **Status**: [ ] Pending\n- **Priority**: P2 (Medium)\n- **Estimated Effort**: 1 day\n- **Files**:\n  - `README.md` (MODIFIED)\n  - `docs/user-guide/windows-setup.md` (NEW)\n  - `CHANGELOG.md` (MODIFIED)\n- **Requirements**: NFR-2\n- **Dependencies**: All implementation tasks\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: Technical documentation writer\n\nTask: Update documentation to reflect Windows platform support. Create Windows setup guide, update README with platform badges.\n\nImplementation Requirements:\n1. Update `README.md`:\n   - Change Windows badge from \"Planned\" to \"Supported\"\n   - Add Windows installation instructions\n   - Update platform support section\n\n2. Create `docs/user-guide/windows-setup.md`:\n   - Installation: Download .exe from GitHub releases\n   - Configuration: Same .krx files as Linux\n   - Running: `keyrx_daemon.exe run --config my-config.krx`\n   - Tray icon usage: Right-click menu\n   - Troubleshooting:\n     - Hook installation failures (check for conflicting software)\n     - Anti-cheat compatibility issues\n     - Secure desktop limitations (UAC prompts)\n\n3. Update `CHANGELOG.md`:\n   - Add v0.2.0 section with Windows support\n   - List all new features:\n     - Windows keyboard hooks (low-level)\n     - System tray icon\n     - Same .krx config files\n     - Feature parity with Linux\n\nRestrictions:\n- Follow existing documentation style\n- Include code examples for common tasks\n- Add FAQ section for Windows-specific issues\n\n_Leverage:\n- docs/user-guide/linux-setup.md as template\n- docs/user-guide/dsl-manual.md for config examples\n\n_Requirements: NFR-2 (Compatibility documentation)\n\nSuccess Criteria:\n- README accurately reflects Windows support\n- Windows setup guide is complete and tested\n- CHANGELOG lists all v0.2.0 changes\n- Documentation reviewed for accuracy\n\nInstructions:\n1. Mark this task as in-progress in tasks.md\n2. Update README, create windows-setup.md, update CHANGELOG\n3. Review with user (submit for approval if needed)\n4. Log implementation with log-implementation tool\n5. Mark task as complete in tasks.md\n```\n\n---\n\n#### Task 10: Verify CI/CD for Windows Builds\n\n- **Status**: [ ] Pending\n- **Priority**: P2 (Medium)\n- **Estimated Effort**: 1 day\n- **Files**:\n  - `.github/workflows/ci.yml` (VERIFY)\n  - `.github/workflows/release.yml` (VERIFY)\n- **Requirements**: US-7.2\n- **Dependencies**: None (CI already exists)\n\n**_Prompt**:\n```\nImplement the task for spec windows-platform-support, first run spec-workflow-guide to get the workflow guide then implement the task:\n\nRole: DevOps engineer with GitHub Actions expertise\n\nTask: Verify GitHub Actions workflows build Windows binaries correctly. Ensure CI runs tests on Windows runner.\n\nContext:\n- `.github/workflows/ci.yml` runs tests on push\n- `.github/workflows/release.yml` builds binaries on version tags\n- Both workflows already have Windows jobs\n\nImplementation Requirements:\n1. Verify `ci.yml` includes Windows:\n   ```yaml\n   strategy:\n     matrix:\n       os: [ubuntu-latest, windows-latest]\n   ```\n2. Verify build command includes Windows feature:\n   ```yaml\n   - name: Build (Windows)\n     if: matrix.os == 'windows-latest'\n     run: cargo build --release --features windows\n   ```\n3. Verify tests run on Windows:\n   ```yaml\n   - name: Test (Windows)\n     if: matrix.os == 'windows-latest'\n     run: cargo test --features windows\n   ```\n4. Verify release.yml builds Windows artifact:\n   ```yaml\n   - name: Build (Windows)\n     run: |\n       cargo build --release --target x86_64-pc-windows-msvc --features windows\n       cp target/x86_64-pc-windows-msvc/release/keyrx_daemon.exe keyrx_daemon-windows.exe\n   ```\n\nRestrictions:\n- Do not modify workflow if already correct\n- Only update if Windows support missing\n\n_Leverage:\n- Existing CI/CD workflows (already set up for Linux)\n\n_Requirements: US-7.2 (CI/CD for Windows)\n\nSuccess Criteria:\n- CI runs on Windows runner\n- Tests pass on Windows\n- Release creates keyrx_daemon-windows.exe artifact\n- Artifact downloadable from GitHub releases\n\nInstructions:\n1. Mark this task as in-progress in tasks.md\n2. Review .github/workflows/*.yml files\n3. If missing Windows support, add it\n4. Trigger CI by pushing commit, verify Windows build succeeds\n5. Log implementation with log-implementation tool\n6. Mark task as complete in tasks.md\n```\n\n---\n\n## Task Dependencies\n\n```mermaid\ngraph TD\n    T1[Task 1: VK Mapping] --> T2[Task 2: Hook]\n    T1 --> T3[Task 3: Injection]\n    T2 --> T4[Task 4: InputDevice]\n    T3 --> T5[Task 5: OutputDevice]\n    T4 --> T7[Task 7: Integration]\n    T5 --> T7\n    T6[Task 6: Tray Icon] --> T7\n    T7 --> T8[Task 8: Tests]\n    T8 --> T9[Task 9: Docs]\n    T10[Task 10: CI/CD] -.-> T7\n```\n\n---\n\n## Progress Tracking\n\n- **Week 1**: Tasks 1-3 (Core hooks and mapping)\n- **Week 2**: Tasks 4-7 (Integration and tray icon)\n- **Week 3**: Tasks 8-10 (Testing, docs, CI verification)\n\n**Completion Criteria**:\n- All 10 tasks marked [x]\n- Tests pass on Windows (cargo test --features windows)\n- CI builds Windows binary\n- Documentation updated and reviewed\n- v0.2.0 ready for release\n\n---\n\n**Document Status**: Ready for Review\n",
  "fileStats": {
    "size": 28157,
    "lines": 907,
    "lastModified": "2025-12-24T14:36:50.161Z"
  },
  "comments": []
}