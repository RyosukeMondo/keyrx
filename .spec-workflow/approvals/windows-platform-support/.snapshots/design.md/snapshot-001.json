{
  "id": "snapshot_1766586998523_o0n7ytxf8",
  "approvalId": "approval_1766586998517_45lom0ep3",
  "approvalTitle": "Design: Windows Platform Support",
  "version": 1,
  "timestamp": "2025-12-24T14:36:38.523Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: Windows Platform Support\n\n**Spec Name**: windows-platform-support\n**Created**: 2024-12-24\n**Status**: Draft\n**Version**: 0.1.0\n\n---\n\n## Table of Contents\n\n1. [Architecture Overview](#architecture-overview)\n2. [Component Design](#component-design)\n3. [Data Structures](#data-structures)\n4. [Algorithms](#algorithms)\n5. [Platform Integration](#platform-integration)\n6. [Error Handling](#error-handling)\n7. [Testing Strategy](#testing-strategy)\n8. [Performance Considerations](#performance-considerations)\n\n---\n\n## 1. Architecture Overview\n\n### 1.1 High-Level Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Windows OS Kernel                                       â”‚\nâ”‚  â””â”€â†’ Raw Input API (device enumeration)                 â”‚\nâ”‚  â””â”€â†’ User32.dll (keyboard hooks, message loop)          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â”‚ Win32 API\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  keyrx_daemon.exe (Windows Desktop Application)          â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚  â”‚  Platform Layer (platform/windows.rs)              â”‚ â”‚\nâ”‚  â”‚  â”œâ”€â†’ WindowsKeyboardHook (SetWindowsHookEx)        â”‚ â”‚\nâ”‚  â”‚  â”œâ”€â†’ VirtualKeyMapper (VK_* â†” KeyCode)            â”‚ â”‚\nâ”‚  â”‚  â”œâ”€â†’ EventInjector (SendInput)                     â”‚ â”‚\nâ”‚  â”‚  â””â”€â†’ TrayIcon (Shell_NotifyIcon)                   â”‚ â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”‚                   â”‚ Platform trait                       â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚  â”‚  Core Logic (keyrx_core)                           â”‚ â”‚\nâ”‚  â”‚  â”œâ”€â†’ Event Processing                              â”‚ â”‚\nâ”‚  â”‚  â”œâ”€â†’ State Management                              â”‚ â”‚\nâ”‚  â”‚  â””â”€â†’ Tap/Hold DFA                                  â”‚ â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### 1.2 Design Principles\n\n**Principle 1: Platform Abstraction**\n- Windows-specific code isolated in `platform/windows.rs`\n- Implements `InputDevice` and `OutputDevice` traits\n- Core logic (keyrx_core) remains platform-agnostic\n\n**Principle 2: Minimal Dependencies**\n- Use `windows` crate (official Microsoft bindings)\n- Use `tray-icon` crate for cross-platform tray support\n- No heavyweight frameworks (no Tauri/Electron for v0.2.0)\n\n**Principle 3: Performance First**\n- Zero-copy event handling where possible\n- Hook callback does minimal work (delegate to async processor)\n- No heap allocation in hot path\n\n---\n\n## 2. Component Design\n\n### 2.1 WindowsKeyboardHook\n\n**Purpose**: Install and manage Windows low-level keyboard hook.\n\n**Responsibilities**:\n1. Install hook via `SetWindowsHookEx(WH_KEYBOARD_LL, ...)`\n2. Route keyboard events to callback function\n3. Block original events when remapped\n4. Clean up hook on exit (RAII pattern)\n\n**API**:\n```rust\npub struct WindowsKeyboardHook {\n    hook_handle: HHOOK,\n    event_sender: Sender<RawKeyEvent>,\n}\n\nimpl WindowsKeyboardHook {\n    pub fn new(event_sender: Sender<RawKeyEvent>) -> Result<Self, HookError>;\n    pub fn is_installed(&self) -> bool;\n}\n\nimpl Drop for WindowsKeyboardHook {\n    fn drop(&mut self) {\n        // Ensure UnhookWindowsHookEx called even on panic\n    }\n}\n```\n\n**Thread Safety**:\n- Hook callback runs on main thread (required by Windows)\n- Events sent to processing thread via crossbeam_channel\n- Drop implementation ensures cleanup even on panic\n\n---\n\n### 2.2 VirtualKeyMapper\n\n**Purpose**: Bidirectional mapping between Windows Virtual Key codes and KeyRx KeyCode enum.\n\n**Implementation Strategy**:\n\n**Option A: Static Arrays** (Chosen)\n```rust\nconst VK_TO_KEYCODE: [Option<KeyCode>; 256] = [\n    None,                    // 0x00 (reserved)\n    Some(KeyCode::Escape),   // VK_ESCAPE = 0x1B\n    Some(KeyCode::A),        // VK_A = 0x41\n    // ... 256 entries\n];\n\nconst KEYCODE_TO_VK: phf::Map<KeyCode, u32> = phf_map! {\n    KeyCode::Escape => VK_ESCAPE,\n    KeyCode::A => VK_A,\n    // ... all variants\n};\n\npub fn vk_to_keycode(vk: u32) -> Option<KeyCode> {\n    VK_TO_KEYCODE.get(vk as usize).copied().flatten()\n}\n\npub fn keycode_to_vk(kc: KeyCode) -> Option<u32> {\n    KEYCODE_TO_VK.get(&kc).copied()\n}\n```\n\n**Rationale**:\n- âœ… O(1) lookup (array index for VKâ†’KeyCode)\n- âœ… Compile-time verification (all 256 VK codes handled)\n- âœ… Zero runtime cost (data in .rodata section)\n\n**Alternative Considered: HashMap**\n- âŒ Runtime overhead (hashing)\n- âŒ Heap allocation\n\n---\n\n### 2.3 EventInjector\n\n**Purpose**: Inject remapped keyboard events into Windows input stream.\n\n**API**:\n```rust\npub struct EventInjector;\n\nimpl EventInjector {\n    pub fn inject_key_event(\n        &self,\n        keycode: KeyCode,\n        event_type: EventType, // Press or Release\n        modifiers: ModifierState,\n    ) -> Result<(), InjectionError>;\n}\n```\n\n**Implementation**:\n```rust\nuse windows::Win32::UI::Input::KeyboardAndMouse::{SendInput, INPUT, INPUT_KEYBOARD};\n\nfn inject_key_event(kc: KeyCode, event_type: EventType, mods: ModifierState) -> Result<()> {\n    let vk = keycode_to_vk(kc).ok_or(InjectionError::UnmappedKey)?;\n\n    let mut input = INPUT {\n        r#type: INPUT_KEYBOARD,\n        Anonymous: INPUT_0 {\n            ki: KEYBDINPUT {\n                wVk: vk as u16,\n                wScan: 0,\n                dwFlags: if event_type == EventType::Release {\n                    KEYEVENTF_KEYUP\n                } else {\n                    0\n                },\n                time: 0,\n                dwExtraInfo: 0,\n            },\n        },\n    };\n\n    unsafe {\n        SendInput(&[input], std::mem::size_of::<INPUT>() as i32);\n    }\n\n    Ok(())\n}\n```\n\n**Modifier Handling**:\n- Modifiers injected as separate events before main key\n- Order: Shift down â†’ Ctrl down â†’ Key down â†’ Key up â†’ Ctrl up â†’ Shift up\n\n---\n\n### 2.4 TrayIcon Component\n\n**Purpose**: System tray icon for daemon control.\n\n**Dependencies**: `tray-icon` crate (v0.14+)\n\n**API**:\n```rust\npub struct TrayIconController {\n    tray_icon: TrayIcon,\n    menu_rx: Receiver<TrayMenuEvent>,\n}\n\npub enum TrayMenuEvent {\n    ReloadConfig,\n    Exit,\n}\n\nimpl TrayIconController {\n    pub fn new() -> Result<Self, TrayError>;\n    pub fn poll_events(&mut self) -> Option<TrayMenuEvent>;\n}\n```\n\n**Menu Structure**:\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ğŸ”„ Reload Config    â”‚\nâ”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚\nâ”‚ ğŸšª Exit            â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Event Handling**:\n- Tray events processed in main event loop\n- Clicking \"Reload Config\" triggers config reload\n- Clicking \"Exit\" initiates graceful shutdown\n\n---\n\n## 3. Data Structures\n\n### 3.1 RawKeyEvent\n\n**Purpose**: Platform-agnostic representation of Windows KBDLLHOOKSTRUCT.\n\n```rust\n#[derive(Debug, Clone)]\npub struct RawKeyEvent {\n    pub vk_code: u32,           // Virtual Key code\n    pub scan_code: u32,         // Hardware scan code\n    pub flags: u32,             // Event flags (LLKHF_*)\n    pub time: u32,              // Event timestamp\n    pub is_extended: bool,      // Extended key flag (arrows, etc.)\n    pub is_injected: bool,      // Event was injected by SendInput\n}\n\nimpl From<&KBDLLHOOKSTRUCT> for RawKeyEvent {\n    fn from(kbd: &KBDLLHOOKSTRUCT) -> Self {\n        Self {\n            vk_code: kbd.vkCode,\n            scan_code: kbd.scanCode,\n            flags: kbd.flags,\n            time: kbd.time,\n            is_extended: (kbd.flags & LLKHF_EXTENDED) != 0,\n            is_injected: (kbd.flags & LLKHF_INJECTED) != 0,\n        }\n    }\n}\n```\n\n**Design Decision**: Why separate RawKeyEvent from KeyEvent?\n- `KBDLLHOOKSTRUCT` is Windows-specific (contains LPARAM, etc.)\n- `RawKeyEvent` is platform-neutral (can be sent across threads)\n- `KeyEvent` (from keyrx_core) is fully platform-agnostic\n\n---\n\n### 3.2 ModifierState\n\n**Purpose**: Track state of modifier keys (Shift, Ctrl, Alt, Win).\n\n```rust\n#[derive(Debug, Clone, Copy, Default)]\npub struct ModifierState {\n    pub shift: bool,\n    pub ctrl: bool,\n    pub alt: bool,\n    pub win: bool,\n}\n\nimpl ModifierState {\n    pub fn from_vk_code(vk: u32, is_down: bool) -> Option<Self> {\n        match vk {\n            VK_SHIFT | VK_LSHIFT | VK_RSHIFT => Some(Self { shift: is_down, ..Default::default() }),\n            VK_CONTROL | VK_LCONTROL | VK_RCONTROL => Some(Self { ctrl: is_down, ..Default::default() }),\n            VK_MENU | VK_LMENU | VK_RMENU => Some(Self { alt: is_down, ..Default::default() }),\n            VK_LWIN | VK_RWIN => Some(Self { win: is_down, ..Default::default() }),\n            _ => None,\n        }\n    }\n}\n```\n\n---\n\n## 4. Algorithms\n\n### 4.1 Hook Callback Algorithm\n\n**Critical Path**: Hook callback must return <50Î¼s to avoid input lag.\n\n**Pseudocode**:\n```rust\nunsafe extern \"system\" fn keyboard_proc(\n    code: i32,\n    wparam: WPARAM,\n    lparam: LPARAM,\n) -> LRESULT {\n    if code < 0 {\n        return CallNextHookEx(None, code, wparam, lparam);\n    }\n\n    let kbd = *(lparam as *const KBDLLHOOKSTRUCT);\n    let event_type = match wparam {\n        WM_KEYDOWN | WM_SYSKEYDOWN => EventType::Press,\n        WM_KEYUP | WM_SYSKEYUP => EventType::Release,\n        _ => return CallNextHookEx(None, code, wparam, lparam),\n    };\n\n    // Ignore injected events (prevent infinite loop)\n    if (kbd.flags & LLKHF_INJECTED) != 0 {\n        return CallNextHookEx(None, code, wparam, lparam);\n    }\n\n    // Convert to RawKeyEvent and send to processing thread\n    let raw_event = RawKeyEvent::from(&kbd);\n    if let Some(sender) = HOOK_STATE.event_sender.as_ref() {\n        let _ = sender.try_send(raw_event); // Non-blocking\n    }\n\n    // Block original event (we'll inject remapped version)\n    return 1; // Non-zero = block event\n}\n```\n\n**Performance Optimizations**:\n- âœ… No heap allocation\n- âœ… Minimal branching\n- âœ… Non-blocking send (try_send instead of send)\n- âœ… Event processing happens in separate thread\n\n---\n\n### 4.2 Event Processing Pipeline\n\n**Flow**:\n```\nHook Callback (main thread)\n  â””â”€â†’ try_send(RawKeyEvent)\n       â””â”€â†’ Channel (lock-free MPMC)\n            â””â”€â†’ Processing Thread\n                 â”œâ”€â†’ vk_to_keycode(vk)\n                 â”œâ”€â†’ process_event(KeyEvent)  // keyrx_core\n                 â””â”€â†’ For each output:\n                      â””â”€â†’ inject_key_event(KeyCode)\n```\n\n**Async Processing**:\n```rust\nasync fn event_processor(\n    mut event_rx: Receiver<RawKeyEvent>,\n    config: Arc<DeviceConfig>,\n    mut state: DeviceState,\n) {\n    while let Ok(raw_event) = event_rx.recv() {\n        // Convert VK to KeyCode\n        let Some(keycode) = vk_to_keycode(raw_event.vk_code) else {\n            warn!(\"Unmapped VK code: {:#x}\", raw_event.vk_code);\n            continue;\n        };\n\n        let event_type = if (raw_event.flags & LLKHF_UP) != 0 {\n            EventType::Release\n        } else {\n            EventType::Press\n        };\n\n        let key_event = KeyEvent::new(keycode, event_type, raw_event.time as u64);\n\n        // Core processing (platform-agnostic)\n        let outputs = keyrx_core::process_event(&key_event, &config, &mut state);\n\n        // Inject remapped events\n        for output in outputs {\n            let injector = EventInjector;\n            let _ = injector.inject_key_event(\n                output.keycode,\n                output.event_type,\n                output.modifiers,\n            );\n        }\n    }\n}\n```\n\n---\n\n### 4.3 Message Loop Integration\n\n**Problem**: Windows hooks require a message loop to function.\n\n**Solution**: Run Windows message loop on main thread.\n\n```rust\nfn main() -> Result<()> {\n    // Install hook (requires main thread)\n    let hook = WindowsKeyboardHook::new(event_tx)?;\n\n    // Spawn processing thread\n    let processor = tokio::spawn(event_processor(event_rx, config, state));\n\n    // Run Windows message loop (blocks main thread)\n    run_message_loop()?;\n\n    // Cleanup\n    drop(hook); // Calls UnhookWindowsHookEx\n    processor.abort();\n    Ok(())\n}\n\nfn run_message_loop() -> Result<()> {\n    unsafe {\n        let mut msg = MSG::default();\n        while GetMessage(&mut msg, None, 0, 0).as_bool() {\n            TranslateMessage(&msg);\n            DispatchMessage(&msg);\n        }\n    }\n    Ok(())\n}\n```\n\n---\n\n## 5. Platform Integration\n\n### 5.1 Trait Implementation\n\n**InputDevice Trait**:\n```rust\nimpl InputDevice for WindowsKeyboardInput {\n    fn next_event(&mut self) -> Result<KeyEvent, DeviceError> {\n        // Events come from hook callback via channel\n        match self.event_rx.recv() {\n            Ok(raw_event) => {\n                let keycode = vk_to_keycode(raw_event.vk_code)\n                    .ok_or(DeviceError::UnmappedKey)?;\n                let event_type = if (raw_event.flags & LLKHF_UP) != 0 {\n                    EventType::Release\n                } else {\n                    EventType::Press\n                };\n                Ok(KeyEvent::new(keycode, event_type, raw_event.time as u64))\n            }\n            Err(_) => Err(DeviceError::EndOfStream),\n        }\n    }\n\n    fn grab(&mut self) -> Result<(), DeviceError> {\n        // Windows hooks are implicitly \"grabbed\" (exclusive)\n        Ok(())\n    }\n\n    fn release(&mut self) -> Result<(), DeviceError> {\n        // No-op (hook cleanup happens in Drop)\n        Ok(())\n    }\n}\n```\n\n**OutputDevice Trait**:\n```rust\nimpl OutputDevice for WindowsKeyboardOutput {\n    fn send_event(&mut self, event: KeyEvent) -> Result<(), DeviceError> {\n        let injector = EventInjector;\n        injector.inject_key_event(event.keycode, event.event_type, ModifierState::default())\n            .map_err(|e| DeviceError::InjectionFailed(e.to_string()))\n    }\n}\n```\n\n---\n\n### 5.2 Cargo Features\n\n**Cargo.toml**:\n```toml\n[features]\ndefault = [\"web\"]\nlinux = [\"dep:evdev\", \"dep:uinput\", \"dep:nix\"]\nwindows = [\"dep:windows\", \"dep:tray-icon\"]\nweb = [\"dep:axum\", \"dep:tower-http\", \"dep:tokio\"]\n\n[target.'cfg(windows)'.dependencies]\nwindows = { version = \"0.58\", features = [\n    \"Win32_Foundation\",\n    \"Win32_UI_Input_KeyboardAndMouse\",\n    \"Win32_UI_WindowsAndMessaging\",\n    \"Win32_System_Threading\",\n    \"Win32_UI_Shell\",\n]}\ntray-icon = \"0.14\"\n```\n\n**Build Command**:\n```bash\ncargo build --release --target x86_64-pc-windows-msvc --features windows\n```\n\n---\n\n## 6. Error Handling\n\n### 6.1 Error Types\n\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum WindowsError {\n    #[error(\"Failed to install keyboard hook: {0}\")]\n    HookInstallFailed(String),\n\n    #[error(\"Failed to inject event: {0}\")]\n    InjectionFailed(String),\n\n    #[error(\"Tray icon creation failed: {0}\")]\n    TrayIconFailed(String),\n\n    #[error(\"Unmapped virtual key code: {0:#x}\")]\n    UnmappedVirtualKey(u32),\n}\n```\n\n### 6.2 Error Recovery\n\n**Hook Installation Failure**:\n```rust\nmatch WindowsKeyboardHook::new(event_tx) {\n    Ok(hook) => hook,\n    Err(e) => {\n        eprintln!(\"Failed to install keyboard hook: {}\", e);\n        eprintln!(\"Possible causes:\");\n        eprintln!(\"  - Another keyboard hook is already active\");\n        eprintln!(\"  - Insufficient privileges (try running as admin)\");\n        std::process::exit(1);\n    }\n}\n```\n\n**Injection Failure**:\n- Log warning but continue (don't crash daemon)\n- Increment error counter for monitoring\n\n---\n\n## 7. Testing Strategy\n\n### 7.1 Unit Tests\n\n**VirtualKeyMapper Tests**:\n```rust\n#[test]\nfn test_vk_to_keycode_all_letters() {\n    for letter in b'A'..=b'Z' {\n        let vk = letter as u32;\n        assert!(vk_to_keycode(vk).is_some());\n    }\n}\n\n#[test]\nfn test_keycode_to_vk_roundtrip() {\n    let kc = KeyCode::A;\n    let vk = keycode_to_vk(kc).unwrap();\n    let kc2 = vk_to_keycode(vk).unwrap();\n    assert_eq!(kc, kc2);\n}\n```\n\n**Event Injection Tests**:\n```rust\n#[test]\nfn test_inject_simple_keypress() {\n    let injector = EventInjector;\n    let result = injector.inject_key_event(\n        KeyCode::A,\n        EventType::Press,\n        ModifierState::default(),\n    );\n    assert!(result.is_ok());\n}\n```\n\n### 7.2 Integration Tests\n\n**Hook Lifecycle Test**:\n```rust\n#[test]\nfn test_hook_install_and_cleanup() {\n    let (tx, _rx) = crossbeam_channel::unbounded();\n    let hook = WindowsKeyboardHook::new(tx).unwrap();\n    assert!(hook.is_installed());\n    drop(hook);\n    // Verify hook uninstalled (cannot directly test, but Drop should run)\n}\n```\n\n### 7.3 Manual Testing Checklist\n\n- [ ] Install daemon, verify tray icon appears\n- [ ] Press keys, verify remapping works\n- [ ] Hold modifiers (Shift, Ctrl), verify preserved\n- [ ] Right-click tray icon, verify menu appears\n- [ ] Click \"Reload Config\", verify config reloaded\n- [ ] Click \"Exit\", verify daemon exits cleanly\n- [ ] Start daemon again, verify no resource leaks\n\n---\n\n## 8. Performance Considerations\n\n### 8.1 Latency Budget\n\n**Target**: <1ms end-to-end\n\n**Breakdown**:\n```\nHook callback:           <50Î¼s   (5%)\nChannel send:            <10Î¼s   (1%)\nVKâ†’KeyCode lookup:       <5Î¼s    (0.5%)\nCore processing:         <100Î¼s  (10%)\nKeyCodeâ†’VK lookup:       <5Î¼s    (0.5%)\nSendInput:               <50Î¼s   (5%)\nOS scheduling:           <780Î¼s  (78%)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal:                   <1000Î¼s (100%)\n```\n\n### 8.2 Optimizations\n\n**1. Static Dispatch**:\n- Use trait objects sparingly (heap allocation + vtable overhead)\n- Prefer concrete types where possible\n\n**2. Zero-Copy Deserialization**:\n- Config loaded via memory-mapped file (memmap2)\n- rkyv zero-copy deserialization\n\n**3. Lock-Free Channels**:\n- crossbeam_channel for hook â†’ processor communication\n- No mutex contention\n\n**4. Batch Event Injection**:\n- SendInput accepts array (batch multiple events)\n- Reduces syscall overhead\n\n---\n\n## 9. Security Considerations\n\n### 9.1 Code Injection Prevention\n\n**Config File Validation**:\n- .krx files validated via rkyv checksum\n- Malformed files rejected at load time\n\n**Hook Callback Safety**:\n- No user input processed in callback (only Windows-provided KBDLLHOOKSTRUCT)\n- Bounds checking on VK code array access\n\n### 9.2 Privilege Escalation\n\n**No Admin Required**:\n- Low-level hooks work in user context\n- No driver installation (avoids kernel-mode code)\n\n---\n\n## 10. Migration Path\n\n### 10.1 From Linux to Windows\n\n**User Workflow**:\n1. Copy .krx file from Linux to Windows\n2. Run `keyrx_daemon.exe run --config my-config.krx`\n3. Config works identically (platform-agnostic)\n\n**Platform Differences**:\n- Linux: systemd service\n- Windows: Desktop app with tray icon\n- Both: Same .krx config format\n\n---\n\n## 11. Future Enhancements (Out of Scope for v0.2.0)\n\n### Deferred Features\n\n1. **Per-Application Configs**: Window title-based config switching\n2. **Gaming Mode**: Suspend hooks when game detected\n3. **MSI Installer**: Professional installation experience\n4. **Auto-Update**: Self-updating binary\n\n---\n\n## 12. References\n\n- Windows API Documentation: https://learn.microsoft.com/en-us/windows/win32/\n- tray-icon crate: https://docs.rs/tray-icon/\n- windows crate: https://docs.rs/windows/\n- Keyboard Hook Example: https://learn.microsoft.com/en-us/windows/win32/winmsg/using-hooks\n\n---\n\n**Document Status**: Ready for Review\n",
  "fileStats": {
    "size": 20284,
    "lines": 731,
    "lastModified": "2025-12-24T14:33:43.773Z"
  },
  "comments": []
}