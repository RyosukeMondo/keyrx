{
  "id": "snapshot_1764565100332_w1j1gytkg",
  "approvalId": "approval_1764565072451_zzgu8cnhz",
  "approvalTitle": "Design document for live-ui-ffi-hardening",
  "version": 2,
  "timestamp": "2025-12-01T04:58:20.332Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\nImplement the live UI/FFI hardening feature: emit full engine state snapshots with timing and latency, execute `keyrx_eval` against the running runtime, expose a canonical key registry, and extend the Dart bridge/UI to consume the richer payloads with clear success/error handling. The goal is a real-time debugger and REPL that reflect true engine state with safe, structured FFI contracts.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Follows hybrid Rust core + Flutter UI via FFI.\n- Preserves CLI-first principle: FFI exports mirror CLI behaviors with JSON-friendly payloads and `ok:`/`error:` responses.\n- Meets low-latency target (<1ms added): latency measured and surfaced without expanding critical path beyond minimal serialization.\n- Uses Rhai sandbox and avoids unsafe state mutation by serializing eval access.\n\n### Project Structure (structure.md)\n- Rust changes stay under `core/src/ffi` (exports), `core/src/engine` (state/latency), and `core/src/scripting` (runtime handle).\n- Dart bridge updates under `ui/lib/ffi` (bindings/bridge) and UI rendering in `ui/lib/pages` / `ui/lib/widgets`.\n- Tests land in `core/tests` or colocated Rust modules, and `ui/test` for Flutter widget/integration tests.\n\n## Code Reuse Analysis\n- **StateStore/engine state**: reuse existing state tracking (`core/src/engine/state.rs`) to populate snapshot fields.\n- **RhaiRuntime**: reuse existing runtime initialization; add shared handle/channel rather than new instances.\n- **FFI string contracts**: reuse `keyrx_free_string` and existing JSON serialization patterns for FFI outputs.\n- **Flutter bridge models**: extend existing `BridgeState`/`EngineSnapshot` parsing instead of redefining structures.\n\n### Existing Components to Leverage\n- **`core/src/ffi/exports.rs`**: extend exports for state stream, eval, and list keys.\n- **`core/src/scripting/runtime.rs`**: expose shared runtime handle or command channel for eval.\n- **`ui/lib/ffi/bridge.dart`**: parse new state fields and handle `ok:`/`error:` responses.\n- **`ui/lib/pages/debugger.dart` & `ui/lib/pages/console.dart`**: render modifiers/pending/timing and eval results.\n\n### Integration Points\n- **Engine event loop**: hook latency measurement and state snapshot publication around `process_event`.\n- **FFI callbacks**: deliver serialized snapshots via existing `keyrx_on_state` callback mechanism.\n- **Key registry**: read canonical key definitions (aliases + OS codes) from engine registry and serialize to JSON.\n- **UI state stream**: Dart bridge updates `EngineSnapshot` model; UI listens via existing stream/subscription.\n\n## Architecture\n- **State stream**: Event loop publishes `StateSnapshot` (layers, modifiers, held, pending, event summary, latency_us, timing) on each event/change. Serialization to JSON feeds `keyrx_on_state` callback when registered.\n- **Shared eval**: `keyrx_eval` routes commands to the active `RhaiRuntime` through a synchronized handle (e.g., `Arc<Mutex<RuntimeHandle>>` or mpsc to the engine task). Responses prefixed `ok:`/`error:`.\n- **Key registry**: `keyrx_list_keys` returns JSON array of `{name, aliases, evdev, vk}` derived from canonical registry.\n- **Bridge/UI**: Dart FFI decodes new fields, updates models, and UI renders debugger timeline (including timing thresholds), modifiers, pending queue, and keyed validation. Console styles outputs based on prefix.\n\n### Modular Design Principles\n- **Single File Responsibility**: FFI exports limited to C-ABI surface; engine state logic remains in engine modules; UI rendering separated from bridge parsing.\n- **Component Isolation**: State serialization helpers live in Rust modules; Dart bridge maps payloads to plain models consumed by pages/widgets.\n- **Service Layer Separation**: Eval routing encapsulated behind a runtime handle/channel; UI interacts only via bridge.\n- **Utility Modularity**: Pending decision formatting and timing snapshot helpers are reusable, unit-testable utilities.\n\n```mermaid\nflowchart LR\n    E[Input Event] --> P[Process Event + Latency Timer]\n    P --> S[StateSnapshot Serialize JSON]\n    S --> C[FFI keyrx_on_state callback]\n    C --> D[Dart bridge parse]\n    D --> U[Debugger UI render]\n    R[Console Eval cmd] --> F[keyrx_eval shared runtime]\n    F --> Rsp[ok:/error:]\n    Rsp --> D\n    D --> U2[Console UI style]\n```\n\n## Components and Interfaces\n\n### Component 1: State Snapshot Publisher (Rust)\n- **Purpose:** Capture engine state + timing per event and deliver via `keyrx_on_state`.\n- **Interfaces:** Internal helper `build_state_snapshot(event_ctx) -> StateSnapshot`; exposed via `keyrx_on_state` FFI callback.\n- **Dependencies:** Engine state store, decision queue, timing config, monotonic clock for latency.\n- **Reuses:** Existing state getters (`active_layers`, modifier state) and JSON serialization utilities.\n\n### Component 2: Shared Eval Handler (Rust)\n- **Purpose:** Execute eval requests on the running `RhaiRuntime` safely.\n- **Interfaces:** `keyrx_eval(cmd: *const c_char) -> *const c_char` returning `ok:`/`error:` strings.\n- **Dependencies:** Shared runtime handle (Arc<Mutex<...>> or channel), Rhai runtime execute API.\n- **Reuses:** Existing runtime initialization and error formatting helpers.\n\n### Component 3: Canonical Key Registry Export (Rust)\n- **Purpose:** Provide authoritative key metadata for UI validation.\n- **Interfaces:** `keyrx_list_keys() -> *const c_char` JSON array.\n- **Dependencies:** Key registry definitions (names, aliases, evdev/vk codes).\n- **Reuses:** Existing key definition tables.\n\n### Component 4: Dart Bridge Parsing Extensions\n- **Purpose:** Decode new state fields and eval/key registry responses.\n- **Interfaces:** `BridgeState`/`EngineSnapshot` with `modifiers`, `pending`, `timing`; bridge methods `listKeys()`, `eval()`.\n- **Dependencies:** Generated FFI bindings, json decode.\n- **Reuses:** Existing bridge stream handling and error normalization.\n\n### Component 5: UI Rendering Updates\n- **Purpose:** Display modifiers/pending/timing in debugger; style console responses; load key registry for editor validation.\n- **Interfaces:** Debugger widgets consume `EngineSnapshot`; console consumes eval result; editor consumes `KeyMappings`.\n- **Dependencies:** Bridge-provided models/streams.\n- **Reuses:** Existing debugger timeline, console UI, key mapping editor.\n\n## Data Models\n\n### StateSnapshot (Rust serialized JSON)\n```\n{\n  \"layers\": [string],\n  \"modifiers\": { \"standard\": [string], \"virtual\": [string] },\n  \"held\": [string],\n  \"pending\": [string],        // human-readable descriptions\n  \"event\": string,            // e.g., \"Key A down; tap-or-hold pending\"\n  \"latency_us\": u64,\n  \"timing\": {\n    \"tap_timeout_ms\": u32,\n    \"combo_timeout_ms\": u32,\n    \"hold_delay_ms\": u32,\n    \"eager_tap\": bool,\n    \"permissive_hold\": bool,\n    \"retro_tap\": bool\n  }\n}\n```\n\n### KeyRegistry Entry (Rust serialized JSON array)\n```\n{\n  \"name\": String,\n  \"aliases\": Vec<String>,\n  \"evdev\": u16,\n  \"vk\": u16\n}\n```\n\n### Dart Bridge Models\n```\nclass EngineSnapshot {\n  List<String> layers;\n  List<String> held;\n  ModifierSet modifiers; // standard + virtual\n  List<String> pending;\n  String event;\n  int latencyUs;\n  TimingConfig? timing;\n}\n\nclass KeyEntry {\n  String name;\n  List<String> aliases;\n  int evdev;\n  int vk;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **No engine initialized when eval called**\n   - **Handling:** Return `error: engine not initialized`; no panic.\n   - **User Impact:** Console shows error styling with message.\n\n2. **FFI callback not registered for state**\n   - **Handling:** Skip publish; log debug trace only.\n   - **User Impact:** UI simply receives no snapshot; no crash.\n\n3. **Key registry fetch fails**\n   - **Handling:** Return `error:` string; Dart falls back to static list and logs.\n   - **User Impact:** Editor uses fallback keys; inline badge indicates invalid keys if present.\n\n4. **JSON serialization error**\n   - **Handling:** Return `error:`; avoid unwinding across FFI boundary.\n   - **User Impact:** UI shows error banner/toast; stream continues on next event.\n\n## Testing Strategy\n\n### Unit Testing\n- Rust: tests for `keyrx_eval` ok/error paths with shared runtime handle; `keyrx_list_keys` schema/content; state snapshot serialization includes timing and latency.\n- Dart: model parsing tests for `EngineSnapshot` with modifiers/pending/timing; eval response parsing for ok/error; key registry normalization.\n\n### Integration Testing\n- Rust: integration test for `keyrx_on_state` with mock callback capturing snapshot JSON.\n- Flutter: widget tests for debugger rendering modifiers/pending/timing and console styling; editor key validation using fetched key list.\n\n### End-to-End Testing\n- Simulated stateStream and eval round-trip in Flutter test harness to ensure bridge â†’ UI flow works with timing data.\n- Optional smoke in Rust with sample event sequence to assert latency measurement and state publication cadence.\n",
  "fileStats": {
    "size": 8957,
    "lines": 178,
    "lastModified": "2025-12-01T04:57:49.659Z"
  },
  "comments": []
}