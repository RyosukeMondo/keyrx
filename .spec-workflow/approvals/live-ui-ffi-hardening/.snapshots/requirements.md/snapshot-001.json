{
  "id": "snapshot_1764564676990_segtbiwbi",
  "approvalId": "approval_1764564676976_88u2zgh1f",
  "approvalTitle": "Requirements document for live-ui-ffi-hardening",
  "version": 1,
  "timestamp": "2025-12-01T04:51:16.990Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\nDeliver a fully live debugger and REPL experience by wiring the native engine state stream, shared eval, canonical key registry, and UI consumption. This closes remaining visibility gaps so users can see accurate layers/modifiers/timing, validate keys, and run Rhai commands against the active engine without restart churn.\n\n## Alignment with Product Vision\nSupports the Product pillars of real-time visual debugging, CLI/FFI-first development, and safety: the debugger surfaces true engine state with latency metrics, the REPL runs against the live runtime for rapid iteration, and canonical key metadata prevents invalid mappings. This advances the tech steering for low-latency observability and script safety.\n\n## Requirements\n\n### Requirement 1: Real-time State Stream with Timing\n\n**User Story:** As a power user debugging layers and timing, I want the debugger to stream full engine state (layers, modifiers, held keys, pending decisions, timing config, last event, latency) so I can understand why the engine behaved a certain way without guesswork.\n\n#### Acceptance Criteria\n\n1. WHEN any input event is processed THEN the engine SHALL publish a state snapshot including: ordered `layers`, `modifiers` (standard + virtual), `held` keys (canonical names), `pending` decisions (tap/hold/combos/sequences in human-readable form), last `event` summary, and `latency_us` measured from ingress to post-decision.\n2. WHEN timing configuration exists THEN the snapshot SHALL include `timing` { tap_timeout_ms, combo_timeout_ms, hold_delay_ms, eager_tap, permissive_hold, retro_tap }.\n3. IF no state callback is registered THEN publishing SHALL be skipped without error; IF a callback exists THEN the first snapshot SHALL be delivered on initialization to keep the UI in sync.\n\n### Requirement 2: Shared REPL/Eval on Active Engine\n\n**User Story:** As a developer iterating on scripts, I want `keyrx_eval` to execute against the running engine/runtime so changes reflect live state without restarting, and I want clear success/error responses.\n\n#### Acceptance Criteria\n\n1. WHEN `keyrx_eval` receives a command string AND an engine instance is active THEN it SHALL execute in that shared runtime (or via a serialized command channel), returning `ok:<value>` on success.\n2. IF the engine is not initialized OR execution fails THEN it SHALL return `error:<message>` without panicking or mutating engine state unsafely.\n3. Concurrent eval requests SHALL be serialized or otherwise coordinated to avoid data races with the engine task.\n\n### Requirement 3: Canonical Key Registry for Validation\n\n**User Story:** As a user editing keymaps, I want the UI to fetch an authoritative key list (names, aliases, OS codes) so invalid key names are caught immediately.\n\n#### Acceptance Criteria\n\n1. WHEN `keyrx_list_keys` is called THEN it SHALL return JSON array objects `{ name, aliases: [...], evdev: u16, vk: u16 }`, covering all canonical keys and aliases from the engine registry.\n2. IF the registry cannot be fetched THEN the bridge SHALL surface an error (using the standardized prefix) and the UI SHALL fall back to its current static list without crashing.\n\n### Requirement 4: UI Consumption & Error Surfacing\n\n**User Story:** As a user in the debugger and console, I want accurate rendering of modifiers/pending/timing, timeline visibility of thresholds, and clear success/error styling for REPL commands.\n\n#### Acceptance Criteria\n\n1. WHEN the Flutter bridge receives a state snapshot THEN it SHALL parse and expose `modifiers`, `pending`, and `timing` to the UI model so the debugger renders them (scrollable to avoid overflow).\n2. WHEN timing thresholds exist THEN the debugger timeline SHALL display tap/hold/combo windows and pending decisions alongside events.\n3. WHEN the console receives an eval result with `ok:` THEN it SHALL render success styling; WHEN it receives `error:` (including “engine not initialized”) THEN it SHALL render failure styling without crashing.\n4. WHEN the UI loads THEN it SHALL call the bridge to fetch the canonical key list and update `KeyMappings`; invalid keys SHALL be surfaced inline (badge/chip) rather than only snackbar.\n\n### Requirement 5: Tests & Validation\n\n**User Story:** As a maintainer, I want automated coverage so regressions in state serialization, eval responses, key registry, and UI rendering are caught.\n\n#### Acceptance Criteria\n\n1. Rust: WHEN running tests THEN there SHALL be unit tests covering `keyrx_eval` ok/error paths, `keyrx_list_keys` schema/content, and `keyrx_on_state` serialization including timing fields.\n2. Flutter: WHEN running widget/tests THEN there SHALL be coverage for debugger rendering of modifiers/pending/timing, editor key validation using fetched key list, console error display on `error:`, and a mocked stateStream integration smoke including timing.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: Rust FFI exports, runtime coordination, and UI parsing layers remain separated with clear interfaces.\n- **Modular Design**: Bridge/state models are isolated from rendering widgets to allow testing without UI spin-up.\n- **Dependency Management**: No new cross-layer tight coupling; shared runtime access is encapsulated behind a thread-safe handle or channel.\n- **Clear Interfaces**: FFI string contracts standardized to `ok:`/`error:` prefixes and documented in bridge layer.\n\n### Performance\n- Per-event processing overhead for state publishing SHALL keep total engine latency <1ms (aligned with steering metric); latency measurement uses monotonic timestamps around event processing.\n- State snapshot serialization SHALL avoid unbounded allocations and reuse buffers where practical.\n\n### Security\n- Eval execution SHALL respect existing Rhai sandbox limits and SHALL not permit unsafe mutation or panic propagation across the FFI boundary.\n- FFI return strings SHALL avoid leaking internal stack traces; errors are prefixed `error:` with concise detail.\n\n### Reliability\n- State callback delivery SHALL be resilient to missing callbacks and SHALL not crash the engine loop.\n- Bridge parsing errors SHALL be handled gracefully with fallbacks and logging without terminating the UI.\n\n### Usability\n- Debugger UI SHALL remain readable on small viewports via scrollable layout.\n- Error/success styling in the console SHALL clearly differentiate outcomes and surface “engine not initialized” explicitly.\n",
  "fileStats": {
    "size": 6495,
    "lines": 83,
    "lastModified": "2025-12-01T04:51:13.588Z"
  },
  "comments": []
}