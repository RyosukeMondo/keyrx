{
  "id": "snapshot_1767426064178_1v4z1eicc",
  "approvalId": "approval_1767057655800_uaa4bb4my",
  "approvalTitle": "Requirements Document - Technical Debt Remediation",
  "version": 2,
  "timestamp": "2026-01-03T07:41:04.178Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThis specification addresses critical technical debt identified across recently implemented features (profile-management, visual-config-builder, config-validation-linting, wasm-simulation-integration, macro-recorder). The technical debt analysis revealed systematic violations of project code quality standards defined in CLAUDE.md, including file size limits, missing test coverage, hard-coded dependencies, code duplication, and insufficient error handling.\n\nThe purpose of this remediation is to bring the codebase into full compliance with project standards, improve maintainability, enhance testability, and establish patterns that prevent future technical debt accumulation. This work is critical for ensuring the codebase remains manageable as the project scales, particularly given the \"AI Coding Agent First\" design philosophy that requires machine-verifiable, deterministic behavior.\n\n## Alignment with Product Vision\n\nThis technical debt remediation directly supports the product vision outlined in product.md through:\n\n1. **AI-First Verification**: By eliminating hard-coded dependencies and enforcing dependency injection, we enable fully automated testing without manual intervention, aligning with the \"AI Coding Agent First\" principle.\n\n2. **Code Quality as Infrastructure**: Maintaining strict file/function size limits and test coverage ensures the codebase remains analyzable by AI agents, supporting deterministic verification and automated code analysis.\n\n3. **Single Source of Truth (SSOT)**: Eliminating code duplication reinforces SSOT principles, ensuring configuration and implementation remain synchronized.\n\n4. **Structured Logging**: Improving error handling with structured logging enhances observability for AI agents to diagnose issues programmatically.\n\n5. **Maintainability at Scale**: Reducing file sizes and extracting common utilities supports the long-term vision of extending keyrx to new platforms and features without codebase degradation.\n\n## Requirements\n\n### Requirement 1: File Size Compliance\n\n**User Story:** As a developer (human or AI), I want all source files to comply with the 500-line maximum limit, so that code remains modular, maintainable, and analyzable.\n\n#### Acceptance Criteria\n\n1. WHEN measuring file length (excluding comments and blank lines) THEN keyrx_daemon/src/config/profile_manager.rs SHALL be ≤500 lines\n2. WHEN measuring file length THEN keyrx_daemon/src/cli/config.rs SHALL be ≤500 lines\n3. WHEN measuring file length THEN keyrx_daemon/src/cli/profiles.rs SHALL be ≤500 lines\n4. WHEN measuring file length THEN keyrx_ui/src/components/MacroRecorderPage.tsx SHALL be ≤500 lines\n5. WHEN file size reduction is achieved THEN extracted modules SHALL follow Single Responsibility Principle\n6. WHEN extracting modules THEN all tests SHALL continue to pass without modification\n7. WHEN compilation is complete THEN no new warnings or errors SHALL be introduced\n\n### Requirement 2: Test Coverage Completeness\n\n**User Story:** As a developer, I want comprehensive test coverage for all components, so that changes can be validated automatically without manual testing (supporting AI-first verification).\n\n#### Acceptance Criteria\n\n1. WHEN running test suite THEN ProfileCard.tsx SHALL have a corresponding test file with ≥80% coverage\n2. WHEN running test suite THEN ProfileDialog.tsx SHALL have a corresponding test file with ≥80% coverage\n3. WHEN running test suite THEN DashboardEventTimeline.tsx SHALL have a corresponding test file with ≥80% coverage\n4. WHEN running test suite THEN DashboardPage.tsx SHALL have a corresponding test file with ≥80% coverage\n5. WHEN running test suite THEN DeviceList.tsx SHALL have a corresponding test file with ≥80% coverage\n6. WHEN running test suite THEN EventTimeline.tsx SHALL have a corresponding test file with ≥80% coverage\n7. WHEN running test suite THEN MetricsChart.tsx SHALL have a corresponding test file with ≥80% coverage\n8. WHEN running test suite THEN StateIndicatorPanel.tsx SHALL have a corresponding test file with ≥80% coverage\n9. WHEN running test suite THEN TemplateLibrary.tsx SHALL have a corresponding test file with ≥80% coverage\n10. WHEN all tests are implemented THEN total project coverage SHALL be ≥80% (verified by tarpaulin/coverage tools)\n11. WHEN tests run in CI THEN all tests SHALL pass consistently without flakiness\n\n### Requirement 3: Dependency Injection Compliance\n\n**User Story:** As a developer, I want all external dependencies injected rather than hard-coded, so that components are testable, mockable, and follow SOLID principles.\n\n#### Acceptance Criteria\n\n1. WHEN ProfilesPage component renders THEN API base URL SHALL be injected via props or context (not hard-coded to localhost:3030)\n2. WHEN ConfigurationPage saves data THEN storage layer SHALL be abstracted behind an interface (not direct localStorage access)\n3. WHEN ProfilesPage downloads files THEN browser APIs SHALL be abstracted behind an injectable interface\n4. WHEN DeviceList connects to WebSocket THEN connection URLs SHALL be configurable via environment or props\n5. WHEN components use injected dependencies THEN unit tests SHALL demonstrate mocking capabilities\n6. WHEN injected dependencies are used THEN components SHALL work correctly with different implementations (dev, test, production)\n\n### Requirement 4: Code Duplication Elimination\n\n**User Story:** As a developer, I want shared logic consolidated into reusable modules, so that changes propagate consistently and maintenance is simplified.\n\n#### Acceptance Criteria\n\n1. WHEN JSON output logic exists in CLI modules THEN a common utility module (cli/common.rs) SHALL centralize serialization logic\n2. WHEN timestamp formatting is needed THEN a shared utility (utils/timeFormatting.ts) SHALL provide consistent formatting functions\n3. WHEN key code mapping is needed THEN a shared utility (utils/keyCodeMapping.ts) SHALL provide consistent mapping logic\n4. WHEN common utilities are created THEN they SHALL have ≥90% test coverage\n5. WHEN duplicated code is removed THEN all existing functionality SHALL continue to work identically\n6. IF duplication is eliminated THEN at least 200+ lines of code SHALL be removed from the codebase\n\n### Requirement 5: Error Handling and Logging Improvements\n\n**User Story:** As a developer or AI agent, I want comprehensive error handling with structured logging, so that failures are observable, debuggable, and machine-parseable.\n\n#### Acceptance Criteria\n\n1. WHEN catch blocks exist THEN they SHALL log errors at appropriate severity levels (no silent failures)\n2. WHEN errors occur in DeviceList.tsx THEN reconnection errors SHALL be logged at debug level\n3. WHEN errors occur in configBuilderStore.ts THEN user-facing actions SHALL propagate errors to UI for display\n4. WHEN errors are logged THEN they SHALL follow structured JSON format (per product.md) with timestamp, level, service, event_type, context\n5. IF a component encounters an error THEN users SHALL receive actionable feedback (not just console warnings)\n6. WHEN debug logging is added THEN it SHALL not impact production performance\n\n### Requirement 6: Documentation Completeness\n\n**User Story:** As a developer, I want comprehensive module-level documentation, so that code intent is clear and onboarding is accelerated.\n\n#### Acceptance Criteria\n\n1. WHEN ProfileCard.tsx is viewed THEN it SHALL have JSDoc comments describing component purpose, props, and usage\n2. WHEN ProfileDialog.tsx is viewed THEN it SHALL have JSDoc comments describing component purpose, props, and usage\n3. WHEN TemplateLibrary.tsx is viewed THEN it SHALL have comprehensive header documentation\n4. WHEN EventTimeline.tsx is viewed THEN it SHALL have detailed feature documentation beyond the brief description\n5. WHEN DeviceList.tsx is viewed THEN it SHALL have detailed documentation of features and integration points\n6. WHEN public components/functions exist THEN they SHALL have documentation following TSDoc or rustdoc standards\n7. WHEN complex logic exists THEN inline comments SHALL explain \"why\" (not \"what\")\n\n### Requirement 7: Outstanding TODOs Resolution\n\n**User Story:** As a product owner, I want all outstanding TODOs resolved or converted to tracked issues, so that incomplete work is visible and prioritized.\n\n#### Acceptance Criteria\n\n1. WHEN ConfigurationPage.tsx:44 TODO exists THEN actual API integration SHALL be implemented OR a GitHub issue SHALL be created\n2. WHEN keyrx_daemon/src/web/ws.rs:48 TODO exists THEN WebSocket event streaming SHALL be fully implemented OR a GitHub issue SHALL be created\n3. WHEN ProfilesPage.tsx:209 rename functionality exists THEN backend API SHALL implement rename endpoint\n4. WHEN all TODOs are addressed THEN code comments SHALL not contain \"TODO\" markers for production-critical features\n5. IF TODOs are converted to issues THEN issues SHALL be labeled \"technical-debt\" and linked to this spec\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: All extracted modules (cli/common.rs, utils/timeFormatting.ts, etc.) SHALL have a single, well-defined purpose\n- **Modular Design**: Utility modules SHALL be isolated, reusable, and independently testable\n- **Dependency Management**: Minimize interdependencies between newly created modules\n- **Clear Interfaces**: Define clean contracts for extracted utilities (JSDoc/rustdoc with parameter and return type specifications)\n- **No Breaking Changes**: All refactoring SHALL maintain backward compatibility for public APIs unless explicitly approved\n\n### Performance\n\n- **No Performance Degradation**: Refactored code SHALL not introduce measurable performance regressions (verified via criterion benchmarks for Rust, performance tests for TypeScript)\n- **Compilation Time**: File size reductions SHALL not increase overall compilation time\n- **Test Execution**: New tests SHALL execute in <10 seconds combined (maintain fast feedback loop)\n\n### Security\n\n- **No Security Regressions**: Dependency injection SHALL not introduce new attack surfaces (validate all injected dependencies)\n- **Logging Safety**: Structured logging SHALL not log sensitive data (PII, secrets, credentials)\n- **Input Validation**: All new utility functions SHALL validate inputs and handle edge cases securely\n\n### Reliability\n\n- **Test Stability**: All new tests SHALL be deterministic and non-flaky (no race conditions, no timing dependencies)\n- **Error Recovery**: Improved error handling SHALL enable graceful degradation (no crashes from improved logging)\n- **Backward Compatibility**: Refactored modules SHALL maintain existing behavior (verified via regression testing)\n\n### Usability\n\n- **Developer Experience**: Extracted utilities SHALL have clear, well-documented APIs that improve developer productivity\n- **Error Messages**: Enhanced error handling SHALL provide actionable error messages with context\n- **Code Readability**: Reduced file sizes SHALL improve code navigation and comprehension\n",
  "fileStats": {
    "size": 11078,
    "lines": 155,
    "lastModified": "2025-12-30T05:01:19.015Z"
  },
  "comments": []
}