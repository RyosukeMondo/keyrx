{
  "id": "snapshot_1764463362526_sv356wwct",
  "approvalId": "approval_1764461820883_i3n60t0iu",
  "approvalTitle": "Platform-Drivers Requirements Document",
  "version": 2,
  "timestamp": "2025-11-30T00:42:42.526Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements Document: platform-drivers\n\n## Introduction\n\nThis specification implements Phase 2 (\"The Nervous System\") from the KeyRx product roadmap - real platform-specific keyboard drivers for Linux and Windows. This transforms KeyRx from a simulation-only tool into a fully functional keyboard remapper that intercepts and transforms real keyboard input.\n\n## Alignment with Product Vision\n\nFrom product.md:\n- **Phase 2: The Nervous System (Drivers)**: Platform-specific drivers for Windows (WH_KEYBOARD_LL) and Linux (uinput/evdev)\n- **Performance > Features**: Sub-1ms latency requirement for \"invisible\" feel\n- **Cross-Platform**: Consistent behavior on Windows and Linux\n\nFrom tech.md:\n- **Trait Abstraction**: OS adapters implement generic `InputSource` trait\n- **Modular Drivers**: Drivers are plugins, enabling mock testing\n- **No Elevated Privileges**: Runs in user space where possible\n\n## Requirements\n\n### REQ-1: Linux Keyboard Capture\n\n**User Story:** As a Linux user, I want KeyRx to intercept my keyboard input, so that I can remap keys system-wide.\n\n#### Acceptance Criteria\n\n1. WHEN KeyRx starts with a script THEN it SHALL grab the keyboard device via evdev\n2. WHEN a key is pressed THEN the engine SHALL receive the event within 500μs\n3. WHEN the keyboard is grabbed THEN other applications SHALL NOT receive raw input\n4. WHEN KeyRx stops THEN it SHALL release the keyboard grab cleanly\n5. IF multiple keyboards are connected THEN KeyRx SHALL support selecting which to grab\n6. IF /dev/input/* is not accessible THEN clear error with remediation SHALL be shown\n7. WHEN running THEN original keyboard device SHALL be exclusively grabbed (EVIOCGRAB)\n\n### REQ-2: Linux Key Injection\n\n**User Story:** As a Linux user, I want KeyRx to inject remapped keys, so that applications receive my configured output.\n\n#### Acceptance Criteria\n\n1. WHEN a key is remapped THEN the remapped key SHALL be injected via uinput\n2. WHEN a key is blocked THEN NO output SHALL be sent to applications\n3. WHEN a key passes through THEN it SHALL be re-injected with original timing\n4. WHEN KeyRx creates uinput device THEN it SHALL register all supported key codes\n5. WHEN injecting THEN both KEY_DOWN and KEY_UP events SHALL be sent correctly\n6. WHEN injecting modifier combinations THEN proper ordering SHALL be maintained\n7. IF uinput write fails THEN error SHALL be logged and operation retried once\n\n### REQ-3: Windows Keyboard Hook\n\n**User Story:** As a Windows user, I want KeyRx to intercept my keyboard input, so that I can remap keys system-wide.\n\n#### Acceptance Criteria\n\n1. WHEN KeyRx starts THEN it SHALL install WH_KEYBOARD_LL hook via SetWindowsHookExW\n2. WHEN a key is pressed THEN the hook callback SHALL receive the event\n3. WHEN the hook is installed THEN it SHALL intercept all keyboard input system-wide\n4. WHEN KeyRx stops THEN it SHALL uninstall hook via UnhookWindowsHookEx\n5. WHEN hook callback processes THEN it SHALL return within 100ms (Windows requirement)\n6. IF hook installation fails THEN clear error with remediation SHALL be shown\n7. WHEN running THEN a message pump thread SHALL process hook callbacks\n\n### REQ-4: Windows Key Injection\n\n**User Story:** As a Windows user, I want KeyRx to inject remapped keys, so that applications receive my configured output.\n\n#### Acceptance Criteria\n\n1. WHEN a key is remapped THEN the remapped key SHALL be injected via SendInput\n2. WHEN a key is blocked THEN hook callback SHALL return non-zero (consume event)\n3. WHEN a key passes through THEN hook callback SHALL return zero (pass event)\n4. WHEN injecting THEN KEYBDINPUT structure SHALL be properly configured\n5. WHEN injecting THEN KEYEVENTF_EXTENDEDKEY SHALL be set for extended keys\n6. WHEN injecting THEN both KEYEVENTF_KEYDOWN and KEYEVENTF_KEYUP SHALL be used correctly\n7. IF SendInput fails THEN error SHALL be logged with GetLastError details\n\n### REQ-5: Event Loop Integration\n\n**User Story:** As a developer, I want drivers to integrate seamlessly with the async engine, so that the architecture remains clean.\n\n#### Acceptance Criteria\n\n1. WHEN driver implements InputSource THEN it SHALL work with existing Engine<I,S,St>\n2. WHEN poll_events is called THEN it SHALL return events without blocking indefinitely\n3. WHEN send_output is called THEN it SHALL inject keys asynchronously\n4. WHEN driver is running THEN it SHALL use channels for cross-thread communication\n5. WHEN engine stops THEN driver threads SHALL terminate within 100ms\n6. IF driver thread panics THEN engine SHALL detect and report error\n\n### REQ-6: Latency Requirements\n\n**User Story:** As a user, I want key remapping to feel instantaneous, so that my typing is not affected.\n\n#### Acceptance Criteria\n\n1. WHEN processing a key event THEN total latency SHALL be < 1ms (capture + process + inject)\n2. WHEN benchmarking THEN p99 latency SHALL be < 2ms\n3. WHEN running THEN latency stats SHALL be available via `keyrx state --latency`\n4. WHEN latency exceeds threshold THEN warning SHALL be logged\n5. IF script execution is slow THEN it SHALL be measured separately from driver latency\n6. WHEN profiling THEN driver overhead vs script overhead SHALL be distinguishable\n\n### REQ-7: Graceful Degradation\n\n**User Story:** As a user, I want KeyRx to handle errors gracefully, so that my keyboard always works.\n\n#### Acceptance Criteria\n\n1. IF driver initialization fails THEN keyboard SHALL continue working normally\n2. IF driver crashes during operation THEN keyboard grab SHALL be released\n3. WHEN Ctrl+C is pressed THEN graceful shutdown SHALL occur within 500ms\n4. WHEN SIGTERM is received (Linux) THEN graceful shutdown SHALL occur\n5. IF panic occurs in driver thread THEN keyboard SHALL be restored to normal\n6. WHEN recovering from error THEN no key events SHALL be lost or duplicated\n\n### REQ-8: Device Selection\n\n**User Story:** As a user with multiple keyboards, I want to select which keyboard to remap, so that I can use different configs for different devices.\n\n#### Acceptance Criteria\n\n1. WHEN running `keyrx devices` THEN all connected keyboards SHALL be listed\n2. WHEN listing devices THEN device name, vendor ID, product ID SHALL be shown\n3. WHEN starting with `--device <id>` THEN only that device SHALL be grabbed\n4. WHEN no device specified THEN first keyboard device SHALL be used\n5. IF specified device is not found THEN clear error with device list SHALL be shown\n6. WHEN device is hot-plugged THEN it SHALL be detectable via `keyrx devices`\n\n## Non-Functional Requirements\n\n### Performance\n- Keyboard capture latency: < 100μs\n- Key injection latency: < 100μs\n- Total end-to-end latency: < 1ms (p50), < 2ms (p99)\n- Memory overhead: < 10MB for driver threads\n- CPU usage: < 1% idle, < 5% during typing\n\n### Reliability\n- Zero lost key events during normal operation\n- Keyboard always recoverable after crash\n- No stuck keys after driver restart\n- Signal handlers registered for cleanup\n\n### Security\n- No elevated privileges required on properly configured systems\n- udev rules for Linux permission management\n- No network access from driver code\n\n### Compatibility\n- Linux: Kernel 5.0+, X11 and Wayland (via evdev)\n- Windows: Windows 10 build 1903+\n- Support for standard HID keyboards\n- USB and Bluetooth keyboards supported\n",
  "fileStats": {
    "size": 7251,
    "lines": 154,
    "lastModified": "2025-11-30T00:13:28.082Z"
  },
  "comments": []
}