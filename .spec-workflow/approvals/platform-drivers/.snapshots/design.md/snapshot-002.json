{
  "id": "snapshot_1764464511148_mypvwzsqv",
  "approvalId": "approval_1764461820950_vczzflqbq",
  "approvalTitle": "Platform-Drivers Design Document",
  "version": 2,
  "timestamp": "2025-11-30T01:01:51.148Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: platform-drivers\n\n## Overview\n\nThis design implements real keyboard capture and injection for Linux (evdev/uinput) and Windows (WH_KEYBOARD_LL/SendInput). The drivers replace the current stubs while maintaining the existing `InputSource` trait interface, enabling seamless integration with the Engine.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Trait Abstraction**: Drivers implement `InputSource` trait\n- **Tokio Async**: Driver threads communicate via async channels\n- **Platform Drivers**: Compile-time selection via `#[cfg(target_os)]`\n- **No Global State**: All driver state in struct instances\n\n### Project Structure (structure.md)\n- `core/src/drivers/linux.rs` - Linux evdev/uinput implementation\n- `core/src/drivers/windows.rs` - Windows hook implementation\n- `core/src/drivers/common.rs` - Shared utilities (device listing)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`InputSource` trait** (`traits/input_source.rs`): Already defined with poll_events, send_output, start, stop\n- **`InputEvent`, `OutputAction`** (`engine/types.rs`): Event types already defined\n- **`KeyCode`** (`engine/types.rs`): Key mapping with evdev/VK conversion stubs already present\n- **`evdev_to_keycode`** (`drivers/linux.rs:156-269`): Mapping already implemented\n- **`vk_to_keycode`** (`drivers/windows.rs:104-235`): Mapping already implemented\n- **`keycode_to_vk`** (`drivers/windows.rs:240-367`): Reverse mapping exists\n\n### Integration Points\n- **Engine**: Uses `InputSource` trait, no changes needed\n- **CLI run command**: Already creates driver based on platform\n- **Benchmarks**: Already measure event processing latency\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Linux Driver\"\n        A[Physical Keyboard] -->|evdev| B[/dev/input/eventX]\n        B -->|EVIOCGRAB| C[LinuxInput]\n        C -->|channel| D[Async Event Queue]\n        D --> E[Engine]\n        E --> F[uinput Writer]\n        F -->|/dev/uinput| G[Virtual Keyboard]\n        G --> H[Applications]\n    end\n\n    subgraph \"Windows Driver\"\n        I[Physical Keyboard] --> J[WH_KEYBOARD_LL]\n        J -->|callback| K[Hook Thread]\n        K -->|channel| L[Async Event Queue]\n        L --> M[Engine]\n        M --> N[SendInput]\n        N --> O[Applications]\n    end\n```\n\n### Thread Model\n\n```\nLinux:\n┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\n│   evdev Reader  │────▶│  Async Channel  │────▶│     Engine      │\n│   (blocking)    │     │   (bounded)     │     │   (async)       │\n└─────────────────┘     └─────────────────┘     └────────┬────────┘\n                                                         │\n                                                         ▼\n                                                ┌─────────────────┐\n                                                │  uinput Writer  │\n                                                │   (blocking)    │\n                                                └─────────────────┘\n\nWindows:\n┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\n│  Message Pump   │────▶│  Async Channel  │────▶│     Engine      │\n│  + Hook Callback│     │   (bounded)     │     │   (async)       │\n└─────────────────┘     └─────────────────┘     └────────┬────────┘\n                                                         │\n                                                         ▼\n                                                ┌─────────────────┐\n                                                │    SendInput    │\n                                                │   (same thread) │\n                                                └─────────────────┘\n```\n\n## Components and Interfaces\n\n### Component 1: Linux evdev Reader\n- **Purpose**: Capture keyboard events from /dev/input/eventX\n- **Files**: `core/src/drivers/linux.rs`\n- **Thread**: Dedicated blocking thread (evdev read is blocking)\n- **Interface**:\n  ```rust\n  struct EvdevReader {\n      device: evdev::Device,\n      tx: Sender<InputEvent>,\n      running: Arc<AtomicBool>,\n  }\n\n  impl EvdevReader {\n      fn spawn(device_path: &Path, tx: Sender<InputEvent>) -> JoinHandle<()>;\n      fn grab(&mut self) -> Result<()>;  // EVIOCGRAB\n      fn ungrab(&mut self) -> Result<()>;\n  }\n  ```\n- **Dependencies**: evdev crate, crossbeam-channel\n\n### Component 2: Linux uinput Writer\n- **Purpose**: Inject remapped keys via virtual keyboard\n- **Files**: `core/src/drivers/linux.rs`\n- **Interface**:\n  ```rust\n  struct UinputWriter {\n      device: evdev::UInputDevice,\n  }\n\n  impl UinputWriter {\n      fn new(name: &str) -> Result<Self>;\n      fn emit(&mut self, key: KeyCode, pressed: bool) -> Result<()>;\n      fn sync(&mut self) -> Result<()>;\n  }\n  ```\n- **Dependencies**: evdev crate (uinput feature)\n\n### Component 3: LinuxInput (InputSource)\n- **Purpose**: Coordinate evdev reader and uinput writer\n- **Files**: `core/src/drivers/linux.rs`\n- **Interface**:\n  ```rust\n  pub struct LinuxInput {\n      reader_handle: Option<JoinHandle<()>>,\n      writer: UinputWriter,\n      rx: Receiver<InputEvent>,\n      running: Arc<AtomicBool>,\n      device_path: PathBuf,\n  }\n\n  impl LinuxInput {\n      pub fn new(device_path: Option<PathBuf>) -> Result<Self>;\n      pub fn list_devices() -> Result<Vec<DeviceInfo>>;\n  }\n\n  impl InputSource for LinuxInput { ... }\n  ```\n\n### Component 4: Windows Hook Manager\n- **Purpose**: Install and manage WH_KEYBOARD_LL hook\n- **Files**: `core/src/drivers/windows.rs`\n- **Thread**: Message pump thread required for hook callbacks\n- **Interface**:\n  ```rust\n  struct HookManager {\n      hook_handle: HHOOK,\n      tx: Sender<InputEvent>,\n      running: Arc<AtomicBool>,\n  }\n\n  impl HookManager {\n      fn install(tx: Sender<InputEvent>) -> Result<Self>;\n      fn uninstall(&mut self) -> Result<()>;\n      fn run_message_loop(&self);  // Blocking\n  }\n  ```\n- **Dependencies**: windows-rs crate\n\n### Component 5: Windows SendInput Injector\n- **Purpose**: Inject remapped keys via SendInput API\n- **Files**: `core/src/drivers/windows.rs`\n- **Interface**:\n  ```rust\n  struct SendInputInjector;\n\n  impl SendInputInjector {\n      fn inject_key(key: KeyCode, pressed: bool) -> Result<()>;\n      fn inject_sequence(keys: &[(KeyCode, bool)]) -> Result<()>;\n  }\n  ```\n- **Dependencies**: windows-rs crate\n\n### Component 6: WindowsInput (InputSource)\n- **Purpose**: Coordinate hook and injection\n- **Files**: `core/src/drivers/windows.rs`\n- **Interface**:\n  ```rust\n  pub struct WindowsInput {\n      hook_thread: Option<JoinHandle<()>>,\n      rx: Receiver<InputEvent>,\n      running: Arc<AtomicBool>,\n  }\n\n  impl WindowsInput {\n      pub fn new() -> Result<Self>;\n  }\n\n  impl InputSource for WindowsInput { ... }\n  ```\n\n### Component 7: Device Listing\n- **Purpose**: List available keyboard devices\n- **Files**: `core/src/drivers/common.rs`, CLI command\n- **Interface**:\n  ```rust\n  pub struct DeviceInfo {\n      pub path: PathBuf,      // Linux: /dev/input/event3\n      pub name: String,       // \"AT Translated Set 2 keyboard\"\n      pub vendor_id: u16,\n      pub product_id: u16,\n      pub is_keyboard: bool,\n  }\n\n  pub fn list_keyboards() -> Result<Vec<DeviceInfo>>;\n  ```\n\n## Data Models\n\n### InputEvent (Updated for REQ-9)\n```rust\n/// Keyboard event with comprehensive metadata for advanced remapping features.\n/// All fields are captured at driver level; scripts can ignore fields they don't need.\n#[derive(Debug, Clone, Serialize)]\npub struct InputEvent {\n    /// The logical key that was pressed/released\n    pub key: KeyCode,\n    /// true = key down, false = key up\n    pub pressed: bool,\n    /// Microseconds since driver started (for timing-based features like tap-hold)\n    pub timestamp_us: u64,\n    /// Source device identifier (for multi-keyboard configs)\n    /// Linux: \"/dev/input/event3\", Windows: device instance ID\n    pub device_id: Option<String>,\n    /// true if this is an auto-repeat event (not initial press)\n    pub is_repeat: bool,\n    /// true if this event was injected by software (including our own uinput/SendInput)\n    /// CRITICAL: Used to prevent infinite loops - skip processing synthetic events\n    pub is_synthetic: bool,\n    /// Raw hardware scan code (for physical key position regardless of layout)\n    pub scan_code: u16,\n}\n```\n\n### Metadata Capture by Platform\n\n```\nLinux (evdev):\n┌─────────────────────────────────────────────────────────────────┐\n│ evdev::InputEvent                                               │\n│ ├── time: timeval          → timestamp_us (convert to μs)       │\n│ ├── type: EV_KEY                                                │\n│ ├── code: KEY_A            → scan_code, key (via evdev_to_keycode)│\n│ └── value: 0/1/2           → pressed (1), is_repeat (2)         │\n│                                                                 │\n│ device path                → device_id                          │\n│ compare to uinput fd       → is_synthetic                       │\n└─────────────────────────────────────────────────────────────────┘\n\nWindows (WH_KEYBOARD_LL):\n┌─────────────────────────────────────────────────────────────────┐\n│ KBDLLHOOKSTRUCT                                                 │\n│ ├── vkCode                 → key (via vk_to_keycode)            │\n│ ├── scanCode               → scan_code                          │\n│ ├── flags                                                       │\n│ │   ├── LLKHF_INJECTED     → is_synthetic                       │\n│ │   └── LLKHF_EXTENDED     → (used for keycode mapping)         │\n│ └── time                   → timestamp_us (ms * 1000)           │\n│                                                                 │\n│ wParam (WM_KEYDOWN/UP)     → pressed                            │\n│ track previous key state   → is_repeat                          │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### DeviceInfo\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct DeviceInfo {\n    /// Device path (Linux: /dev/input/eventX, Windows: device instance ID)\n    pub path: PathBuf,\n    /// Human-readable device name\n    pub name: String,\n    /// USB Vendor ID\n    pub vendor_id: u16,\n    /// USB Product ID\n    pub product_id: u16,\n    /// Whether this is a keyboard device\n    pub is_keyboard: bool,\n}\n```\n\n### LatencyStats\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct LatencyStats {\n    pub capture_us: u64,    // Time from hardware to driver\n    pub process_us: u64,    // Time in script runtime\n    pub inject_us: u64,     // Time to output key\n    pub total_us: u64,      // End-to-end latency\n    pub sample_count: usize,\n}\n```\n\n## Error Handling\n\n### Linux-Specific Errors\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum LinuxDriverError {\n    #[error(\"Device not found: {path}\")]\n    DeviceNotFound { path: PathBuf },\n\n    #[error(\"Permission denied accessing {path}. Run: sudo usermod -aG input $USER\")]\n    PermissionDenied { path: PathBuf },\n\n    #[error(\"Failed to grab keyboard: {0}\")]\n    GrabFailed(#[source] std::io::Error),\n\n    #[error(\"Failed to create uinput device: {0}\")]\n    UinputFailed(#[source] std::io::Error),\n\n    #[error(\"evdev error: {0}\")]\n    Evdev(#[from] evdev::Error),\n}\n```\n\n### Windows-Specific Errors\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum WindowsDriverError {\n    #[error(\"Failed to install keyboard hook: {0}\")]\n    HookInstallFailed(windows::core::Error),\n\n    #[error(\"SendInput failed: error code {0}\")]\n    SendInputFailed(u32),\n\n    #[error(\"Message pump thread panicked\")]\n    MessagePumpPanic,\n\n    #[error(\"Hook callback timeout exceeded\")]\n    HookTimeout,\n}\n```\n\n### Recovery Strategies\n\n1. **Initialization Failure**: Return error, keyboard continues normally\n2. **Runtime Grab Loss**: Attempt re-grab once, then shutdown gracefully\n3. **Injection Failure**: Log error, skip this key, continue\n4. **Thread Panic**: Set running=false, cleanup in Drop impl\n\n## Testing Strategy\n\n### Unit Testing\n- Key code conversion: evdev ↔ KeyCode ↔ VK roundtrips\n- Event serialization and channel passing\n- Error type construction and messages\n\n### Integration Testing\n- Mock evdev device for Linux (requires /dev/uinput access)\n- Virtual keyboard injection and verification\n- Start/stop lifecycle without real keyboard\n\n### Manual Testing Checklist\n- [ ] Single key remap (CapsLock → Escape)\n- [ ] Key blocking (Insert → nothing)\n- [ ] Modifier combinations (Ctrl+C)\n- [ ] Rapid key repeat\n- [ ] Multiple keyboards (if available)\n- [ ] Hot-unplug during operation\n- [ ] Ctrl+C graceful shutdown\n- [ ] Kill -9 keyboard recovery\n\n### Performance Testing\n- Latency measurement under load (100 keys/sec)\n- Memory usage over 1 hour operation\n- CPU usage during idle and typing\n\n## File Changes Summary\n\n| File | Action | Purpose |\n|------|--------|---------|\n| `core/src/drivers/linux.rs` | Rewrite | Full evdev/uinput implementation |\n| `core/src/drivers/windows.rs` | Rewrite | Full WH_KEYBOARD_LL implementation |\n| `core/src/drivers/common.rs` | Create | Shared device listing logic |\n| `core/src/drivers/mod.rs` | Modify | Export new types, re-export platform driver |\n| `core/src/cli/commands/devices.rs` | Create | `keyrx devices` command |\n| `core/src/cli/commands/mod.rs` | Modify | Export DevicesCommand |\n| `core/src/bin/keyrx.rs` | Modify | Add devices subcommand |\n| `core/src/error.rs` | Modify | Add driver error variants |\n| `core/Cargo.toml` | Modify | Add evdev uinput feature |\n| `core/tests/driver_test.rs` | Create | Driver integration tests |\n\n## Platform-Specific Notes\n\n### Linux\n- Requires `input` group membership or udev rules\n- evdev grab prevents other applications from seeing keys\n- uinput virtual device appears as new keyboard\n- Wayland compatible (evdev is kernel-level)\n\n### Windows\n- Hook runs in context of installing thread\n- Requires message pump for callbacks\n- SendInput subject to UIPI (User Interface Privilege Isolation)\n- May trigger antivirus warnings (keyboard hook)\n\n## Security Considerations\n\n- Driver code has no network access\n- No file system access beyond /dev/input and /dev/uinput\n- Rhai sandbox prevents script access to driver internals\n- Keyboard state not persisted to disk\n",
  "fileStats": {
    "size": 15539,
    "lines": 411,
    "lastModified": "2025-11-30T00:59:16.024Z"
  },
  "comments": []
}