{
  "id": "snapshot_1764768909598_8voulrhm0",
  "approvalId": "approval_1764768817482_nkn871qg3",
  "approvalTitle": "Widget Decomposition Requirements",
  "version": 2,
  "timestamp": "2025-12-03T13:35:09.598Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe `editor_widgets.dart` file is 1035 lines containing 15+ widget classes with mixed responsibilities. Large widget files hurt maintainability, testability, and make code navigation difficult. This spec decomposes the monolithic widget file into focused, single-purpose widget components following Flutter best practices.\n\n## Alignment with Product Vision\n\nThis feature supports KeyRx's product principles:\n- **Maintainability**: Small, focused widgets are easier to understand\n- **Testability**: Isolated widgets can be unit tested\n- **Performance**: Smaller widgets enable better rebuild optimization\n\nPer tech.md: \"Max 500 lines/file\" - current file exceeds this by 2x.\n\n## Requirements\n\n### Requirement 1: Widget Extraction\n\n**User Story:** As a developer, I want each widget in its own file, so that I can find and modify widgets quickly.\n\n#### Acceptance Criteria\n\n1. WHEN a widget has > 100 lines THEN it SHALL be in its own file\n2. IF a widget has helper methods THEN they SHALL be private to that widget\n3. WHEN widgets are extracted THEN imports SHALL be updated throughout codebase\n4. IF a widget has state THEN StatefulWidget and State SHALL be in same file\n\n### Requirement 2: Widget Organization\n\n**User Story:** As a developer, I want widgets organized by feature, so that related widgets are discoverable.\n\n#### Acceptance Criteria\n\n1. WHEN widgets are extracted THEN they SHALL be in feature subdirectories\n2. IF widgets share styling THEN a shared theme file SHALL exist\n3. WHEN a widget is reusable THEN it SHALL be in `widgets/common/`\n4. IF a widget is page-specific THEN it SHALL be in `widgets/{page}/`\n\n### Requirement 3: Widget Composition\n\n**User Story:** As a developer, I want widgets to be composable, so that I can build complex UIs from simple parts.\n\n#### Acceptance Criteria\n\n1. WHEN a widget has > 3 responsibilities THEN it SHALL be split\n2. IF a widget builds other widgets THEN composition SHALL be used\n3. WHEN widgets communicate THEN callbacks or providers SHALL be used\n4. IF state is shared THEN a state management solution SHALL coordinate\n\n### Requirement 4: Widget Testing\n\n**User Story:** As a developer, I want widgets testable in isolation, so that I can verify widget behavior.\n\n#### Acceptance Criteria\n\n1. WHEN a widget is extracted THEN a test file SHALL be created\n2. IF a widget has logic THEN unit tests SHALL cover it\n3. WHEN widgets interact THEN integration tests SHALL verify\n4. IF a widget renders differently THEN golden tests SHALL exist\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility**: One widget per file\n- **Modular Design**: Feature-based directory structure\n- **Dependency Management**: Minimal cross-widget dependencies\n- **Clear Interfaces**: Widget APIs defined by constructors\n\n### Performance\n- Widget rebuilds SHALL be optimized with const constructors\n- Large lists SHALL use ListView.builder\n- Expensive computations SHALL be memoized\n\n### Maintainability\n- No file SHALL exceed 300 lines\n- Widget names SHALL be descriptive\n- Public widgets SHALL have documentation\n",
  "fileStats": {
    "size": 3135,
    "lines": 79,
    "lastModified": "2025-12-03T13:33:09.746Z"
  },
  "comments": []
}