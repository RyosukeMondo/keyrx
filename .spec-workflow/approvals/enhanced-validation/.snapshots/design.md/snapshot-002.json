{
  "id": "snapshot_1765451883452_lbgpydt93",
  "approvalId": "approval_1765451762824_c09pzq1et",
  "approvalTitle": "Enhanced Validation - Design",
  "version": 2,
  "timestamp": "2025-12-11T11:18:03.452Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Enhanced Validation feature transforms the existing `contract_adherence.rs` test from simple string matching to comprehensive static analysis using Rust's `syn` crate for AST parsing. This ensures that every FFI function signature exactly matches its JSON contract, eliminating type mismatches, missing parameters, and incorrect return types at compile time.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **Dependency Injection**: The validation system will be testable through trait abstractions for file loading and parsing\n- **Error Handling**: Fail-fast validation with structured error types following KeyRx's custom exception hierarchy\n- **Testing Framework**: Uses `cargo test` with detailed error reporting; integrates seamlessly with CI/CD pipeline\n- **CLI First**: The test runs as part of `cargo test` and can be invoked directly for rapid validation\n\n### Project Structure (structure.md)\n\n- **Location**: `core/tests/contract_adherence.rs` (existing file, enhanced)\n- **Module Organization**: Separate modules for parsing, validation, and reporting within the test\n- **Naming Conventions**: Follows Rust conventions with `snake_case` functions and `PascalCase` structs\n- **Code Size**: Each validation function under 50 lines; total file under 500 lines\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **ContractRegistry**: Already exists at `core/src/ffi/contract.rs` - loads and parses all `.ffi-contract.json` files\n- **FfiContract / FunctionContract**: Existing structs for representing contract data\n- **TypeDefinition**: Already handles primitive, object, array, and enum types\n- **File Discovery**: Current test already uses `walkdir` to find contract files\n\n### Integration Points\n\n- **Cargo Test Infrastructure**: Integrates as a standard `#[test]` function\n- **Contract Directory**: Reads from `core/src/ffi/contracts/`\n- **FFI Exports**: Validates against `core/src/ffi/exports.rs` and domain-specific FFI modules\n\n## Architecture\n\nThe enhanced validation system follows a pipeline architecture:\n\n```\nContracts (JSON) → Load → Parse Rust → Extract Signatures → Validate → Report\n```\n\n### Modular Design Principles\n\n- **Single Responsibility**: Each function handles one validation concern (signature matching, type mapping, error reporting)\n- **Component Isolation**: Parser, validator, and reporter are separate modules that can be tested independently\n- **Service Layer Separation**: Contract loading, AST parsing, and validation logic are cleanly separated\n\n```mermaid\ngraph TD\n    A[Load Contracts from JSON] --> B[Parse exports.rs with syn]\n    B --> C[Extract Function Signatures]\n    C --> D[Validate Signatures]\n    D --> E{All Valid?}\n    E -->|Yes| F[Test Pass]\n    E -->|No| G[Generate Error Report]\n    G --> H[Test Fail with Details]\n```\n\n## Components and Interfaces\n\n### Component 1: Contract Loader\n- **Purpose:** Load all FFI contracts from the contracts directory\n- **Interfaces:**\n  - `load_all_contracts() -> Result<Vec<FfiContract>, Error>`\n- **Dependencies:** `ContractRegistry`, file system\n- **Reuses:** Existing `ContractRegistry::load_from_dir()`\n\n### Component 2: Rust AST Parser\n- **Purpose:** Parse Rust source files and extract `extern \"C\"` function signatures\n- **Interfaces:**\n  - `parse_ffi_exports(file_path: &Path) -> Result<Vec<ParsedFunction>, syn::Error>`\n- **Dependencies:** `syn` crate for AST parsing\n- **Reuses:** None (new functionality)\n\n**Implementation Details:**\n```rust\nstruct ParsedFunction {\n    name: String,              // Function name\n    params: Vec<ParsedParam>,  // Parameters with types\n    return_type: ParsedType,   // Return type\n    file_path: PathBuf,        // Source file\n    line_number: usize,        // Line number\n}\n\nstruct ParsedParam {\n    name: String,\n    rust_type: String,         // e.g., \"*const c_char\"\n    is_pointer: bool,\n    is_mutable: bool,\n}\n\nenum ParsedType {\n    Unit,                      // ()\n    Pointer { target: String, is_mut: bool },\n    Primitive(String),         // i32, bool, etc.\n}\n```\n\n### Component 3: Type Mapper\n- **Purpose:** Map contract types to expected Rust FFI types\n- **Interfaces:**\n  - `map_contract_to_rust(contract_type: &str) -> RustFfiType`\n  - `validate_type_match(contract: &str, rust: &ParsedType) -> Result<(), TypeMismatch>`\n- **Dependencies:** None\n- **Reuses:** None (new functionality)\n\n**Type Mapping Rules:**\n| Contract Type | Rust FFI Type |\n|--------------|---------------|\n| `string` | `*const c_char` |\n| `int` | `i32` |\n| `bool` | `bool` |\n| `void` | `()` |\n| `Vec<T>` | `*const c_char` (JSON array) |\n| Custom structs | `*const c_char` (JSON object) |\n| Error pointer | `*mut *mut c_char` (always last param) |\n\n### Component 4: Signature Validator\n- **Purpose:** Compare contract function definitions against parsed Rust signatures\n- **Interfaces:**\n  - `validate_function(contract: &FunctionContract, parsed: &ParsedFunction) -> Result<(), ValidationError>`\n  - `validate_all_functions(contracts: &[FfiContract], parsed: &[ParsedFunction]) -> ValidationReport`\n- **Dependencies:** Type Mapper\n- **Reuses:** None (new functionality)\n\n**Validation Checks:**\n1. Function exists in parsed functions\n2. Parameter count matches (accounting for error pointer)\n3. Each parameter type matches the mapped contract type\n4. Return type matches the contract return type\n5. Error pointer is present as last parameter\n\n### Component 5: Error Reporter\n- **Purpose:** Generate comprehensive, actionable error messages\n- **Interfaces:**\n  - `report_missing_function(name: &str, contract_file: &str) -> String`\n  - `report_type_mismatch(func: &str, param: &str, expected: &str, found: &str, location: FileLocation) -> String`\n  - `generate_full_report(errors: Vec<ValidationError>) -> String`\n- **Dependencies:** None\n- **Reuses:** None (new functionality)\n\n**Error Message Format:**\n```\n❌ Validation Errors Found:\n\n1. Function keyrx_config_save_hardware_profile\n   File: core/src/ffi/domains/config.rs:45\n   Contract: core/src/ffi/contracts/config.ffi-contract.json\n\n   Type Mismatch in return type:\n   Expected: *const c_char (HardwareProfile)\n   Found:    ()\n\n   Fix: Change return type from () to *const c_char and serialize the result\n\n2. Function keyrx_discovery_scan_devices\n   Contract: core/src/ffi/contracts/discovery.ffi-contract.json\n\n   Missing: This function is defined in the contract but not found in the codebase.\n\n   Fix: Implement this function in core/src/ffi/domains/discovery.rs\n```\n\n## Data Models\n\n### ValidationError\n```rust\n#[derive(Debug, Clone)]\nenum ValidationError {\n    MissingFunction {\n        name: String,\n        contract_file: String,\n    },\n    ParameterCountMismatch {\n        function: String,\n        expected: usize,\n        found: usize,\n        location: FileLocation,\n    },\n    ParameterTypeMismatch {\n        function: String,\n        param_name: String,\n        expected_type: String,\n        found_type: String,\n        location: FileLocation,\n    },\n    ReturnTypeMismatch {\n        function: String,\n        expected_type: String,\n        found_type: String,\n        location: FileLocation,\n    },\n    UncontractedFunction {\n        name: String,\n        location: FileLocation,\n    },\n}\n\n#[derive(Debug, Clone)]\nstruct FileLocation {\n    file: PathBuf,\n    line: usize,\n}\n```\n\n### ValidationReport\n```rust\nstruct ValidationReport {\n    total_functions: usize,\n    validated: usize,\n    errors: Vec<ValidationError>,\n    warnings: Vec<ValidationWarning>,\n}\n\nimpl ValidationReport {\n    fn is_success(&self) -> bool {\n        self.errors.is_empty()\n    }\n\n    fn format_for_display(&self) -> String {\n        // Human-readable error report\n    }\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Contract JSON Parse Error**\n   - **Handling:** Fail the test immediately with the JSON parse error\n   - **User Impact:** Developer sees which contract file has invalid JSON\n\n2. **Rust Syntax Error**\n   - **Handling:** Fail with `syn` error pointing to problematic Rust code\n   - **User Impact:** Developer sees which file and line has invalid Rust syntax\n\n3. **Type Mismatch**\n   - **Handling:** Collect all mismatches and report at the end\n   - **User Impact:** Developer sees all type mismatches with expected vs found types\n\n4. **Missing Function**\n   - **Handling:** Collect all missing functions and report at the end\n   - **User Impact:** Developer sees which contract functions are not implemented\n\n5. **Uncontracted Function**\n   - **Handling:** Warning if < 10% uncontracted, error if ≥ 10%\n   - **User Impact:** Developer is warned about FFI functions without contracts\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Parser Tests**: Test `syn` parsing with sample Rust function signatures\n  - Input: Rust function string\n  - Output: `ParsedFunction` struct\n  - Cases: Various parameter types, return types, pointer variations\n\n- **Type Mapper Tests**: Verify contract type to Rust FFI type mappings\n  - Input: Contract type string\n  - Output: Expected Rust type\n  - Cases: All primitive types, custom types, arrays, void\n\n- **Validator Tests**: Test signature matching logic\n  - Input: Contract function + Parsed function\n  - Output: Validation result\n  - Cases: Exact matches, type mismatches, missing parameters\n\n### Integration Testing\n\n- **End-to-End Validation**: Test against real contract files\n  - Create temporary Rust files with deliberate errors\n  - Run validation\n  - Verify errors are caught correctly\n\n- **Contract Completeness**: Test uncontracted function detection\n  - Create FFI function without contract\n  - Run validation\n  - Verify warning is generated\n\n### End-to-End Testing\n\n- **CI Integration**: Run as part of `cargo test` in CI pipeline\n  - All contracts validated on every PR\n  - Build fails if validation errors exist\n  - Report shown in CI logs\n\n- **Developer Workflow**: Test can be run locally before commit\n  - `cargo test contract_adherence`\n  - Clear, actionable error messages\n  - File locations for quick navigation\n\n## Implementation Phases\n\n### Phase 1: AST Parsing\n1. Add `syn` dependency to `Cargo.toml`\n2. Implement `parse_ffi_exports()` function\n3. Extract function names, parameters, and return types\n4. Unit test the parser with sample functions\n\n### Phase 2: Type Mapping\n1. Implement type mapping rules\n2. Handle pointer types, primitives, and void\n3. Unit test all type mappings\n\n### Phase 3: Validation Logic\n1. Implement signature comparison\n2. Check parameter counts and types\n3. Validate return types\n4. Unit test validation logic\n\n### Phase 4: Error Reporting\n1. Implement detailed error messages\n2. Include file locations and fix suggestions\n3. Format report for readability\n\n### Phase 5: Integration\n1. Replace string matching in `contract_adherence.rs`\n2. Run against real contracts\n3. Fix any discovered issues\n4. Document in README\n",
  "fileStats": {
    "size": 10874,
    "lines": 326,
    "lastModified": "2025-12-11T11:13:37.079Z"
  },
  "comments": []
}