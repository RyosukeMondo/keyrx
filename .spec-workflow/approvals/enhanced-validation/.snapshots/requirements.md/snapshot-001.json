{
  "id": "snapshot_1765450427545_a2co29byt",
  "approvalId": "approval_1765450427478_f8s6syh8y",
  "approvalTitle": "Enhanced Validation - Requirements",
  "version": 1,
  "timestamp": "2025-12-11T10:53:47.545Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe Enhanced Validation feature upgrades the existing `contract_adherence` test from a simple existence check to comprehensive static analysis that verifies FFI contract correctness. This eliminates runtime FFI errors by ensuring that Rust implementations match their JSON contract definitions at compile time.\n\n**Current Problem**: The existing `tests/contract_adherence.rs` only checks if functions exist but doesn't verify that their signatures match the contract. This allows mismatches like returning `void` when `HardwareProfile` is expected, leading to runtime crashes.\n\n**Solution**: Parse Rust AST using `syn` to extract actual function signatures and compare them against the JSON contract, failing the build if mismatches are detected.\n\n## Alignment with Product Vision\n\nThis feature directly supports KeyRx's \"Safety First\" principle by preventing FFI crashes before they reach production. It aligns with the CLI-first development philosophy by providing compile-time guarantees without requiring manual testing. This eliminates an entire class of bugs that could undermine user trust in the remapping engine.\n\nBy establishing the JSON Contract as the Single Source of Truth (SSOT), this feature lays the foundation for future code generation (Phase 3), making KeyRx's FFI layer more maintainable and reliable.\n\n## Requirements\n\n### Requirement 1: Parse Rust Function Signatures\n\n**User Story:** As a developer, I want the build system to automatically parse Rust FFI function signatures, so that type mismatches are detected without manual inspection.\n\n#### Acceptance Criteria\n\n1. WHEN the test runs THEN it SHALL use `syn` to parse `core/src/ffi/exports.rs`\n2. WHEN parsing completes THEN it SHALL extract all `extern \"C\"` function signatures including:\n   - Function name\n   - Parameter names and types\n   - Return type\n   - Whether parameters are pointers (`*const`, `*mut`)\n3. IF parsing fails (invalid Rust syntax) THEN the test SHALL fail with a clear error message indicating the file and line number\n\n### Requirement 2: Validate Function Signatures Against Contracts\n\n**User Story:** As a developer, I want function signatures to be validated against their JSON contracts, so that I'm immediately notified when they drift out of sync.\n\n#### Acceptance Criteria\n\n1. WHEN validation runs THEN it SHALL load all `*.ffi-contract.json` files from the contracts directory\n2. FOR EACH function in the contract THEN it SHALL:\n   - Verify the function exists in `exports.rs`\n   - Verify parameter count matches\n   - Verify parameter types match (with FFI type mappings)\n   - Verify return type matches the expected contract type\n3. WHEN a function is missing THEN the test SHALL fail with message: \"Contract function `{name}` not found in exports.rs\"\n4. WHEN parameter count mismatches THEN the test SHALL fail with: \"Function `{name}` expects {expected} parameters, found {actual}\"\n5. WHEN parameter type mismatches THEN the test SHALL fail with: \"Function `{name}` parameter `{param}` expects type `{expected}`, found `{actual}`\"\n6. WHEN return type mismatches THEN the test SHALL fail with: \"Function `{name}` expects return type `{expected}`, found `{actual}`\"\n\n### Requirement 3: FFI Type Mapping Rules\n\n**User Story:** As a developer, I want clear rules for how Rust FFI types map to contract types, so that validation is consistent and predictable.\n\n#### Acceptance Criteria\n\n1. WHEN validating types THEN it SHALL apply these mappings:\n   - Contract `string` → Rust `*const c_char`\n   - Contract `int` → Rust `i32`\n   - Contract `bool` → Rust `bool`\n   - Contract `{CustomType}` → Rust `*const c_char` (JSON serialized)\n   - Contract `void` → Rust `()`\n   - Contract result wrapper → Rust `*mut *mut c_char` (error out parameter)\n2. WHEN a contract type has no mapping THEN the test SHALL fail with: \"Unknown contract type `{type}` in function `{name}`\"\n3. WHEN a custom type is expected THEN it SHALL accept JSON string pointers (`*const c_char`)\n\n### Requirement 4: Comprehensive Error Reporting\n\n**User Story:** As a developer, I want detailed error messages when validation fails, so that I can quickly identify and fix the issue.\n\n#### Acceptance Criteria\n\n1. WHEN any validation fails THEN the test SHALL output:\n   - Which contract file contained the violation\n   - Which function failed validation\n   - What was expected vs. what was found\n   - The file and line number of the Rust function\n2. WHEN multiple violations exist THEN it SHALL report ALL violations, not just the first one\n3. WHEN validation succeeds THEN it SHALL output: \"All {count} FFI functions validated successfully against contracts\"\n\n### Requirement 5: Contract Completeness Check\n\n**User Story:** As a developer, I want to ensure all FFI functions have contracts, so that no function is left undocumented.\n\n#### Acceptance Criteria\n\n1. WHEN validation runs THEN it SHALL identify all `extern \"C\"` functions in `exports.rs`\n2. FOR EACH FFI function THEN it SHALL verify a corresponding contract entry exists\n3. WHEN a function has no contract THEN the test SHALL warn: \"Function `{name}` in exports.rs has no contract definition\"\n4. IF more than 10% of functions are missing contracts THEN the test SHALL fail\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility**: `contract_adherence.rs` handles only validation logic; parsing and type mapping are separate modules\n- **Modular Design**: Use separate functions for parsing, loading contracts, validating, and reporting\n- **Clear Interfaces**: Define structs for `ParsedFunction`, `ContractFunction`, and `ValidationError`\n\n### Performance\n\n- Validation SHALL complete in under 5 seconds on a typical development machine\n- Parsing SHALL cache AST results to avoid re-parsing unchanged files\n\n### Reliability\n\n- Validation SHALL never produce false positives (reporting an error when the contract is correct)\n- Validation SHALL never miss genuine mismatches (false negatives)\n- The test SHALL be deterministic and produce the same results on all platforms\n\n### Usability\n\n- Error messages SHALL be actionable and include file locations\n- The test SHALL integrate seamlessly with `cargo test` and CI pipelines\n- Documentation SHALL include examples of common contract errors and how to fix them\n",
  "fileStats": {
    "size": 6341,
    "lines": 115,
    "lastModified": "2025-12-11T10:53:36.786Z"
  },
  "comments": []
}