{
  "id": "snapshot_1764765558105_6ztczekx5",
  "approvalId": "approval_1764765558096_306a6kzj8",
  "approvalTitle": "Flutter Service Facade - Design",
  "version": 1,
  "timestamp": "2025-12-03T12:39:18.105Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design introduces `KeyrxFacade`, a unified service interface that wraps the 19 existing services behind a cohesive API. The facade coordinates multi-step operations, aggregates state streams, and simplifies testing by providing a single mock target. It coexists with `ServiceRegistry` for backward compatibility.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Dependency Injection**: Facade accepts `ServiceRegistry` as constructor dependency\n- **No Global State**: Facade is an instance, not a singleton\n- **CLI First, GUI Later**: Facade operations mirror CLI commands for consistency\n\n### Project Structure (structure.md)\n- New files in `ui/lib/services/facade/`\n- Interface in `keyrx_facade.dart`, implementation in `keyrx_facade_impl.dart`\n- Mock in `ui/test/mocks/mock_keyrx_facade.dart`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`ServiceRegistry`**: Provides all underlying services\n- **`ErrorTranslator`**: Reused for error message translation\n- **`EngineService`/`DeviceService`**: Core services wrapped by facade\n\n### Integration Points\n- **`EditorPage`**: First migration candidate (uses 7+ services)\n- **Provider/State management**: Facade exposed via Provider for widget tree\n- **Existing tests**: Can gradually migrate to facade mocks\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"UI Layer\"\n        EP[EditorPage]\n        DP[DiscoveryPage]\n        TP[TestPage]\n    end\n\n    subgraph \"Facade Layer\"\n        KF[KeyrxFacade]\n        AS[Aggregated State Stream]\n    end\n\n    subgraph \"Service Layer\"\n        SR[ServiceRegistry]\n        ES[EngineService]\n        DS[DeviceService]\n        VS[ValidationService]\n        TS[TestService]\n        SS[ScriptFileService]\n        AU[AudioService]\n        PS[PermissionService]\n    end\n\n    EP --> KF\n    DP --> KF\n    TP --> KF\n\n    KF --> SR\n    KF --> AS\n\n    SR --> ES\n    SR --> DS\n    SR --> VS\n    SR --> TS\n    SR --> SS\n    SR --> AU\n    SR --> PS\n\n    AS -.->|combines| ES\n    AS -.->|combines| DS\n    AS -.->|combines| VS\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: `keyrx_facade.dart` (interface), `keyrx_facade_impl.dart` (impl), `facade_state.dart` (state models)\n- **Component Isolation**: Facade doesn't expose internal service instances\n- **Service Layer Separation**: Facade (coordination) → Services (domain) → FFI (boundary)\n- **Utility Modularity**: Shared error handling in `facade_error.dart`\n\n## Components and Interfaces\n\n### Component 1: KeyrxFacade Interface\n\n- **Purpose:** Define the unified API contract for all KeyRx operations\n- **Interfaces:**\n  ```dart\n  abstract class KeyrxFacade {\n    // === Factories ===\n    factory KeyrxFacade.real(ServiceRegistry registry) = KeyrxFacadeImpl;\n    factory KeyrxFacade.mock() = MockKeyrxFacade;\n\n    // === State ===\n    Stream<FacadeState> get stateStream;\n    FacadeState get currentState;\n\n    // === Engine Operations ===\n    Future<Result<void>> startEngine(String scriptPath);\n    Future<Result<void>> stopEngine();\n    Future<Result<EngineStatus>> getEngineStatus();\n\n    // === Script Operations ===\n    Future<Result<ValidationResult>> validateScript(String content);\n    Future<Result<String>> loadScript(String path);\n    Future<Result<void>> saveScript(String path, String content);\n\n    // === Device Operations ===\n    Future<Result<List<DeviceInfo>>> listDevices();\n    Future<Result<void>> startDiscovery(DeviceInfo device, LayoutConfig layout);\n    Future<Result<void>> cancelDiscovery();\n\n    // === Testing Operations ===\n    Future<Result<TestResults>> runTests(String scriptPath);\n    Future<Result<void>> cancelTests();\n\n    // === Lifecycle ===\n    Future<void> dispose();\n\n    // === Advanced Access ===\n    ServiceRegistry get services;  // Escape hatch for rare cases\n  }\n  ```\n- **Dependencies:** `ServiceRegistry`, `rxdart` (for stream combining)\n- **Reuses:** Service method signatures\n\n### Component 2: FacadeState\n\n- **Purpose:** Aggregated state combining engine, device, and validation status\n- **Interfaces:**\n  ```dart\n  @freezed\n  class FacadeState with _$FacadeState {\n    const factory FacadeState({\n      required EngineStatus engineStatus,\n      required DeviceStatus deviceStatus,\n      required ValidationStatus validationStatus,\n      required DiscoveryStatus discoveryStatus,\n      String? activeScriptPath,\n      String? lastError,\n    }) = _FacadeState;\n\n    factory FacadeState.initial() => FacadeState(\n      engineStatus: EngineStatus.stopped,\n      deviceStatus: DeviceStatus.disconnected,\n      validationStatus: ValidationStatus.none,\n      discoveryStatus: DiscoveryStatus.idle,\n    );\n  }\n\n  enum EngineStatus { stopped, starting, running, stopping, error }\n  enum DeviceStatus { disconnected, connecting, connected, error }\n  enum ValidationStatus { none, validating, valid, invalid }\n  enum DiscoveryStatus { idle, inProgress, completed, cancelled }\n  ```\n- **Dependencies:** `freezed` for immutable state\n- **Reuses:** Status enums from existing services\n\n### Component 3: KeyrxFacadeImpl\n\n- **Purpose:** Concrete implementation coordinating services\n- **Interfaces:**\n  ```dart\n  class KeyrxFacadeImpl implements KeyrxFacade {\n    KeyrxFacadeImpl(this._registry) {\n      _initStateStream();\n    }\n\n    final ServiceRegistry _registry;\n    final _stateController = BehaviorSubject<FacadeState>.seeded(FacadeState.initial());\n\n    @override\n    Future<Result<void>> startEngine(String scriptPath) async {\n      _updateState((s) => s.copyWith(engineStatus: EngineStatus.starting));\n\n      // Step 1: Validate script\n      final validation = await validateScript(await loadScript(scriptPath));\n      if (validation.isError) {\n        _updateState((s) => s.copyWith(engineStatus: EngineStatus.error));\n        return Result.error(validation.error);\n      }\n\n      // Step 2: Start engine\n      try {\n        await _registry.engineService.start(scriptPath);\n        _updateState((s) => s.copyWith(\n          engineStatus: EngineStatus.running,\n          activeScriptPath: scriptPath,\n        ));\n        return Result.ok(null);\n      } catch (e) {\n        _updateState((s) => s.copyWith(\n          engineStatus: EngineStatus.error,\n          lastError: _registry.errorTranslator.translate(e),\n        ));\n        return Result.error(FacadeError.fromException(e));\n      }\n    }\n  }\n  ```\n- **Dependencies:** `ServiceRegistry`, `rxdart`\n- **Reuses:** All existing service implementations\n\n### Component 4: Result Type\n\n- **Purpose:** Explicit success/failure without exceptions\n- **Interfaces:**\n  ```dart\n  @freezed\n  sealed class Result<T> with _$Result<T> {\n    const factory Result.ok(T value) = Ok<T>;\n    const factory Result.error(FacadeError error) = Err<T>;\n  }\n\n  extension ResultExtension<T> on Result<T> {\n    bool get isOk => this is Ok<T>;\n    bool get isError => this is Err<T>;\n    T get value => (this as Ok<T>).value;\n    FacadeError get error => (this as Err<T>).error;\n\n    Result<U> map<U>(U Function(T) f);\n    Future<Result<U>> flatMap<U>(Future<Result<U>> Function(T) f);\n  }\n  ```\n- **Dependencies:** `freezed`\n- **Reuses:** Pattern from Rust's Result type\n\n### Component 5: FacadeError\n\n- **Purpose:** Structured errors with user-friendly messages\n- **Interfaces:**\n  ```dart\n  @freezed\n  class FacadeError with _$FacadeError {\n    const factory FacadeError({\n      required String code,\n      required String message,\n      required String userMessage,\n      Object? originalError,\n      StackTrace? stackTrace,\n    }) = _FacadeError;\n\n    factory FacadeError.validation(List<ValidationIssue> issues) => FacadeError(\n      code: 'VALIDATION_FAILED',\n      message: 'Script validation failed with ${issues.length} issues',\n      userMessage: 'Your script has errors. Please fix them before running.',\n    );\n\n    factory FacadeError.deviceNotFound(String deviceId) => FacadeError(\n      code: 'DEVICE_NOT_FOUND',\n      message: 'Device $deviceId not found',\n      userMessage: 'The selected keyboard was disconnected. Please reconnect it.',\n    );\n\n    factory FacadeError.fromException(Object e) => /* translate using ErrorTranslator */;\n  }\n  ```\n- **Dependencies:** `freezed`, `ErrorTranslator`\n- **Reuses:** Error translation logic from `ErrorTranslatorImpl`\n\n## Data Models\n\n### DeviceInfo\n```dart\n@freezed\nclass DeviceInfo with _$DeviceInfo {\n  const factory DeviceInfo({\n    required String id,           // \"vendorId:productId\"\n    required String name,\n    required String path,\n    required int vendorId,\n    required int productId,\n    bool? hasProfile,\n  }) = _DeviceInfo;\n}\n```\n\n### LayoutConfig\n```dart\n@freezed\nclass LayoutConfig with _$LayoutConfig {\n  const factory LayoutConfig({\n    required int rows,\n    required List<int> colsPerRow,\n  }) = _LayoutConfig;\n}\n```\n\n### ValidationResult\n```dart\n@freezed\nclass ValidationResult with _$ValidationResult {\n  const factory ValidationResult({\n    required bool isValid,\n    required List<ValidationIssue> errors,\n    required List<ValidationIssue> warnings,\n    List<String>? suggestions,\n  }) = _ValidationResult;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Engine start with invalid script**\n   - **Handling:** Validate first, return `Result.error` with validation issues\n   - **User Impact:** UI shows specific validation errors with line numbers\n\n2. **Device disconnection during discovery**\n   - **Handling:** Cancel discovery, emit state change, return error\n   - **User Impact:** \"Device disconnected\" message with reconnect option\n\n3. **Concurrent operation conflict**\n   - **Handling:** Queue or reject with `OPERATION_IN_PROGRESS` error\n   - **User Impact:** Button disabled or \"Please wait\" message\n\n4. **Service disposal during operation**\n   - **Handling:** Cancel pending operations, clean up state\n   - **User Impact:** Graceful shutdown, no crashes\n\n## Testing Strategy\n\n### Unit Testing\n- Mock `ServiceRegistry` to test facade coordination logic\n- Verify state transitions for each operation\n- Test error translation and Result wrapping\n\n### Integration Testing\n- Use real `ServiceRegistry` with mock FFI bridge\n- Test full operation flows (start → stop, validate → run)\n- Verify state stream emissions\n\n### Widget Testing\n- Inject `MockKeyrxFacade` into widget tests\n- Stub specific methods as needed\n- Test UI response to facade state changes\n\n### Backward Compatibility Testing\n- Verify pages work with both facade and direct service access\n- Test gradual migration scenario\n- Ensure no state conflicts between access methods\n",
  "fileStats": {
    "size": 10541,
    "lines": 344,
    "lastModified": "2025-12-03T12:35:40.467Z"
  },
  "comments": []
}