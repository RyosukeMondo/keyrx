{
  "id": "snapshot_1766076028306_o72kdfo35",
  "approvalId": "approval_1766075909499_ryijei9zm",
  "approvalTitle": "Design for Unified FFI/IPC Codegen",
  "version": 2,
  "timestamp": "2025-12-18T16:40:28.306Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Unified FFI/IPC Codegen\n\n## Overview\n\nThis feature extends the `generate-dart-bindings` tool to support the generation of type-safe Dart IPC clients from `.ffi-contract.json` files. This ensures that the communication between the Flutter UI and the `keyrx daemon` follows the same strict contracts as the FFI layer, providing a Single Source of Truth (SSOT) and preventing protocol drift.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Follows the established pattern of contract-driven development.\n- Reuses the existing Rust-based code generation infrastructure.\n- Adheres to the JSON-RPC 2.0 protocol standards used by the daemon.\n\n### Project Structure (structure.md)\n- Maintains the separation between \"Core\" (Rust) and \"UI\" (Flutter).\n- Places generated IPC clients in `ui/lib/services/generated/` to keep them separate from manual service logic.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`models_gen.rs`**: Already generates Dart data classes from contracts. We will reuse these for IPC method parameters and return types.\n- **`loader.rs`**: Handles loading and parsing of `.ffi-contract.json` files.\n- **`DaemonService`**: The existing manual `DaemonService` will be refactored to serve as the generic transport layer, which the generated clients will depend on.\n\n### Integration Points\n- **`generate-dart-bindings` Crate**: We will add a new `ipc_client_gen.rs` module and wire it into the `pipeline.rs`.\n- **`DaemonService`**: Generated clients will take a `DaemonService` instance and use its `sendRequest` and `events` stream.\n\n## Architecture\n\nThe system follows a layered architecture where the communication protocol is abstracted away from the domain logic.\n\n```mermaid\ngraph TD\n    Contract[*.ffi-contract.json] --> Generator[generate-dart-bindings]\n    Generator --> FfiBindings[generated_bindings.dart]\n    Generator --> Models[generated_models.dart]\n    Generator --> IpcClient[generated_ipc_client.dart]\n    \n    UI[Flutter UI] --> IpcClient\n    IpcClient --> Transport[DaemonService]\n    Transport -- JSON-RPC over Socket --> Daemon[Rust Daemon]\n    Daemon --> Core[Rust Engine]\n```\n\n### Components and Interfaces\n\n#### 1. `IpcClientGenerator` (Rust)\n- **Purpose:** Generates Dart classes that provide a typed interface to the Daemon.\n- **Input:** `FfiContract` object.\n- **Output:** Dart code string containing `DomainIpcClient` classes.\n- **Logic:**\n    - Maps contract **Functions** to `Future<T> name(args)` methods.\n    - Maps contract **Events** to `Stream<T> get onName` getters.\n\n#### 2. `DaemonService` (Dart - Refactored)\n- **Purpose:** Low-level transport for JSON-RPC.\n- **Interfaces:**\n    - `Future<dynamic> sendRequest(String method, Map<String, dynamic> params)`\n    - `Stream<JsonRpcNotification> get notifications`\n- **Dependencies:** `Socket`, `jsonDecode/Encode`.\n\n#### 3. Generated `DomainIpcClient` (Dart)\n- **Purpose:** Domain-specific wrapper around `DaemonService`.\n- **Interfaces:** Typed methods corresponding to the contract.\n- **Reuses:** `GeneratedModels` for type-safe arguments and returns.\n\n## Data Models\n\nThe IPC layer will reuse the models generated by `models_gen.rs`. For example:\n\n```dart\n// Generated in generated_models.dart\nclass EngineStatus {\n  final String status;\n  // ...\n  factory EngineStatus.fromJson(Map<String, dynamic> json) => ...;\n}\n```\n\nThe generated client will use it as:\n\n```dart\nFuture<EngineStatus> getStatus() async {\n  final result = await _service.sendRequest('engine.status', {});\n  return EngineStatus.fromJson(result as Map<String, dynamic>);\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **JSON-RPC Error:** The daemon returns an error object (e.g., `METHOD_NOT_FOUND`).\n   - **Handling:** `DaemonService` throws a `DaemonException`.\n   - **User Impact:** UI catches the exception and shows an error message.\n\n2. **Parsing Error:** The daemon returns a payload that doesn't match the model.\n   - **Handling:** `Model.fromJson` throws a `TypeError` or `FormatException`.\n   - **User Impact:** UI logs the error; standard \"Internal Error\" handling.\n\n3. **Connection Lost:** The socket connection is broken.\n   - **Handling:** `DaemonService` triggers a reconnect and notifies listeners via `connectionState`.\n\n## Testing Strategy\n\n### Unit Testing\n- Test the `IpcClientGenerator` in Rust by comparing its output against golden files.\n- Test the generated Dart code's ability to serialize/deserialize sample payloads.\n\n### Integration Testing\n- Use the existing `daemon_lifecycle_test.rs` pattern to verify that the generated client can talk to a real spawned daemon.\n",
  "fileStats": {
    "size": 4622,
    "lines": 112,
    "lastModified": "2025-12-18T16:38:25.724Z"
  },
  "comments": []
}