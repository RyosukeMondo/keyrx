{
  "id": "snapshot_1766075645700_kfp9h4yzj",
  "approvalId": "approval_1766075645572_l5fhcvgaf",
  "approvalTitle": "Requirements for Unified FFI/IPC Codegen",
  "version": 1,
  "timestamp": "2025-12-18T16:34:05.700Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe goal of this specification is to unify the consistency mechanisms for FFI (Foreign Function Interface) and IPC (Inter-Process Communication) in KeyRx. Currently, FFI enjoys strict type safety and contract enforcement via the `generate-dart-bindings` tool, while IPC relies on manually maintained `protocol.rs` and `daemon_protocol.dart` files, leading to bugs and protocol drift (e.g., missing events, mismatched fields).\n\nThis feature will extend the existing `generate-dart-bindings` tool to generate a type-safe Dart IPC client (`DaemonClient`) directly from the same `*.ffi-contract.json` files used for FFI, establishing a Single Source of Truth (SSOT) for both communication layers.\n\n## Alignment with Product Vision\n\nThis aligns with the goal of \"Robust Architecture\" and \"Developer Experience\" by eliminating a class of bugs caused by manual synchronization of protocols. It ensures that any feature added to the core engine (represented by a contract change) is immediately available and type-safe in both the Embedded (FFI) and Daemon (IPC) modes of the application.\n\n## Requirements\n\n### Requirement 1: Unified Contract Definition\n\n**User Story:** As a developer, I want to define a feature's interface once in a `.ffi-contract.json` file so that I don't have to manually keep `protocol.rs` and `daemon_protocol.dart` in sync.\n\n#### Acceptance Criteria\n\n1. The `generate-dart-bindings` tool SHALL accept `*.ffi-contract.json` files as input for IPC generation.\n2. The tool SHALL interpret \"functions\" in the contract as JSON-RPC methods.\n3. The tool SHALL interpret \"events\" in the contract as JSON-RPC notifications.\n4. The tool SHALL support a flag (e.g., `--mode=ipc` or implicit generation) to trigger IPC client generation.\n\n### Requirement 2: Shared Data Models\n\n**User Story:** As a developer, I want the generated IPC client to use the same Dart model classes as the FFI layer so that I can reuse UI logic and state management code regardless of the underlying backend.\n\n#### Acceptance Criteria\n\n1. The IPC generator SHALL import and use the existing `generated_models.dart` classes.\n2. The generated models SHALL support JSON serialization (already implemented via `fromJson`/`toJson`).\n3. No duplicate model classes SHALL be generated for IPC; the existing ones must be reused.\n\n### Requirement 3: Typed IPC Client Generation\n\n**User Story:** As a developer, I want a generated `DaemonClient` Dart class with typed methods so that I can interact with the daemon without passing raw strings or loose Maps.\n\n#### Acceptance Criteria\n\n1. The tool SHALL generate a `DaemonClient` class (or domain-specific client mixins).\n2. For a contract function `start_loop(config: Config)`, the client SHALL generate a method `Future<void> startLoop(Config config)`.\n3. The generated method SHALL serialize arguments to a JSON-RPC request and send it via the underlying connection.\n4. The generated method SHALL deserialize the JSON-RPC response into the correct return type (using the shared models).\n\n### Requirement 4: Typed Event Subscriptions\n\n**User Story:** As a developer, I want to subscribe to daemon events using typed streams so that I don't have to parse raw JSON notifications manually.\n\n#### Acceptance Criteria\n\n1. The generated client SHALL expose typed Streams for each event defined in the contract.\n2. For an event `input_event(event: InputEvent)`, the client SHALL expose `Stream<InputEvent> get onInputEvent`.\n3. The client SHALL automatically handle the JSON-RPC subscription/unsubscription logic if required by the protocol.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Extensibility**: The new IPC generator logic (`ipc_client_gen.rs`) should be a separate module within the `generate-dart-bindings` crate, following the pattern of `bindings_gen.rs` and `models_gen.rs`.\n- **Clean Output**: Generated Dart code must pass `dart analyze` without errors or warnings.\n- **Backwards Compatibility**: The changes MUST NOT break existing FFI binding generation.\n\n### Reliability\n- The generated code must handle JSON serialization errors gracefully (e.g., throwing a typed exception rather than crashing).\n\n### Usability\n- The generated client should be easy to instantiate and inject into the Flutter application's service layer.\n",
  "fileStats": {
    "size": 4330,
    "lines": 69,
    "lastModified": "2025-12-18T16:33:59.595Z"
  },
  "comments": []
}