{
  "id": "snapshot_1764768915276_af263t0b4",
  "approvalId": "approval_1764768819967_nne402qxz",
  "approvalTitle": "Error Code Registry Design",
  "version": 2,
  "timestamp": "2025-12-03T13:35:15.276Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design creates a compile-time error registry using Rust macros. The core innovation is the `define_error!` macro that generates error types, codes, and documentation from a single source. All errors flow through the `ErrorRegistry` for consistency and traceability.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Custom Exception Hierarchy**: ErrorCode enum with categories\n- **Error Codes**: KRX-XXXX format for all errors\n- **Structured Logging**: JSON format with error codes\n\n### Project Structure (structure.md)\n- Registry in `core/src/errors/`\n- Domain errors in their modules\n- Documentation generated to `docs/errors/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **thiserror**: Error derive macros\n- **anyhow**: Error context and chaining\n- **serde**: Error serialization\n\n### Integration Points\n- **All modules**: Use registry errors\n- **FFI**: Export error codes\n- **Flutter**: Display localized messages\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Error Definition\"\n        REG[ErrorRegistry] --> |define| CAT[Categories]\n        REG --> |define| ERR[ErrorDef]\n    end\n\n    subgraph \"Error Creation\"\n        ERR --> |new| INST[ErrorInstance]\n        INST --> |with| CTX[Context]\n    end\n\n    subgraph \"Error Usage\"\n        MOD[Modules] --> |return| INST\n        MOD --> |log| LOG[Logger]\n        MOD --> |ffi| FFI[FFI Export]\n    end\n\n    subgraph \"Documentation\"\n        REG --> |generate| DOC[docs/errors/]\n        REG --> |generate| MD[errors.md]\n    end\n```\n\n### Modular Design Principles\n- **Single Source of Truth**: Registry defines all errors\n- **Compile-Time Safety**: Invalid codes caught at build\n- **Auto-Documentation**: Docs generated from registry\n- **Structured Output**: JSON logs with full context\n\n## Components and Interfaces\n\n### Component 1: ErrorCode\n\n- **Purpose:** Unique error identifier with category\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct ErrorCode {\n      category: ErrorCategory,\n      number: u16,\n  }\n\n  impl ErrorCode {\n      pub const fn new(category: ErrorCategory, number: u16) -> Self;\n      pub fn as_string(&self) -> String; // \"KRX-1001\"\n      pub fn category(&self) -> ErrorCategory;\n      pub fn number(&self) -> u16;\n  }\n\n  impl std::fmt::Display for ErrorCode {\n      fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n          write!(f, \"KRX-{}{:03}\", self.category.prefix(), self.number)\n      }\n  }\n\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub enum ErrorCategory {\n      Config,      // C - 1xxx\n      Runtime,     // R - 2xxx\n      Driver,      // D - 3xxx\n      Validation,  // V - 4xxx\n      Ffi,         // F - 5xxx\n      Internal,    // I - 9xxx\n  }\n  ```\n- **Dependencies:** None\n- **Reuses:** Standard patterns\n\n### Component 2: ErrorDef\n\n- **Purpose:** Error definition with message template\n- **Interfaces:**\n  ```rust\n  pub struct ErrorDef {\n      pub code: ErrorCode,\n      pub message_template: &'static str,\n      pub hint: Option<&'static str>,\n      pub severity: ErrorSeverity,\n      pub doc_link: Option<&'static str>,\n  }\n\n  #[derive(Debug, Clone, Copy)]\n  pub enum ErrorSeverity {\n      Fatal,\n      Error,\n      Warning,\n      Info,\n  }\n\n  impl ErrorDef {\n      pub fn format(&self, args: &[(&str, &str)]) -> String;\n      pub fn with_context<C: std::fmt::Display>(self, context: C) -> KeyrxError;\n  }\n  ```\n- **Dependencies:** ErrorCode\n- **Reuses:** Template string pattern\n\n### Component 3: KeyrxError\n\n- **Purpose:** Runtime error instance with context\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, thiserror::Error)]\n  pub struct KeyrxError {\n      def: &'static ErrorDef,\n      message: String,\n      context: Option<String>,\n      source: Option<Box<dyn std::error::Error + Send + Sync>>,\n  }\n\n  impl KeyrxError {\n      pub fn code(&self) -> ErrorCode;\n      pub fn message(&self) -> &str;\n      pub fn hint(&self) -> Option<&str>;\n      pub fn with_source<E: std::error::Error + Send + Sync + 'static>(self, e: E) -> Self;\n      pub fn to_json(&self) -> serde_json::Value;\n  }\n\n  impl std::fmt::Display for KeyrxError {\n      fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n          write!(f, \"[{}] {}\", self.code(), self.message)\n      }\n  }\n  ```\n- **Dependencies:** ErrorDef, thiserror, serde\n- **Reuses:** Error handling patterns\n\n### Component 4: ErrorRegistry\n\n- **Purpose:** Central registry of all error definitions\n- **Interfaces:**\n  ```rust\n  pub struct ErrorRegistry {\n      errors: HashMap<ErrorCode, &'static ErrorDef>,\n  }\n\n  impl ErrorRegistry {\n      pub fn global() -> &'static Self;\n      pub fn get(&self, code: ErrorCode) -> Option<&'static ErrorDef>;\n      pub fn by_category(&self, cat: ErrorCategory) -> Vec<&'static ErrorDef>;\n      pub fn all(&self) -> impl Iterator<Item = &'static ErrorDef>;\n  }\n\n  // Macro for defining errors\n  macro_rules! define_errors {\n      (\n          $category:ident {\n              $(\n                  $name:ident = $num:literal {\n                      message: $msg:literal,\n                      $(hint: $hint:literal,)?\n                      severity: $sev:ident,\n                  }\n              ),* $(,)?\n          }\n      ) => { ... };\n  }\n  ```\n- **Dependencies:** ErrorCode, ErrorDef\n- **Reuses:** Static registry pattern\n\n### Component 5: Error Macros\n\n- **Purpose:** Convenient error creation\n- **Interfaces:**\n  ```rust\n  // Create error with code\n  macro_rules! keyrx_err {\n      ($code:expr) => { ... };\n      ($code:expr, $($key:ident = $val:expr),*) => { ... };\n  }\n\n  // Create error and return early\n  macro_rules! bail_keyrx {\n      ($code:expr) => { return Err(keyrx_err!($code)); };\n      ($code:expr, $($args:tt)*) => { return Err(keyrx_err!($code, $($args)*)); };\n  }\n\n  // Ensure condition or error\n  macro_rules! ensure_keyrx {\n      ($cond:expr, $code:expr) => {\n          if !$cond { bail_keyrx!($code); }\n      };\n  }\n  ```\n- **Dependencies:** ErrorRegistry\n- **Reuses:** anyhow macro patterns\n\n### Component 6: Documentation Generator\n\n- **Purpose:** Generate error documentation from registry\n- **Interfaces:**\n  ```rust\n  pub struct ErrorDocGenerator {\n      registry: &'static ErrorRegistry,\n  }\n\n  impl ErrorDocGenerator {\n      pub fn generate_markdown(&self) -> String;\n      pub fn generate_by_category(&self, cat: ErrorCategory) -> String;\n      pub fn write_to_file(&self, path: &Path) -> io::Result<()>;\n  }\n  ```\n- **Dependencies:** ErrorRegistry\n- **Reuses:** Documentation patterns\n\n## Data Models\n\n### LogEntry\n```rust\n#[derive(Serialize)]\npub struct ErrorLogEntry {\n    pub timestamp: String,\n    pub level: &'static str,\n    pub code: String,\n    pub message: String,\n    pub context: Option<String>,\n    pub hint: Option<String>,\n    pub source: Option<String>,\n}\n```\n\n### FfiError\n```rust\n#[repr(C)]\npub struct FfiError {\n    pub code: *const c_char,\n    pub message: *const c_char,\n    pub hint: *const c_char,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Duplicate error code**\n   - **Handling:** Compile-time error via macro\n   - **User Impact:** None - caught in development\n\n2. **Missing error definition**\n   - **Handling:** Return Internal error with original code\n   - **User Impact:** Generic error with tracking\n\n3. **Template format failure**\n   - **Handling:** Return raw template with warning\n   - **User Impact:** Less pretty message\n\n## Testing Strategy\n\n### Unit Testing\n- Test error code formatting\n- Test message templating\n- Test serialization\n\n### Compile-Time Testing\n- Verify duplicate detection\n- Test macro expansion\n- Verify doc generation\n\n### Integration Testing\n- Test error propagation\n- Test FFI export\n- Test logging output\n",
  "fileStats": {
    "size": 7742,
    "lines": 298,
    "lastModified": "2025-12-03T13:33:12.665Z"
  },
  "comments": []
}