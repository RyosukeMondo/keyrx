{
  "id": "snapshot_1764771443101_dh3277a2q",
  "approvalId": "approval_1764770435306_dox3us1on",
  "approvalTitle": "Unwrap/Panic Hardening Design",
  "version": 2,
  "timestamp": "2025-12-03T14:17:23.101Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design systematically eliminates panics from KeyRx's critical input path. The core innovation is a `CriticalResult<T>` type that enforces error handling at compile time, combined with `PanicGuard` wrappers that catch and recover from panics in driver threads. A `CircuitBreaker` pattern prevents repeated failures from degrading the system.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **No Panics in Critical Path**: Enforced by lint and type system\n- **Graceful Degradation**: Fallback to passthrough on errors\n- **Error Handling**: Result types for all fallible operations\n\n### Project Structure (structure.md)\n- Error types in `core/src/errors/`\n- Panic guards in `core/src/safety/`\n- Fallback logic in `core/src/engine/fallback/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **anyhow/thiserror**: Error handling infrastructure\n- **std::panic::catch_unwind**: Panic catching\n- **tracing**: Panic logging\n\n### Integration Points\n- **Drivers**: Wrap in PanicGuard\n- **Engine**: Use CriticalResult\n- **FFI**: Report panics to Flutter\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Critical Path\"\n        DRV[Driver] --> |event| ENG[Engine]\n        ENG --> |action| OUT[Output]\n    end\n\n    subgraph \"Safety Layer\"\n        DRV --> PG[PanicGuard]\n        ENG --> CR[CriticalResult]\n        OUT --> FB[Fallback]\n    end\n\n    subgraph \"Recovery\"\n        PG --> |panic| REC[Recovery]\n        CR --> |error| REC\n        REC --> CB[CircuitBreaker]\n        CB --> |open| PASS[Passthrough]\n    end\n```\n\n### Modular Design Principles\n- **Defense in Depth**: Multiple recovery layers\n- **Fail Safe**: Default to passthrough\n- **Observable**: All failures logged\n- **Testable**: Panic scenarios covered\n\n## Components and Interfaces\n\n### Component 1: CriticalResult Type\n\n- **Purpose:** Result type that must be handled, no unwrap allowed\n- **Interfaces:**\n  ```rust\n  /// Result type for critical path operations.\n  /// Deliberately does not implement methods that panic.\n  #[must_use = \"CriticalResult must be handled\"]\n  pub struct CriticalResult<T> {\n      inner: Result<T, CriticalError>,\n  }\n\n  impl<T> CriticalResult<T> {\n      pub fn ok(value: T) -> Self;\n      pub fn err(error: CriticalError) -> Self;\n\n      /// Handle result with explicit fallback\n      pub fn unwrap_or_fallback(self, fallback: T) -> T;\n\n      /// Handle result with fallback function\n      pub fn unwrap_or_else<F: FnOnce(CriticalError) -> T>(self, f: F) -> T;\n\n      /// Map success value\n      pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> CriticalResult<U>;\n\n      /// Chain operations\n      pub fn and_then<U, F: FnOnce(T) -> CriticalResult<U>>(self, f: F) -> CriticalResult<U>;\n\n      // NOTE: No unwrap(), expect(), or panic-inducing methods\n  }\n\n  impl<T: Default> CriticalResult<T> {\n      pub fn unwrap_or_default(self) -> T;\n  }\n  ```\n- **Dependencies:** CriticalError\n- **Reuses:** Result patterns without panic methods\n\n### Component 2: CriticalError Type\n\n- **Purpose:** Error type for critical path failures\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, thiserror::Error)]\n  pub enum CriticalError {\n      #[error(\"Driver failure: {message}\")]\n      DriverFailure {\n          message: String,\n          recoverable: bool,\n          fallback: FallbackAction,\n      },\n\n      #[error(\"Engine error: {message}\")]\n      EngineError {\n          message: String,\n          state_snapshot: Option<StateSnapshot>,\n      },\n\n      #[error(\"Panic recovered: {message}\")]\n      PanicRecovered {\n          message: String,\n          backtrace: String,\n          location: &'static str,\n      },\n\n      #[error(\"Config error: {message}\")]\n      ConfigError {\n          message: String,\n          using_defaults: bool,\n      },\n  }\n\n  #[derive(Debug, Clone, Copy)]\n  pub enum FallbackAction {\n      Passthrough,\n      UseDefaults,\n      RetryOnce,\n      Disable,\n  }\n\n  impl CriticalError {\n      pub fn fallback_action(&self) -> FallbackAction;\n      pub fn is_recoverable(&self) -> bool;\n      pub fn should_report(&self) -> bool;\n  }\n  ```\n- **Dependencies:** thiserror\n- **Reuses:** Error hierarchy patterns\n\n### Component 3: PanicGuard\n\n- **Purpose:** Catch panics in driver threads\n- **Interfaces:**\n  ```rust\n  /// Guard that catches panics and converts to CriticalError.\n  pub struct PanicGuard {\n      name: &'static str,\n      on_panic: Box<dyn Fn(PanicInfo) + Send + Sync>,\n  }\n\n  impl PanicGuard {\n      pub fn new(name: &'static str) -> Self;\n\n      /// Set custom panic handler\n      pub fn on_panic<F: Fn(PanicInfo) + Send + Sync + 'static>(mut self, f: F) -> Self;\n\n      /// Run closure with panic catching\n      pub fn run<T, F: FnOnce() -> T + UnwindSafe>(&self, f: F) -> CriticalResult<T>;\n\n      /// Run with fallback value on panic\n      pub fn run_or<T, F: FnOnce() -> T + UnwindSafe>(&self, fallback: T, f: F) -> T;\n  }\n\n  #[derive(Debug)]\n  pub struct PanicInfo {\n      pub message: String,\n      pub location: String,\n      pub backtrace: String,\n      pub thread_name: String,\n  }\n  ```\n- **Dependencies:** std::panic\n- **Reuses:** catch_unwind patterns\n\n### Component 4: CircuitBreaker\n\n- **Purpose:** Prevent repeated failures from degrading system\n- **Interfaces:**\n  ```rust\n  /// Circuit breaker for failure-prone operations.\n  pub struct CircuitBreaker {\n      state: AtomicU8,  // Closed=0, Open=1, HalfOpen=2\n      failure_count: AtomicU32,\n      last_failure: AtomicU64,\n      config: CircuitBreakerConfig,\n  }\n\n  pub struct CircuitBreakerConfig {\n      pub failure_threshold: u32,\n      pub reset_timeout: Duration,\n      pub half_open_requests: u32,\n  }\n\n  impl CircuitBreaker {\n      pub fn new(config: CircuitBreakerConfig) -> Self;\n\n      /// Check if operation should proceed\n      pub fn allow(&self) -> bool;\n\n      /// Record success\n      pub fn record_success(&self);\n\n      /// Record failure\n      pub fn record_failure(&self);\n\n      /// Get current state\n      pub fn state(&self) -> CircuitState;\n\n      /// Run operation with circuit breaker\n      pub fn run<T, F: FnOnce() -> CriticalResult<T>>(&self, f: F) -> CriticalResult<T>;\n  }\n\n  #[derive(Debug, Clone, Copy)]\n  pub enum CircuitState {\n      Closed,    // Normal operation\n      Open,      // Failing, reject requests\n      HalfOpen,  // Testing recovery\n  }\n  ```\n- **Dependencies:** std::sync::atomic\n- **Reuses:** Circuit breaker pattern\n\n### Component 5: FallbackEngine\n\n- **Purpose:** Provide fallback behavior when engine fails\n- **Interfaces:**\n  ```rust\n  /// Minimal engine that passes keys through unchanged.\n  pub struct FallbackEngine {\n      active: AtomicBool,\n      reason: Mutex<Option<CriticalError>>,\n  }\n\n  impl FallbackEngine {\n      pub fn new() -> Self;\n\n      /// Activate fallback mode\n      pub fn activate(&self, reason: CriticalError);\n\n      /// Deactivate and return to normal\n      pub fn deactivate(&self) -> Option<CriticalError>;\n\n      /// Check if active\n      pub fn is_active(&self) -> bool;\n\n      /// Process key in fallback mode (always passthrough)\n      pub fn process(&self, event: KeyEvent) -> KeyAction {\n          KeyAction::Passthrough\n      }\n  }\n  ```\n- **Dependencies:** None\n- **Reuses:** Null object pattern\n\n### Component 6: Unwrap Removal Utilities\n\n- **Purpose:** Help migrate unwrap calls\n- **Interfaces:**\n  ```rust\n  /// Extension trait for Option with fallback logging\n  pub trait OptionExt<T> {\n      fn unwrap_or_log(self, default: T, context: &str) -> T;\n      fn ok_or_critical(self, error: CriticalError) -> CriticalResult<T>;\n  }\n\n  /// Extension trait for Result with fallback logging\n  pub trait ResultExt<T, E> {\n      fn unwrap_or_log(self, default: T, context: &str) -> T;\n      fn map_critical(self) -> CriticalResult<T> where E: std::error::Error;\n  }\n\n  impl<T> OptionExt<T> for Option<T> {\n      fn unwrap_or_log(self, default: T, context: &str) -> T {\n          match self {\n              Some(v) => v,\n              None => {\n                  tracing::warn!(context, \"Option was None, using default\");\n                  default\n              }\n          }\n      }\n  }\n  ```\n- **Dependencies:** tracing\n- **Reuses:** Extension trait patterns\n\n## Data Models\n\n### StateSnapshot\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct StateSnapshot {\n    pub pressed_keys: Vec<KeyCode>,\n    pub active_layers: Vec<LayerId>,\n    pub pending_count: usize,\n    pub timestamp: u64,\n}\n```\n\n### RecoveryReport\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct RecoveryReport {\n    pub error: String,\n    pub action_taken: FallbackAction,\n    pub timestamp: u64,\n    pub state_before: Option<StateSnapshot>,\n    pub state_after: Option<StateSnapshot>,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Panic in hook callback**\n   - **Handling:** PanicGuard catches, returns Passthrough\n   - **User Impact:** Key works normally, bug logged\n\n2. **Engine state corruption**\n   - **Handling:** Reset to clean state, activate fallback\n   - **User Impact:** Brief passthrough, auto-recovery\n\n3. **Repeated driver failures**\n   - **Handling:** CircuitBreaker opens, passthrough mode\n   - **User Impact:** Keys work, no remapping until recovery\n\n4. **Config parsing failure**\n   - **Handling:** Use default config, warn user\n   - **User Impact:** Basic functionality preserved\n\n## Testing Strategy\n\n### Unit Testing\n- Test CriticalResult API\n- Test PanicGuard catches panics\n- Test CircuitBreaker state transitions\n\n### Integration Testing\n- Test panic recovery in drivers\n- Test fallback mode activation\n- Test circuit breaker under load\n\n### Chaos Testing\n- Inject panics at random points\n- Verify keyboard remains functional\n- Test emergency exit works\n",
  "fileStats": {
    "size": 9686,
    "lines": 359,
    "lastModified": "2025-12-03T14:13:34.696Z"
  },
  "comments": []
}