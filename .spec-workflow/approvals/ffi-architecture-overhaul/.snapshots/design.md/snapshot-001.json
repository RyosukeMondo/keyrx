{
  "id": "snapshot_1764765557554_ykrga4oc8",
  "approvalId": "approval_1764765557546_djejzhm6v",
  "approvalTitle": "FFI Architecture Overhaul - Design",
  "version": 1,
  "timestamp": "2025-12-03T12:39:17.554Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design introduces a trait-based FFI architecture that replaces the current 10 export modules with a unified, auto-generated system. The core innovation is the `FfiExportable` trait that domain modules implement, with procedural macros generating C-ABI wrappers, callback management, and Dart bindings automatically.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **No Global State**: Replaces `OnceLock<Mutex<...>>` singletons with handle-based state management\n- **Dependency Injection**: FFI context is injectable for testing\n- **Trait-based OS Abstraction**: Extends pattern to FFI layer with `FfiExportable` trait\n\n### Project Structure (structure.md)\n- FFI code remains in `core/src/ffi/` but reorganized by domain\n- New `core/src/ffi/macros/` for procedural macros\n- Dart bindings in `ui/lib/ffi/generated/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`CallbackRegistry`** (`ffi/callbacks.rs`): Refactor to generic event-based system\n- **`keyrx_free_string`** (`ffi/exports.rs`): Keep as shared utility\n- **JSON serialization patterns**: Standardize across all exports\n\n### Integration Points\n- **Discovery module**: First migration candidate (well-tested, self-contained)\n- **Validation module**: Benefits from new callback system\n- **Flutter KeyrxBridge**: Will consume generated Dart bindings\n\n## Architecture\n\nThe new architecture separates concerns into layers:\n\n```mermaid\ngraph TD\n    subgraph \"Flutter UI\"\n        FB[KeyrxBridge] --> GB[Generated Bindings]\n    end\n\n    subgraph \"FFI Layer\"\n        GB --> GW[Generated C-ABI Wrappers]\n        GW --> CTX[FfiContext Handle]\n        CTX --> ER[Event Registry]\n    end\n\n    subgraph \"Domain Layer\"\n        GW --> DT[Domain Traits]\n        DT --> DI[DiscoveryFfi]\n        DT --> VI[ValidationFfi]\n        DT --> EI[EngineFfi]\n        DT --> TI[TestingFfi]\n    end\n\n    subgraph \"Core Layer\"\n        DI --> DS[DiscoverySession]\n        VI --> VS[ValidationEngine]\n        EI --> ES[Engine]\n        TI --> TS[TestRunner]\n    end\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each domain has one `*_ffi.rs` implementing its trait\n- **Component Isolation**: Domain FFI modules don't import each other\n- **Service Layer Separation**: FFI (boundary) → Domain Trait (contract) → Core (logic)\n- **Utility Modularity**: Shared utilities in `ffi/common.rs`\n\n## Components and Interfaces\n\n### Component 1: FfiExportable Trait\n\n- **Purpose:** Define contract for FFI-exportable domain modules\n- **Interfaces:**\n  ```rust\n  pub trait FfiExportable {\n      /// Domain name for namespacing (e.g., \"discovery\", \"validation\")\n      const DOMAIN: &'static str;\n\n      /// Initialize domain state within context\n      fn init(ctx: &mut FfiContext) -> Result<(), FfiError>;\n\n      /// Clean up domain state\n      fn cleanup(ctx: &mut FfiContext);\n  }\n\n  /// Attribute macro for FFI methods\n  #[ffi_export]\n  fn start_discovery(&self, device_id: &str, rows: u8, cols: &[u8]) -> Result<StartResult, FfiError>;\n  ```\n- **Dependencies:** None (trait definition only)\n- **Reuses:** Patterns from existing `InputSource` trait\n\n### Component 2: FfiContext\n\n- **Purpose:** Hold all FFI state per-instance, replacing global statics\n- **Interfaces:**\n  ```rust\n  pub struct FfiContext {\n      handle: u64,\n      event_registry: EventRegistry,\n      domains: HashMap<&'static str, Box<dyn Any + Send>>,\n  }\n\n  impl FfiContext {\n      pub fn new() -> Self;\n      pub fn register_callback(&mut self, event: EventType, cb: EventCallback);\n      pub fn emit_event(&self, event: EventType, payload: &impl Serialize);\n      pub fn get_domain<T: 'static>(&self) -> Option<&T>;\n      pub fn get_domain_mut<T: 'static>(&mut self) -> Option<&mut T>;\n  }\n  ```\n- **Dependencies:** `serde`, `serde_json`\n- **Reuses:** Callback invocation pattern from `CallbackRegistry`\n\n### Component 3: EventRegistry\n\n- **Purpose:** Unified callback management replacing per-domain callback functions\n- **Interfaces:**\n  ```rust\n  #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n  pub enum EventType {\n      // Discovery events\n      DiscoveryProgress,\n      DiscoveryDuplicate,\n      DiscoverySummary,\n      // Validation events\n      ValidationProgress,\n      ValidationComplete,\n      // Engine events\n      EngineStateChange,\n      EngineError,\n      // ... extensible\n  }\n\n  pub type EventCallback = extern \"C\" fn(*const u8, usize);\n\n  impl EventRegistry {\n      pub fn register(&mut self, event: EventType, cb: Option<EventCallback>);\n      pub fn invoke(&self, event: EventType, payload: &[u8]);\n      pub fn has_callback(&self, event: EventType) -> bool;\n  }\n  ```\n- **Dependencies:** None\n- **Reuses:** Callback pattern from `callbacks.rs`\n\n### Component 4: Procedural Macro `#[ffi_export]`\n\n- **Purpose:** Generate C-ABI wrapper, error handling, and JSON serialization\n- **Interfaces:**\n  ```rust\n  // Input (developer writes):\n  #[ffi_export]\n  impl DiscoveryFfi {\n      pub fn start(&mut self, device_id: &str, rows: u8, cols: Vec<u8>) -> Result<StartResult, FfiError> {\n          // domain logic\n      }\n  }\n\n  // Output (macro generates):\n  #[no_mangle]\n  pub unsafe extern \"C\" fn keyrx_discovery_start(\n      ctx: *mut FfiContext,\n      device_id: *const c_char,\n      rows: u8,\n      cols_json: *const c_char,\n  ) -> *mut c_char {\n      // null checks, UTF-8 validation, JSON parsing\n      // call domain method\n      // serialize result to JSON\n      // return \"ok:{...}\" or \"error:{...}\"\n  }\n  ```\n- **Dependencies:** `syn`, `quote`, `proc-macro2`\n- **Reuses:** Error handling patterns from existing exports\n\n### Component 5: Dart Binding Generator\n\n- **Purpose:** Generate type-safe Dart FFI bindings from Rust exports\n- **Interfaces:**\n  ```dart\n  // Generated: ui/lib/ffi/generated/discovery_bindings.dart\n  class DiscoveryBindings {\n    final DynamicLibrary _lib;\n\n    late final Pointer<Utf8> Function(\n      Pointer<FfiContext>,\n      Pointer<Utf8>,\n      int,\n      Pointer<Utf8>,\n    ) _start;\n\n    Future<StartResult> start(String deviceId, int rows, List<int> cols) async {\n      final result = _start(_ctx, deviceId.toNativeUtf8(), rows, jsonEncode(cols).toNativeUtf8());\n      return _parseResult<StartResult>(result);\n    }\n  }\n  ```\n- **Dependencies:** `ffigen` (or custom generator)\n- **Reuses:** Patterns from existing `KeyrxBridge`\n\n## Data Models\n\n### FfiError\n```rust\n#[derive(Serialize)]\npub struct FfiError {\n    pub code: String,        // e.g., \"INVALID_UTF8\", \"DEVICE_NOT_FOUND\"\n    pub message: String,     // Human-readable message\n    pub details: Option<serde_json::Value>,  // Additional context\n}\n\nimpl FfiError {\n    pub fn invalid_input(msg: &str) -> Self;\n    pub fn internal(msg: &str) -> Self;\n    pub fn not_found(resource: &str) -> Self;\n}\n```\n\n### FfiResult\n```rust\npub type FfiResult<T> = Result<T, FfiError>;\n\n// Serialization format:\n// Success: \"ok:{...serialized T...}\"\n// Error: \"error:{code, message, details?}\"\n```\n\n### EventPayload\n```rust\n#[derive(Serialize)]\npub struct EventPayload<T: Serialize> {\n    pub event_type: String,\n    pub timestamp_ms: u64,\n    pub data: T,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Null pointer input**\n   - **Handling:** Return `error:{code: \"NULL_POINTER\", message: \"...\"}`\n   - **User Impact:** Flutter receives parseable error, displays friendly message\n\n2. **Invalid UTF-8 in string parameter**\n   - **Handling:** Return `error:{code: \"INVALID_UTF8\", message: \"parameter X contains invalid UTF-8\"}`\n   - **User Impact:** Developer sees which parameter failed\n\n3. **Domain operation failure**\n   - **Handling:** Domain returns `FfiError`, wrapper serializes it\n   - **User Impact:** Specific error (e.g., \"device not found\") displayed\n\n4. **Panic in domain code**\n   - **Handling:** `catch_unwind` in wrapper, convert to `error:{code: \"INTERNAL_ERROR\"}`\n   - **User Impact:** App doesn't crash, error logged for debugging\n\n## Testing Strategy\n\n### Unit Testing\n- Test each domain's `FfiExportable` implementation in isolation\n- Mock `FfiContext` to verify state management\n- Test error handling paths with invalid inputs\n\n### Integration Testing\n- Test full FFI round-trip: Dart → C-ABI → Rust → C-ABI → Dart\n- Verify callback invocation with real payloads\n- Test context lifecycle (create, use, dispose)\n\n### Property Testing\n- Fuzz FFI inputs with proptest\n- Verify no panics escape FFI boundary\n- Test JSON serialization round-trips\n\n### Parallel Test Safety\n- Each test creates isolated `FfiContext`\n- No global state accessed\n- Tests run with `cargo nextest` for true parallelism\n",
  "fileStats": {
    "size": 8610,
    "lines": 280,
    "lastModified": "2025-12-03T12:35:40.407Z"
  },
  "comments": []
}