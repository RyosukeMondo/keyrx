{
  "id": "snapshot_1765469255819_30kvfjydf",
  "approvalId": "approval_1765469255754_valbiwxdf",
  "approvalTitle": "Misc Improvements - Design Document",
  "version": 1,
  "timestamp": "2025-12-11T16:07:35.819Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design addresses remaining code quality items: function length compliance, test coverage improvements, structured logging verification, and documentation coverage. Each improvement follows analyze → verify → fix pattern.\n\n**Core Principles:**\n1. **Measure first** - Understand current state\n2. **Prioritize impact** - Focus on critical gaps\n3. **Minimal changes** - Only fix what needs fixing\n4. **Verify compliance** - Ensure standards met\n\n## Steering Document Alignment\n\n### Technical Standards (~/.claude/CLAUDE.md)\n\n**Code Metrics Met:**\n- ✅ **Max 50 lines/function**: Verified and enforced\n- ✅ **80% test coverage**: Overall minimum achieved\n- ✅ **90% critical paths**: Services/API/engine/FFI covered\n- ✅ **Structured logging**: JSON with required fields\n\n## Architecture\n\n### Analysis and Fix Pipeline\n\n```mermaid\ngraph LR\n    A[Measure Current State] --> B[Identify Gaps]\n    B --> C[Prioritize Fixes]\n    C --> D[Implement Fixes]\n    D --> E[Verify Compliance]\n    E --> F[Enforce in CI]\n\n    style A fill:#e1f5e1\n    style F fill:#ccffcc\n```\n\n## Component Designs\n\n### 1. Function Length Analysis\n\n**Tool Design:**\n```rust\n// Custom analysis script\nfn analyze_function_lengths() -> Vec<FunctionInfo> {\n    // Parse Rust files\n    // Identify function boundaries\n    // Count non-comment/blank lines\n    // Report violations\n}\n```\n\n**Detection Strategy:**\n- Use `syn` crate to parse Rust AST\n- Count lines between `fn` and closing `}`\n- Exclude comments and blank lines\n- Report functions >50 lines\n\n**Refactoring Pattern:**\n```rust\n// Before: 80-line function\npub fn complex_operation(data: Data) -> Result<Output> {\n    // 80 lines of logic\n}\n\n// After: Broken into helpers\npub fn complex_operation(data: Data) -> Result<Output> {\n    let validated = validate_input(data)?;\n    let processed = process_data(validated)?;\n    let result = finalize_output(processed)?;\n    Ok(result)\n}\n\nfn validate_input(data: Data) -> Result<ValidatedData> {\n    // 15-20 lines\n}\n\nfn process_data(data: ValidatedData) -> Result<ProcessedData> {\n    // 20-30 lines\n}\n\nfn finalize_output(data: ProcessedData) -> Result<Output> {\n    // 15-20 lines\n}\n```\n\n**Refactoring Guidelines:**\n- Extract logical steps into helpers\n- Name helpers descriptively\n- Keep public API unchanged\n- Preserve all behavior\n- Maintain error handling\n- Update tests if needed (usually not)\n\n---\n\n### 2. Test Coverage Improvements\n\n**Coverage Analysis:**\n```bash\ncargo llvm-cov --lib --html\n# Review HTML report\n# Identify uncovered lines/branches\n```\n\n**Gap Prioritization:**\n```\nPriority 1: Critical paths <90% (services, API, engine, FFI)\nPriority 2: Overall <80% (all other code)\nPriority 3: Nice-to-have (edge cases, error paths)\n```\n\n**Test Addition Strategy:**\n\n**For uncovered logic:**\n```rust\n// Identify uncovered lines in coverage report\n// Red/yellow highlighted lines\n\n// Add targeted test\n#[test]\nfn test_uncovered_error_path() {\n    // Set up conditions that hit uncovered lines\n    // Verify behavior\n}\n```\n\n**For uncovered branches:**\n```rust\n// If-else, match arms not covered\n\n#[test]\nfn test_branch_a() {\n    // Test first branch\n}\n\n#[test]\nfn test_branch_b() {\n    // Test second branch\n}\n```\n\n**Test Quality Criteria:**\n- Test real scenarios, not just coverage\n- Use mocks from DI spec for unit tests\n- Test error paths and edge cases\n- Verify behavior, not implementation\n- Keep tests maintainable\n\n---\n\n### 3. Structured Logging Verification\n\n**Current State Check:**\n```rust\n// Verify LogEntry struct has required fields\npub struct LogEntry {\n    pub timestamp: u64,      // ✓ Required\n    pub level: LogLevel,     // ✓ Required\n    pub target: String,      // service field\n    pub message: String,     // event field\n    pub fields: HashMap<String, String>,  // context\n}\n```\n\n**Verification Steps:**\n1. Review `observability/entry.rs` - Check LogEntry struct\n2. Review `observability/logger.rs` - Check JSON serialization\n3. Sample logs in tests - Verify format\n4. Check for PII/secrets - Ensure not logged\n\n**Format Validation:**\n```rust\n#[test]\nfn test_log_format_compliance() {\n    // Capture log output\n    let log = capture_log();\n\n    // Parse as JSON\n    let entry: serde_json::Value = serde_json::from_str(&log).unwrap();\n\n    // Verify required fields\n    assert!(entry.get(\"timestamp\").is_some());\n    assert!(entry.get(\"level\").is_some());\n    assert!(entry.get(\"service\").is_some() || entry.get(\"target\").is_some());\n    assert!(entry.get(\"event\").is_some() || entry.get(\"message\").is_some());\n}\n```\n\n**Fixes if Needed:**\n- Add missing fields to LogEntry\n- Update serialization to include all fields\n- Add field mapping (target → service, message → event)\n- Ensure timestamp is ISO 8601 format\n\n---\n\n### 4. Documentation Coverage\n\n**Analysis Tool:**\n```bash\n# Built-in cargo tool\ncargo doc --no-deps 2>&1 | grep -i warning\n```\n\n**Missing Doc Detection:**\n```bash\n# Custom script or manual review\nrg \"^pub (fn|struct|trait|enum)\" --no-heading | \\\n  while read line; do\n    # Check if next line is doc comment\n  done\n```\n\n**Documentation Template:**\n```rust\n/// Brief description of what this does.\n///\n/// More detailed explanation if needed.\n///\n/// # Parameters\n/// * `param1` - Description of param1\n/// * `param2` - Description of param2\n///\n/// # Returns\n/// Description of return value\n///\n/// # Errors\n/// When this can error and why\n///\n/// # Examples\n/// ```\n/// let result = function(arg1, arg2);\n/// ```\npub fn function(param1: Type1, param2: Type2) -> Result<Output> {\n    // ...\n}\n```\n\n**Quick Wins:**\n- Functions missing docs entirely\n- Types without descriptions\n- Unclear parameter purposes\n- Missing examples for complex APIs\n\n---\n\n### 5. Code Complexity Analysis\n\n**Tool:** `cargo-geiger` or custom complexity calculator\n\n**Cyclomatic Complexity:**\n```\nCC = edges - nodes + 2 (control flow graph)\n\nSimplified:\n- Base: 1\n- Each if/while/for: +1\n- Each match arm: +1\n- Each &&/||: +1\n```\n\n**Example Analysis:**\n```rust\n// Complexity = 8 (moderate)\npub fn calculate(value: i32, mode: Mode) -> Result<i32> {  // 1\n    if value < 0 {  // +1 = 2\n        return Err(Error::Negative);\n    }\n\n    let result = match mode {  // +3 = 5\n        Mode::Add => value + 10,\n        Mode::Multiply => value * 2,\n        Mode::Custom(x) => value + x,\n    };\n\n    if result > 1000 {  // +1 = 6\n        Err(Error::Overflow)\n    } else if result < -1000 {  // +1 = 7\n        Err(Error::Underflow)\n    } else {\n        Ok(result)  // +1 (else) = 8\n    }\n}\n```\n\n**Simplification Strategies:**\n- Extract nested conditions\n- Use early returns\n- Replace complex match with method dispatch\n- Split into multiple functions\n\n## Testing Strategy\n\n### Per-Improvement Testing\n\n**After function refactoring:**\n```bash\ncargo test --lib              # All tests pass\ncargo bench <function_name>   # Performance unchanged\n```\n\n**After adding tests:**\n```bash\ncargo test <new_test>         # New test passes\ncargo llvm-cov --lib          # Coverage improved\n```\n\n**After logging fixes:**\n```bash\ncargo test observability      # Logging tests pass\n# Manual: Check log output format\n```\n\n**After documentation:**\n```bash\ncargo doc --no-deps           # No warnings\n```\n\n## Implementation Plan\n\n### Phase 1: Analysis (Measure Current State)\n\n1. **Function Length Audit**\n   - Write/run analysis script\n   - Identify all functions >50 lines\n   - Rank by severity\n\n2. **Coverage Measurement**\n   - Run `cargo llvm-cov --lib --html`\n   - Identify gaps <80% overall\n   - Identify critical paths <90%\n\n3. **Logging Verification**\n   - Review LogEntry structure\n   - Verify JSON output format\n   - Check for PII/secrets\n\n4. **Documentation Audit**\n   - Run `cargo doc` and check warnings\n   - Identify undocumented public APIs\n   - Prioritize by importance\n\n5. **Complexity Analysis** (Optional)\n   - Calculate cyclomatic complexity\n   - Identify functions >10 complexity\n   - Prioritize simplification\n\n### Phase 2: Prioritization\n\n**High Priority:**\n- Critical path coverage gaps (<90%)\n- Functions >100 lines (very long)\n- Missing docs on core APIs\n- Logging format violations\n\n**Medium Priority:**\n- Overall coverage gaps (<80%)\n- Functions 70-100 lines\n- Missing docs on public utilities\n- Complexity >15\n\n**Low Priority:**\n- Functions 50-70 lines (borderline)\n- Nice-to-have documentation\n- Complexity 10-15 (moderate)\n\n### Phase 3: Implementation\n\nWork through prioritized list:\n- Fix high priority items first\n- Test after each fix\n- Measure improvement\n- Move to next item\n\n### Phase 4: Enforcement\n\nAdd CI checks:\n```yaml\n# .github/workflows/quality.yml\n- name: Check function length\n  run: ./scripts/check_function_length.sh\n\n- name: Check coverage\n  run: cargo llvm-cov --lib --summary-only | tee coverage.txt\n  # Parse and verify ≥80%\n\n- name: Check docs\n  run: cargo doc --no-deps\n```\n\n## Backward Compatibility\n\n**Zero Breaking Changes:**\n- Refactoring maintains exact behavior\n- New tests don't change existing APIs\n- Documentation is additive\n- Logging format improvements backward compatible\n\n## Performance Considerations\n\n**Test Runtime:**\n- New tests should be fast (<1ms unit tests)\n- Coverage measurement adds ~5-10s to CI\n\n**Build Time:**\n- Function refactoring: no impact\n- Documentation: negligible impact\n",
  "fileStats": {
    "size": 9270,
    "lines": 410,
    "lastModified": "2025-12-11T16:05:22.719Z"
  },
  "comments": []
}