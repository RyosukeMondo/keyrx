{
  "id": "snapshot_1764473432222_9bs1i5epc",
  "approvalId": "approval_1764473353068_m9tf834gb",
  "approvalTitle": "Design: Code Quality Refactor",
  "version": 2,
  "timestamp": "2025-11-30T03:30:32.222Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: code-quality-refactor\n\n## Overview\n\nThis refactoring introduces a **declarative macro system** for keycode definitions, splits oversized driver files into focused submodules, adds the `KeyInjector` trait for testability, and extracts shared utilities. All changes maintain **zero runtime overhead** through compile-time code generation.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Dependency Injection**: New `KeyInjector` trait follows existing trait-based DI pattern\n- **Performance**: Declarative macros compile to match statements (jump tables)\n- **Input latency < 1ms**: No runtime lookups, all conversions are compiled\n\n### Project Structure (structure.md)\n- Follows existing `core/src/` organization\n- New submodules under `drivers/linux/` and `drivers/windows/`\n- Shared utilities in `drivers/common.rs`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`InputSource` trait**: Pattern for new `KeyInjector` trait\n- **`MockInput`**: Pattern for new `MockKeyInjector`\n- **`error.rs`**: Error types for new driver errors\n- **Existing tests**: Patterns for new unit tests\n\n### Integration Points\n- **`LinuxInput`**: Will use injected `KeyInjector` instead of owned `UinputWriter`\n- **`WindowsInput`**: Will use injected `KeyInjector` instead of owned `SendInputInjector`\n- **`RhaiRuntime`**: Will use shared `parse_key_or_error()` helper\n\n## Architecture\n\n### Keycode Definition System\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│  keycodes.rs (SINGLE SOURCE OF TRUTH)                           │\n│  ┌─────────────────────────────────────────────────────────────┐│\n│  │ define_keycodes! {                                          ││\n│  │   A       => evdev: 30,  vk: 0x41, aliases: [\"a\"];          ││\n│  │   B       => evdev: 48,  vk: 0x42, aliases: [\"b\"];          ││\n│  │   CapsLock=> evdev: 58,  vk: 0x14, aliases: [\"caps\"];       ││\n│  │   // ... all 127 keycodes                                   ││\n│  │ }                                                           ││\n│  └─────────────────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────────────────┘\n                              │\n                              │ Generates at compile time:\n                              ▼\n┌──────────────────┬──────────────────┬──────────────────┬──────────────────┐\n│ KeyCode enum     │ Display impl     │ FromStr impl     │ evdev↔KeyCode    │\n│ (types.rs)       │ (auto-derived)   │ (with aliases)   │ vk↔KeyCode       │\n└──────────────────┴──────────────────┴──────────────────┴──────────────────┘\n```\n\n### Driver Module Structure\n\n```\ndrivers/\n├── mod.rs              # Re-exports: LinuxInput, WindowsInput, DeviceInfo\n├── common.rs           # DeviceInfo, extract_panic_message()\n├── keycodes.rs         # define_keycodes! macro + invocation\n├── injector.rs         # KeyInjector trait + MockKeyInjector\n│\n├── linux/\n│   ├── mod.rs          # LinuxInput struct, InputSource impl\n│   ├── reader.rs       # EvdevReader (event capture thread)\n│   ├── writer.rs       # UinputWriter impl KeyInjector\n│   └── keymap.rs       # evdev_to_keycode(), keycode_to_evdev()\n│\n└── windows/\n    ├── mod.rs          # WindowsInput struct, InputSource impl\n    ├── hook.rs         # HookManager (WH_KEYBOARD_LL)\n    ├── injector.rs     # SendInputInjector impl KeyInjector\n    └── keymap.rs       # vk_to_keycode(), keycode_to_vk()\n```\n\n## Components and Interfaces\n\n### Component 1: Keycode Macro System\n\n**Purpose:** Single source of truth for all keycode definitions\n**File:** `core/src/drivers/keycodes.rs`\n\n```rust\n/// Declarative macro generating KeyCode enum and all conversions\nmacro_rules! define_keycodes {\n    (\n        $(\n            $variant:ident => evdev: $evdev:expr, vk: $vk:expr,\n                              aliases: [$($alias:literal),*]\n        );* $(;)?\n    ) => {\n        // 1. Generate KeyCode enum (imported by types.rs)\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\n        pub enum KeyCode {\n            $($variant,)*\n            Unknown(u16),\n        }\n\n        // 2. Generate Display impl\n        impl std::fmt::Display for KeyCode { ... }\n\n        // 3. Generate FromStr impl (with aliases)\n        impl std::str::FromStr for KeyCode { ... }\n\n        // 4. Generate evdev conversion (Linux only)\n        #[cfg(target_os = \"linux\")]\n        pub fn evdev_to_keycode(code: u16) -> KeyCode { ... }\n\n        #[cfg(target_os = \"linux\")]\n        pub fn keycode_to_evdev(key: KeyCode) -> u16 { ... }\n\n        // 5. Generate VK conversion (Windows only)\n        #[cfg(target_os = \"windows\")]\n        pub fn vk_to_keycode(vk: u16) -> KeyCode { ... }\n\n        #[cfg(target_os = \"windows\")]\n        pub fn keycode_to_vk(key: KeyCode) -> u16 { ... }\n\n        // 6. Generate key set for uinput registration\n        #[cfg(target_os = \"linux\")]\n        pub fn all_keycodes() -> &'static [u16] { ... }\n    };\n}\n\n// Single invocation - THE source of truth\ndefine_keycodes! {\n    // Letters A-Z\n    A       => evdev: 30,  vk: 0x41, aliases: [\"a\"];\n    B       => evdev: 48,  vk: 0x42, aliases: [\"b\"];\n    // ... all 127 keycodes\n}\n```\n\n**Interfaces:**\n- `KeyCode` enum (pub)\n- `evdev_to_keycode()`, `keycode_to_evdev()` (pub, cfg linux)\n- `vk_to_keycode()`, `keycode_to_vk()` (pub, cfg windows)\n- `all_keycodes()` (pub, cfg linux)\n\n**Dependencies:** None (self-contained)\n\n### Component 2: KeyInjector Trait\n\n**Purpose:** Abstract key injection for testability\n**File:** `core/src/drivers/injector.rs`\n\n```rust\nuse crate::engine::KeyCode;\nuse anyhow::Result;\n\n/// Trait for injecting keyboard events into the OS.\n///\n/// Enables mock injection for testing without hardware.\npub trait KeyInjector: Send {\n    /// Inject a key press or release.\n    fn inject(&mut self, key: KeyCode, pressed: bool) -> Result<()>;\n\n    /// Sync/flush any pending events (Linux uinput needs this).\n    fn sync(&mut self) -> Result<()>;\n}\n\n/// Mock injector for testing.\n#[derive(Default)]\npub struct MockKeyInjector {\n    pub injected: Vec<(KeyCode, bool)>,\n}\n\nimpl KeyInjector for MockKeyInjector {\n    fn inject(&mut self, key: KeyCode, pressed: bool) -> Result<()> {\n        self.injected.push((key, pressed));\n        Ok(())\n    }\n\n    fn sync(&mut self) -> Result<()> {\n        Ok(())\n    }\n}\n```\n\n**Interfaces:** `KeyInjector` trait, `MockKeyInjector` struct\n**Dependencies:** `KeyCode` from keycodes module\n**Reuses:** Pattern from `InputSource` trait\n\n### Component 3: Shared Utilities\n\n**Purpose:** Extract duplicated patterns\n**File:** `core/src/drivers/common.rs` (extend existing)\n\n```rust\n/// Extract message from panic payload.\n/// Used by both Linux and Windows driver threads.\npub fn extract_panic_message(panic_info: Box<dyn std::any::Any + Send>) -> String {\n    if let Some(s) = panic_info.downcast_ref::<&str>() {\n        s.to_string()\n    } else if let Some(s) = panic_info.downcast_ref::<String>() {\n        s.clone()\n    } else {\n        \"Unknown panic\".to_string()\n    }\n}\n```\n\n**File:** `core/src/scripting/helpers.rs` (new)\n\n```rust\nuse crate::engine::KeyCode;\nuse rhai::{EvalAltResult, Position};\n\n/// Parse a key name or return a Rhai-compatible error.\n/// Used by remap(), block(), pass() functions.\npub fn parse_key_or_error(\n    name: &str,\n    func_name: &str\n) -> std::result::Result<KeyCode, Box<EvalAltResult>> {\n    KeyCode::from_name(name).ok_or_else(|| {\n        Box::new(EvalAltResult::ErrorRuntime(\n            format!(\n                \"Unknown key '{}' in {}(). See docs/KEYS.md for valid names.\",\n                name, func_name\n            ).into(),\n            Position::NONE,\n        ))\n    })\n}\n```\n\n### Component 4: Linux Driver Submodules\n\n**Purpose:** Split 1,600-line file into focused modules\n\n#### `linux/mod.rs` (~150 lines)\n- `LinuxInput` struct with `KeyInjector` generic\n- `InputSource` trait implementation\n- `new()` and `new_with_injector()` constructors\n- Re-exports: `list_keyboards`, `EvdevReader`, `UinputWriter`\n\n#### `linux/reader.rs` (~200 lines)\n- `EvdevReader` struct\n- `spawn()` method (refactored to ~40 lines)\n- `run_loop()` helper\n- `handle_thread_exit()` helper\n\n#### `linux/writer.rs` (~150 lines)\n- `UinputWriter` struct\n- `KeyInjector` trait implementation\n- `create_virtual_device()` helper\n\n#### `linux/keymap.rs` (~50 lines)\n- Re-exports from keycodes.rs\n- `evdev_to_keycode()` wrapper\n- `keycode_to_evdev()` wrapper\n\n### Component 5: Windows Driver Submodules\n\n**Purpose:** Split 1,743-line file into focused modules\n\n#### `windows/mod.rs` (~200 lines)\n- `WindowsInput` struct with `KeyInjector` generic\n- `InputSource` trait implementation\n- Re-exports: `list_keyboards`, `HookManager`, `SendInputInjector`\n\n#### `windows/hook.rs` (~250 lines)\n- `HookManager` struct\n- `low_level_keyboard_proc` callback\n- Thread-local storage management\n\n#### `windows/injector.rs` (~100 lines)\n- `SendInputInjector` struct\n- `KeyInjector` trait implementation\n- `is_extended_key()` helper\n\n#### `windows/keymap.rs` (~50 lines)\n- Re-exports from keycodes.rs\n- `vk_to_keycode()` wrapper\n- `keycode_to_vk()` wrapper\n\n## Data Models\n\n### KeyCode Enum (generated)\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum KeyCode {\n    // Letters A-Z (26)\n    A, B, C, D, E, F, G, H, I, J, K, L, M,\n    N, O, P, Q, R, S, T, U, V, W, X, Y, Z,\n\n    // Numbers 0-9 (10)\n    Key0, Key1, Key2, Key3, Key4, Key5, Key6, Key7, Key8, Key9,\n\n    // Function keys F1-F12 (12)\n    F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,\n\n    // Modifiers (8)\n    LeftShift, RightShift, LeftCtrl, RightCtrl,\n    LeftAlt, RightAlt, LeftMeta, RightMeta,\n\n    // ... all 127 variants\n\n    Unknown(u16),\n}\n```\n\n### Keycode Definition Record\n\n```rust\n// Internal to macro - not exposed\nstruct KeycodeDef {\n    variant: &'static str,\n    evdev: u16,\n    vk: u16,\n    aliases: &'static [&'static str],\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Unknown keycode in evdev/vk conversion**\n   - **Handling:** Return `KeyCode::Unknown(code)`\n   - **User Impact:** None - graceful fallback\n\n2. **Unknown key name in Rhai script**\n   - **Handling:** Return Rhai `ErrorRuntime` with helpful message\n   - **User Impact:** Script error with key name and docs reference\n\n3. **Key injection failure**\n   - **Handling:** Propagate error through `KeyInjector::inject()`\n   - **User Impact:** Error logged, key event dropped\n\n## Testing Strategy\n\n### Unit Testing\n\n**Keycode macro tests:**\n- Roundtrip: `evdev_to_keycode(keycode_to_evdev(k)) == k`\n- Roundtrip: `vk_to_keycode(keycode_to_vk(k)) == k`\n- FromStr with aliases: `KeyCode::from_str(\"caps\") == Ok(KeyCode::CapsLock)`\n- Display: `KeyCode::A.to_string() == \"A\"`\n\n**KeyInjector tests:**\n- `MockKeyInjector` captures all injections\n- Error propagation from failed injections\n\n**Shared utility tests:**\n- `extract_panic_message()` handles &str, String, and unknown\n- `parse_key_or_error()` returns correct errors\n\n### Integration Testing\n\n**Driver tests with mocks:**\n```rust\n#[tokio::test]\nasync fn linux_input_with_mock_injector() {\n    let mock = MockKeyInjector::default();\n    let input = LinuxInput::new_with_injector(None, mock)?;\n    // ... test without real uinput\n}\n```\n\n### Benchmark Testing\n\n```rust\n#[bench]\nfn bench_evdev_to_keycode(b: &mut Bencher) {\n    b.iter(|| evdev_to_keycode(30)); // Should be <10ns\n}\n\n#[bench]\nfn bench_keycode_to_evdev(b: &mut Bencher) {\n    b.iter(|| keycode_to_evdev(KeyCode::A)); // Should be <10ns\n}\n```\n\n**Regression threshold:** Any increase > 100 microseconds fails CI.\n",
  "fileStats": {
    "size": 12606,
    "lines": 380,
    "lastModified": "2025-11-30T03:29:05.470Z"
  },
  "comments": []
}