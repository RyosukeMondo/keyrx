{
  "id": "snapshot_1765468336808_7j5wqcas6",
  "approvalId": "approval_1765468336772_6ak7i80gp",
  "approvalTitle": "Dependency Injection - Tasks Document (43 tasks)",
  "version": 1,
  "timestamp": "2025-12-11T15:52:16.808Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n## Phase 1: Create Service Trait Abstractions (Foundation)\n\n- [ ] 1.1 Create services/traits.rs with DeviceServiceTrait\n  - File: core/src/services/traits.rs\n  - Define `DeviceServiceTrait` with all 6 async methods from existing `DeviceService`\n  - Add `#[async_trait]` attribute and `Send + Sync` bounds\n  - Import all required types (DeviceView, DeviceServiceError, etc.)\n  - Purpose: Establish contract for device service implementations\n  - _Leverage: core/src/services/device.rs (extract method signatures)_\n  - _Requirements: 1.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust architect specializing in trait design and async patterns\n\nTask: Create `core/src/services/traits.rs` and define `DeviceServiceTrait` following requirement 1.1. Extract all 6 public async method signatures from `DeviceService` in `core/src/services/device.rs` (list_devices, get_device, set_remap_enabled, assign_profile, unassign_profile, set_label). Add `#[async_trait]` macro and ensure trait is `Send + Sync`. Include comprehensive doc comments for each method.\n\nRestrictions: Do not modify DeviceService implementation yet. Only create trait definition. Do not change method signatures - they must match existing implementation exactly. Do not add new methods beyond what exists in DeviceService.\n\nSuccess: DeviceServiceTrait compiles successfully with all 6 async methods. Trait is Send + Sync. All return types and parameter types match existing DeviceService methods exactly. Doc comments explain contract.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field including any apiEndpoints, components, functions, classes, or integrations created\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 1.2 Add ProfileServiceTrait to traits.rs\n  - File: core/src/services/traits.rs (continue from 1.1)\n  - Define `ProfileServiceTrait` with all 9 methods from existing `ProfileService`\n  - All methods are synchronous (no async_trait needed for this trait)\n  - Add `Send + Sync` bounds\n  - Purpose: Establish contract for profile service implementations\n  - _Leverage: core/src/services/profile.rs (extract method signatures)_\n  - _Requirements: 1.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust architect specializing in trait design\n\nTask: Add `ProfileServiceTrait` to `core/src/services/traits.rs` following requirement 1.1. Extract all 9 public method signatures from `ProfileService` in `core/src/services/profile.rs` (list_virtual_layouts, save_virtual_layout, delete_virtual_layout, list_hardware_profiles, save_hardware_profile, delete_hardware_profile, list_keymaps, save_keymap, delete_keymap). These methods are synchronous. Ensure trait is `Send + Sync`. Include comprehensive doc comments.\n\nRestrictions: Do not modify ProfileService implementation. Only add trait definition. Method signatures must match existing implementation exactly. Do not add async_trait as these methods are synchronous.\n\nSuccess: ProfileServiceTrait compiles successfully with all 9 synchronous methods. Trait is Send + Sync. All return types match existing ProfileService methods exactly. Doc comments explain contract clearly.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 1.3 Add RuntimeServiceTrait to traits.rs\n  - File: core/src/services/traits.rs (continue from 1.2)\n  - Define `RuntimeServiceTrait` with all 5 methods from existing `RuntimeService`\n  - All methods are synchronous\n  - Add `Send + Sync` bounds\n  - Purpose: Establish contract for runtime service implementations\n  - _Leverage: core/src/services/runtime.rs (extract method signatures)_\n  - _Requirements: 1.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust architect specializing in trait design\n\nTask: Add `RuntimeServiceTrait` to `core/src/services/traits.rs` following requirement 1.1. Extract all 5 public method signatures from `RuntimeService` in `core/src/services/runtime.rs` (get_config, add_slot, remove_slot, reorder_slot, set_slot_active). These methods are synchronous. Ensure trait is `Send + Sync`. Include comprehensive doc comments.\n\nRestrictions: Do not modify RuntimeService implementation. Only add trait definition. Method signatures must match existing implementation exactly. Do not add async_trait as these methods are synchronous.\n\nSuccess: RuntimeServiceTrait compiles successfully with all 5 synchronous methods. Trait is Send + Sync. All return types match existing RuntimeService methods exactly. Doc comments explain contract. File core/src/services/traits.rs is under 500 lines.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 1.4 Update services/mod.rs to export traits\n  - File: core/src/services/mod.rs\n  - Add `pub mod traits;` and re-export all three trait types\n  - Ensure existing module exports remain unchanged\n  - Purpose: Make traits accessible via `use keyrx_core::services::*;`\n  - _Leverage: Existing mod.rs structure_\n  - _Requirements: 1.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust module organization specialist\n\nTask: Update `core/src/services/mod.rs` following requirement 1.1. Add module declaration for traits (`pub mod traits;`) and re-export all three traits (`pub use traits::{DeviceServiceTrait, ProfileServiceTrait, RuntimeServiceTrait};`). Preserve all existing module declarations and exports.\n\nRestrictions: Do not remove or modify existing module exports. Only add new exports for traits module. Maintain alphabetical or logical ordering of module declarations.\n\nSuccess: traits module is properly declared and exported. All three traits are re-exported at services module level. Existing exports remain unchanged. Code compiles successfully. Can import traits via `use keyrx_core::services::DeviceServiceTrait;`.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 2: Implement Traits on Existing Services\n\n- [ ] 2.1 Implement DeviceServiceTrait for DeviceService\n  - File: core/src/services/device.rs\n  - Add `#[async_trait] impl DeviceServiceTrait for DeviceService`\n  - Implement all 6 trait methods by delegating to existing implementations (zero logic changes)\n  - Add necessary imports (async_trait macro)\n  - Purpose: Make DeviceService conform to trait contract\n  - _Leverage: Existing DeviceService method implementations_\n  - _Requirements: 1.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust backend developer with expertise in trait implementations\n\nTask: Add trait implementation to `core/src/services/device.rs` following requirement 1.1. Add `use async_trait::async_trait;` import. Add `#[async_trait] impl DeviceServiceTrait for DeviceService { }` block. Move all 6 existing public method implementations into this trait impl block without changing their logic. Ensure method signatures match trait definition exactly.\n\nRestrictions: ZERO logic changes to existing methods. Only move code into trait impl block. Do not change method behavior, error handling, or return values. Do not modify struct definition or constructor yet. Maintain all existing tracing instrumentation.\n\nSuccess: DeviceService successfully implements DeviceServiceTrait. All 6 methods compile and work identically to before. Existing tests still pass. No behavior changes. Code organization improved with trait impl block clearly marked.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 2.2 Implement ProfileServiceTrait for ProfileService\n  - File: core/src/services/profile.rs\n  - Add `impl ProfileServiceTrait for ProfileService`\n  - Implement all 9 trait methods by delegating to existing implementations (zero logic changes)\n  - No async_trait needed (synchronous methods)\n  - Purpose: Make ProfileService conform to trait contract\n  - _Leverage: Existing ProfileService method implementations_\n  - _Requirements: 1.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust backend developer with expertise in trait implementations\n\nTask: Add trait implementation to `core/src/services/profile.rs` following requirement 1.1. Add import for ProfileServiceTrait. Add `impl ProfileServiceTrait for ProfileService { }` block. Move all 9 existing public method implementations into this trait impl block without changing their logic.\n\nRestrictions: ZERO logic changes to existing methods. Only move code into trait impl block. Do not change method behavior or return values. Do not modify struct definition or constructor yet. These are synchronous methods, do not add async_trait.\n\nSuccess: ProfileService successfully implements ProfileServiceTrait. All 9 methods compile and work identically to before. Existing tests still pass. No behavior changes. Code is well-organized with trait impl block.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 2.3 Implement RuntimeServiceTrait for RuntimeService\n  - File: core/src/services/runtime.rs\n  - Add `impl RuntimeServiceTrait for RuntimeService`\n  - Implement all 5 trait methods by delegating to existing implementations (zero logic changes)\n  - No async_trait needed (synchronous methods)\n  - Purpose: Make RuntimeService conform to trait contract\n  - _Leverage: Existing RuntimeService method implementations_\n  - _Requirements: 1.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust backend developer with expertise in trait implementations\n\nTask: Add trait implementation to `core/src/services/runtime.rs` following requirement 1.1. Add import for RuntimeServiceTrait. Add `impl RuntimeServiceTrait for RuntimeService { }` block. Move all 5 existing public method implementations into this trait impl block without changing their logic.\n\nRestrictions: ZERO logic changes to existing methods. Only move code into trait impl block. Do not change method behavior or return values. Do not modify struct definition or constructor yet. These are synchronous methods, do not add async_trait.\n\nSuccess: RuntimeService successfully implements RuntimeServiceTrait. All 5 methods compile and work identically to before. Existing tests still pass. No behavior changes. Code is well-organized with trait impl block.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 3: Add Constructor Injection to Services\n\n- [ ] 3.1 Refactor DeviceService constructor for dependency injection\n  - File: core/src/services/device.rs\n  - Change `DeviceService::new()` to accept `registry: Option<DeviceRegistry>` and `bindings: DeviceBindings` parameters\n  - Add `DeviceService::with_defaults(registry: Option<DeviceRegistry>)` convenience constructor\n  - Remove hardcoded `DeviceBindings::default_path()` from constructor\n  - Remove fallback to `with_revolutionary_runtime()` in `get_registry()` method\n  - Purpose: Enable dependency injection for DeviceService\n  - _Leverage: Existing DeviceService struct and methods_\n  - _Requirements: 3.1, 3.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust refactoring specialist with expertise in dependency injection patterns\n\nTask: Refactor `DeviceService` constructor in `core/src/services/device.rs` following requirements 3.1 and 3.2. Change `new()` signature to `pub fn new(registry: Option<DeviceRegistry>, bindings: DeviceBindings) -> Self`. Add `pub fn with_defaults(registry: Option<DeviceRegistry>) -> Self { Self::new(registry, DeviceBindings::with_path(DeviceBindings::default_path())) }` convenience constructor. In `get_registry()` method, remove the fallback code that calls `with_revolutionary_runtime()` - only return `self.registry.clone()` or `None`.\n\nRestrictions: Do not change method logic beyond removing global fallback. Constructor must store passed dependencies, not create new ones. Maintain backward compatibility by providing with_defaults() convenience method. Do not modify trait implementation from previous tasks.\n\nSuccess: DeviceService constructor accepts injected dependencies. with_defaults() provides convenient production constructor. Global runtime fallback removed. All method logic remains unchanged. Existing tests may need updating but service behavior is identical when dependencies are properly injected.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 3.2 Refactor ProfileService constructor for dependency injection\n  - File: core/src/services/profile.rs\n  - Change `ProfileService::new()` to accept `config_manager: ConfigManager` parameter\n  - Add `ProfileService::with_defaults()` convenience constructor that creates `ConfigManager::default()`\n  - Remove hardcoded `ConfigManager::default()` from constructor\n  - Purpose: Enable dependency injection for ProfileService\n  - _Leverage: Existing ProfileService struct and methods_\n  - _Requirements: 3.1, 3.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust refactoring specialist with expertise in dependency injection patterns\n\nTask: Refactor `ProfileService` constructor in `core/src/services/profile.rs` following requirements 3.1 and 3.2. Change `new()` signature to `pub fn new(config_manager: ConfigManager) -> Self { Self { config_manager } }`. Add `pub fn with_defaults() -> Self { Self::new(ConfigManager::default()) }` convenience constructor. Remove hardcoded ConfigManager::default() from new().\n\nRestrictions: Do not change method logic. Constructor must store passed dependency, not create new one. Maintain backward compatibility by providing with_defaults(). Update Default trait implementation to use with_defaults() if it exists. Do not modify trait implementation.\n\nSuccess: ProfileService constructor accepts injected ConfigManager. with_defaults() provides convenient production constructor. No hardcoded dependencies in new(). All method logic unchanged. Service behavior identical when dependency properly injected.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 3.3 Refactor RuntimeService constructor for dependency injection\n  - File: core/src/services/runtime.rs\n  - Analyze current constructor and identify dependencies\n  - Change `RuntimeService::new()` to accept dependencies as parameters\n  - Add `RuntimeService::with_defaults()` convenience constructor\n  - Remove any hardcoded dependency creation from constructor\n  - Purpose: Enable dependency injection for RuntimeService\n  - _Leverage: Existing RuntimeService struct and methods_\n  - _Requirements: 3.1, 3.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust refactoring specialist with expertise in dependency injection patterns\n\nTask: Refactor `RuntimeService` constructor in `core/src/services/runtime.rs` following requirements 3.1 and 3.2. First analyze the current implementation to identify what dependencies RuntimeService has (likely RuntimeConfig or similar). Change `new()` signature to accept these dependencies as parameters. Add `with_defaults()` convenience constructor that creates default dependencies. Remove any hardcoded dependency creation from new().\n\nRestrictions: Do not change method logic. Constructor must store passed dependencies, not create new ones. Maintain backward compatibility with with_defaults(). Update Default trait if needed. Do not modify trait implementation.\n\nSuccess: RuntimeService constructor accepts injected dependencies. with_defaults() provides convenient production constructor. No hardcoded dependencies in new(). All method logic unchanged. Service behavior identical when dependencies properly injected.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 4: Create ApiContext with Dependency Injection\n\n- [ ] 4.1 Create ApiContext struct in api.rs\n  - File: core/src/api.rs\n  - Add `ApiContext` struct with three `Arc<dyn Trait>` fields for services\n  - Implement `ApiContext::new()` constructor accepting injected services\n  - Implement `ApiContext::with_defaults()` constructor creating real services\n  - Add necessary imports (Arc, service traits)\n  - Purpose: Create API orchestration layer with injected dependencies\n  - _Leverage: Existing api.rs structure_\n  - _Requirements: 2.1, 2.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust architect specializing in dependency injection and API design\n\nTask: Add `ApiContext` struct to `core/src/api.rs` following requirements 2.1 and 2.2. Define struct with three fields: `device_service: Arc<dyn DeviceServiceTrait>`, `profile_service: Arc<dyn ProfileServiceTrait>`, `runtime_service: Arc<dyn RuntimeServiceTrait>`. Implement `new(device_service: Arc<dyn DeviceServiceTrait>, profile_service: Arc<dyn ProfileServiceTrait>, runtime_service: Arc<dyn RuntimeServiceTrait>) -> Self` constructor. Implement `with_defaults() -> Self` that creates `Arc::new(DeviceService::with_defaults(None))`, `Arc::new(ProfileService::with_defaults())`, `Arc::new(RuntimeService::with_defaults())` and passes to new(). Add all necessary imports.\n\nRestrictions: Do not modify existing functions in api.rs yet. Only add new ApiContext struct and constructors. Ensure Arc<dyn Trait> is used (not Arc<ConcreteType>). Keep struct definition under 50 lines including constructors.\n\nSuccess: ApiContext struct compiles successfully. new() constructor accepts trait objects. with_defaults() creates production services. All imports correct. Structure ready for method implementation in next tasks.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 4.2 Convert device API functions to ApiContext methods (part 1 of 3)\n  - File: core/src/api.rs\n  - Convert 6 device-related functions to ApiContext methods: list_devices, get_device, set_device_remap, assign_device_profile, unassign_device_profile, set_device_label\n  - Change function signatures from `pub async fn list_devices()` to `pub async fn list_devices(&self)`\n  - Replace `DEVICE_SERVICE.method()` calls with `self.device_service.method()`\n  - Maintain all tracing instrumentation\n  - Purpose: Enable dependency injection for device API functions\n  - _Leverage: Existing device API function implementations_\n  - _Requirements: 2.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust refactoring specialist with expertise in API layer design\n\nTask: Refactor device-related functions in `core/src/api.rs` to ApiContext methods following requirement 2.2. Add impl block for ApiContext. Move 6 device functions (list_devices, get_device, set_device_remap, assign_device_profile, unassign_device_profile, set_device_label) into impl ApiContext block. Change each from standalone function to method by adding `&self` parameter. Replace all `DEVICE_SERVICE.method()` calls with `self.device_service.method()`. Keep all existing logic, error handling, and tracing unchanged.\n\nRestrictions: Do not remove original standalone functions yet (needed for backward compatibility in later task). Only add new methods to ApiContext. Do not change method logic beyond replacing service access. Maintain all tracing::instrument attributes. Keep each method under 50 lines.\n\nSuccess: ApiContext has 6 device-related methods. All methods compile and delegate to self.device_service. Logic identical to original functions. Tracing preserved. Methods are &self (not &mut self). All async/await preserved.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 4.3 Convert profile API functions to ApiContext methods (part 2 of 3)\n  - File: core/src/api.rs (continue from 4.2)\n  - Convert 9 profile-related functions to ApiContext methods: list_virtual_layouts, save_virtual_layout, delete_virtual_layout, list_hardware_profiles, save_hardware_profile, delete_hardware_profile, list_keymaps, save_keymap, delete_keymap\n  - Change function signatures to accept `&self`\n  - Replace `PROFILE_SERVICE.method()` calls with `self.profile_service.method()`\n  - Maintain all tracing instrumentation\n  - Purpose: Enable dependency injection for profile API functions\n  - _Leverage: Existing profile API function implementations_\n  - _Requirements: 2.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust refactoring specialist with expertise in API layer design\n\nTask: Add profile-related methods to ApiContext impl block in `core/src/api.rs` following requirement 2.2. Move 9 profile functions (list_virtual_layouts, save_virtual_layout, delete_virtual_layout, list_hardware_profiles, save_hardware_profile, delete_hardware_profile, list_keymaps, save_keymap, delete_keymap) into ApiContext impl block. Add `&self` parameter to each. Replace `PROFILE_SERVICE.method()` calls with `self.profile_service.method()`. Keep all logic and tracing unchanged.\n\nRestrictions: Do not remove original standalone functions yet. Only add methods to ApiContext. Do not change method logic. Maintain tracing attributes. Keep each method under 50 lines. These methods are synchronous, not async.\n\nSuccess: ApiContext has 9 profile-related methods. All methods compile and delegate to self.profile_service. Logic identical to original functions. Tracing preserved. Synchronous methods properly implemented.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 4.4 Convert runtime API functions to ApiContext methods (part 3 of 3)\n  - File: core/src/api.rs (continue from 4.3)\n  - Convert 5 runtime-related functions to ApiContext methods: get_runtime_config, runtime_add_slot, runtime_remove_slot, runtime_reorder_slot, runtime_set_slot_active\n  - Change function signatures to accept `&self`\n  - Replace `RUNTIME_SERVICE.method()` calls with `self.runtime_service.method()`\n  - Maintain all tracing instrumentation\n  - Purpose: Enable dependency injection for runtime API functions\n  - _Leverage: Existing runtime API function implementations_\n  - _Requirements: 2.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust refactoring specialist with expertise in API layer design\n\nTask: Add runtime-related methods to ApiContext impl block in `core/src/api.rs` following requirement 2.2. Move 5 runtime functions (get_runtime_config, runtime_add_slot, runtime_remove_slot, runtime_reorder_slot, runtime_set_slot_active) into ApiContext impl block. Add `&self` parameter to each. Replace `RUNTIME_SERVICE.method()` calls with `self.runtime_service.method()`. Keep all logic and tracing unchanged.\n\nRestrictions: Do not remove original standalone functions yet. Only add methods to ApiContext. Do not change method logic. Maintain tracing attributes. Keep each method under 50 lines.\n\nSuccess: ApiContext has 5 runtime-related methods. All methods compile and delegate to self.runtime_service. Logic identical to original functions. Tracing preserved. ApiContext now has all 20 API methods (6 device + 9 profile + 5 runtime).\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 4.5 Add GLOBAL_API and update standalone functions for backward compatibility\n  - File: core/src/api.rs (continue from 4.4)\n  - Add `lazy_static! { static ref GLOBAL_API: ApiContext = ApiContext::with_defaults(); }`\n  - Update all 20 standalone functions to delegate to `GLOBAL_API.method()`\n  - Add init_logger and create_log_stream methods to ApiContext if they don't delegate to services\n  - Ensure all existing public API remains unchanged\n  - Purpose: Maintain 100% backward compatibility with existing code\n  - _Leverage: Existing api.rs public API surface_\n  - _Requirements: 2.3_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust backward compatibility specialist\n\nTask: Add backward compatibility layer to `core/src/api.rs` following requirement 2.3. Add lazy_static dependency if not present. Add `lazy_static! { static ref GLOBAL_API: ApiContext = ApiContext::with_defaults(); }` after ApiContext impl block. Update all 20 standalone functions (device: 6, profile: 9, runtime: 5) to call corresponding GLOBAL_API methods: `pub async fn list_devices() -> anyhow::Result<Vec<DeviceView>> { GLOBAL_API.list_devices().await }`. Handle init_logger and create_log_stream functions appropriately (they may not use services).\n\nRestrictions: Do not remove any existing public functions. Do not change function signatures. Each standalone function should be 1-3 lines (just delegation). Do not change ApiContext methods. Maintain all doc comments on public functions.\n\nSuccess: GLOBAL_API static defined using ApiContext::with_defaults(). All 20 public API functions delegate to GLOBAL_API. Existing code using api::list_devices() continues working. No breaking changes. Zero duplicate logic (standalone functions just delegate).\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 5: Create Mock Service Implementations\n\n- [ ] 5.1 Create services/mocks.rs with MockDeviceService\n  - File: core/src/services/mocks.rs (new file)\n  - Create `MockDeviceService` struct with fields for test data and configured errors\n  - Implement builder pattern methods: `new()`, `with_devices()`, `with_get_error()`, `with_list_error()`, etc.\n  - Add call tracking with HashMap<String, usize> to count method invocations\n  - Implement `DeviceServiceTrait` for `MockDeviceService` with mock behavior\n  - Purpose: Enable fast, isolated unit testing of device API\n  - _Leverage: DeviceServiceTrait from traits.rs_\n  - _Requirements: 4.1, 4.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust test infrastructure developer with expertise in mock implementations\n\nTask: Create `core/src/services/mocks.rs` and implement `MockDeviceService` following requirements 4.1 and 4.2. Define struct with: `devices: Vec<DeviceView>`, error fields for each trait method (`list_error: Option<DeviceServiceError>`, etc.), `call_counts: Arc<Mutex<HashMap<String, usize>>>` for tracking calls. Implement `new()` returning empty mock. Implement builder methods `with_devices(self, devices: Vec<DeviceView>) -> Self`, `with_list_error(self, error: DeviceServiceError) -> Self`, etc. for each trait method. Implement `get_call_count(&self, method: &str) -> usize` helper. Implement DeviceServiceTrait where each method: (1) increments call counter, (2) returns error if configured, (3) returns success data if configured.\n\nRestrictions: All operations must be pure in-memory (zero I/O). Errors must be cloneable. Use Arc<Mutex<HashMap>> for thread-safe call tracking. Each trait method implementation should be 5-15 lines. Return clones of data, not references.\n\nSuccess: MockDeviceService compiles and implements DeviceServiceTrait. Builder pattern allows fluent configuration. Call tracking works correctly. Can configure success and error responses. All methods are pure in-memory. Under 200 lines total.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 5.2 Add MockProfileService to mocks.rs\n  - File: core/src/services/mocks.rs (continue from 5.1)\n  - Create `MockProfileService` struct with fields for layouts, hardware profiles, keymaps, and errors\n  - Implement builder pattern methods for configuration\n  - Add call tracking\n  - Implement `ProfileServiceTrait` for `MockProfileService`\n  - Purpose: Enable fast, isolated unit testing of profile API\n  - _Leverage: ProfileServiceTrait from traits.rs_\n  - _Requirements: 4.1, 4.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust test infrastructure developer with expertise in mock implementations\n\nTask: Add `MockProfileService` to `core/src/services/mocks.rs` following requirements 4.1 and 4.2. Define struct with: `virtual_layouts: Vec<VirtualLayout>`, `hardware_profiles: Vec<HardwareProfile>`, `keymaps: Vec<Keymap>`, error fields for each trait method, `call_counts: Arc<Mutex<HashMap<String, usize>>>`. Implement new(), builder methods for configuring data and errors, get_call_count() helper. Implement ProfileServiceTrait with mock behavior (increment counter, return error if configured, return data otherwise).\n\nRestrictions: Pure in-memory operations only. Methods should handle save by adding to collection, delete by filtering, list by returning clones. Use Arc<Mutex> for call tracking. Keep implementation simple and predictable. Each trait method 5-15 lines.\n\nSuccess: MockProfileService implements ProfileServiceTrait. Builder pattern works. Call tracking functional. Can configure data and errors. All operations in-memory. Under 200 lines.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 5.3 Add MockRuntimeService to mocks.rs\n  - File: core/src/services/mocks.rs (continue from 5.2)\n  - Create `MockRuntimeService` struct with fields for runtime config and errors\n  - Implement builder pattern methods for configuration\n  - Add call tracking\n  - Implement `RuntimeServiceTrait` for `MockRuntimeService`\n  - Purpose: Enable fast, isolated unit testing of runtime API\n  - _Leverage: RuntimeServiceTrait from traits.rs_\n  - _Requirements: 4.1, 4.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust test infrastructure developer with expertise in mock implementations\n\nTask: Add `MockRuntimeService` to `core/src/services/mocks.rs` following requirements 4.1 and 4.2. Define struct with: `config: RuntimeConfig`, error fields for each trait method, `call_counts: Arc<Mutex<HashMap<String, usize>>>`. Implement new(), builder methods (with_config, with_get_error, etc.), get_call_count(). Implement RuntimeServiceTrait with mock behavior.\n\nRestrictions: Pure in-memory. Methods should modify internal config state appropriately. Use Arc<Mutex> for call tracking. Keep simple. Each trait method 5-15 lines. File should stay under 500 lines total.\n\nSuccess: MockRuntimeService implements RuntimeServiceTrait. Builder pattern works. Call tracking functional. Can configure state and errors. All in-memory. Total mocks.rs file under 500 lines.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 5.4 Export mocks from services/mod.rs for tests\n  - File: core/src/services/mod.rs\n  - Add `#[cfg(test)] pub mod mocks;` conditional module declaration\n  - Add re-exports for all three mock types under cfg(test)\n  - Ensure mocks are only compiled in test builds\n  - Purpose: Make mocks available to tests without bloating production builds\n  - _Leverage: Existing mod.rs structure_\n  - _Requirements: 4.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Rust module organization specialist\n\nTask: Update `core/src/services/mod.rs` following requirement 4.1. Add conditional module declaration and exports for test mocks. Add `#[cfg(test)] pub mod mocks;` after existing modules. Add `#[cfg(test)] pub use mocks::{MockDeviceService, MockProfileService, MockRuntimeService};` for convenient imports in tests.\n\nRestrictions: Mocks must only be available in test builds, not production. Use #[cfg(test)] attribute correctly. Do not modify existing module declarations or exports. Keep additions minimal.\n\nSuccess: Mocks module declared and exported conditionally. Can import mocks in tests via `use keyrx_core::services::MockDeviceService;`. Mocks not included in production builds (verify with `cargo build --release` and check binary size). All existing exports unchanged.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 6: Write Unit Tests with Mocks\n\n- [ ] 6.1 Create unit tests for device API with mocks\n  - File: core/tests/unit/api/device_api_tests.rs (new file, create directory if needed)\n  - Write 8-10 unit tests for device API methods using MockDeviceService\n  - Test success cases: list_devices, get_device, set_remap_enabled, etc.\n  - Test error cases: device not found, I/O errors, etc.\n  - Verify mock call tracking\n  - Purpose: Demonstrate fast, isolated testing with mocks\n  - _Leverage: MockDeviceService from services/mocks.rs_\n  - _Requirements: 5.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: QA engineer with expertise in Rust unit testing and mocking\n\nTask: Create `core/tests/unit/api/device_api_tests.rs` following requirement 5.1. Write comprehensive unit tests for ApiContext device methods. Include tests: (1) test_list_devices_returns_mock_data - verify correct devices returned, (2) test_get_device_success - verify specific device retrieved, (3) test_get_device_not_found - verify error handling, (4) test_set_remap_enabled_updates_device - verify remap enabled, (5) test_assign_profile_success - verify profile assignment, (6) test_api_handles_io_error - verify error propagation, (7) test_mock_tracks_method_calls - verify call counting. Each test creates ApiContext with mocked services, calls method, asserts results.\n\nRestrictions: Must use MockDeviceService, not real DeviceService. Tests must be pure (no I/O). Each test should run in <1ms. Use tokio::test for async tests. Do not access filesystem. Verify both success and error paths. Use assert macros appropriately.\n\nSuccess: 8-10 unit tests created and passing. Tests use ApiContext::new() with mocks. All tests pure in-memory. Error cases covered. Call tracking verified. Tests complete in <10ms total. Clear test names and assertions.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 6.2 Create unit tests for profile API with mocks\n  - File: core/tests/unit/api/profile_api_tests.rs (new file)\n  - Write 8-10 unit tests for profile API methods using MockProfileService\n  - Test CRUD operations for layouts, hardware profiles, and keymaps\n  - Test error cases\n  - Verify mock call tracking\n  - Purpose: Demonstrate comprehensive profile API testing\n  - _Leverage: MockProfileService from services/mocks.rs_\n  - _Requirements: 5.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: QA engineer with expertise in Rust unit testing and mocking\n\nTask: Create `core/tests/unit/api/profile_api_tests.rs` following requirement 5.1. Write tests for ApiContext profile methods. Include: (1) test_list_virtual_layouts, (2) test_save_virtual_layout, (3) test_delete_virtual_layout, (4) test_list_hardware_profiles, (5) test_save_hardware_profile, (6) test_list_keymaps, (7) test_save_keymap, (8) test_profile_not_found_error, (9) test_storage_error_handling, (10) test_mock_call_tracking. Use MockProfileService for all tests.\n\nRestrictions: Pure in-memory tests. No filesystem access. Tests under 1ms each. Use appropriate assertions. Test both success and error paths. Verify mock behavior.\n\nSuccess: 8-10 unit tests passing. All use mocks. Pure in-memory. Error cases covered. Tests complete quickly. Clear and maintainable.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 6.3 Create unit tests for runtime API with mocks\n  - File: core/tests/unit/api/runtime_api_tests.rs (new file)\n  - Write 6-8 unit tests for runtime API methods using MockRuntimeService\n  - Test slot management operations\n  - Test error cases\n  - Verify mock call tracking\n  - Purpose: Complete API unit test coverage with mocks\n  - _Leverage: MockRuntimeService from services/mocks.rs_\n  - _Requirements: 5.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: QA engineer with expertise in Rust unit testing and mocking\n\nTask: Create `core/tests/unit/api/runtime_api_tests.rs` following requirement 5.1. Write tests for ApiContext runtime methods. Include: (1) test_get_runtime_config, (2) test_add_slot, (3) test_remove_slot, (4) test_reorder_slot, (5) test_set_slot_active, (6) test_runtime_error_handling, (7) test_mock_call_tracking. Use MockRuntimeService.\n\nRestrictions: Pure in-memory. No I/O. Fast tests (<1ms). Test success and error paths. Verify mock behavior.\n\nSuccess: 6-8 unit tests passing. All use mocks. Pure in-memory. Error cases covered. Fast execution. Clear tests.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 6.4 Create integration tests with real services\n  - File: core/tests/integration/api_integration_tests.rs (new file)\n  - Write 5-8 integration tests using real services with temporary filesystem\n  - Test ApiContext::with_defaults() in realistic scenarios\n  - Test real I/O, config loading, error handling with actual files\n  - Purpose: Verify real implementations work correctly when integrated\n  - _Leverage: Real DeviceService, ProfileService, RuntimeService with tempfile_\n  - _Requirements: 5.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Integration test specialist with expertise in filesystem testing\n\nTask: Create `core/tests/integration/api_integration_tests.rs` following requirement 5.1. Write integration tests using real services with temporary directories. Include: (1) test_api_with_real_services_empty_state - fresh temp dir, (2) test_device_binding_persistence - save and reload bindings, (3) test_profile_crud_with_filesystem - save/load profiles, (4) test_error_handling_with_real_io - permission errors, missing files, (5) test_api_defaults_constructor - verify with_defaults() works. Use tempfile::tempdir() for isolated filesystem. Construct ApiContext with real services injecting temp paths.\n\nRestrictions: Use temporary directories for all I/O. Clean up after tests. Tests can be slower (>1ms) but should complete in <100ms. Must test real error conditions. Verify actual file contents where appropriate.\n\nSuccess: 5-8 integration tests passing. Use real services with temp filesystem. Test actual I/O and error handling. Tests are isolated and reliable. Cleanup properly. Demonstrate DI works with real implementations.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 6.5 Update existing service tests to use dependency injection\n  - File: core/src/services/tests/test_services.rs (if exists, or individual test files)\n  - Review existing service tests and identify tests using global state\n  - Refactor service tests to inject dependencies via constructors\n  - Ensure tests create service instances with mock dependencies\n  - Purpose: Migrate existing tests to DI pattern\n  - _Leverage: New constructor injection pattern from Phase 3_\n  - _Requirements: 5.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Test refactoring specialist\n\nTask: Update existing service tests following requirement 5.1. Search for existing tests in `core/src/services/tests/` or `core/tests/unit/services/`. Identify tests that create services with `Service::new()` using defaults. Refactor these tests to either: (1) inject mock dependencies for pure unit tests, or (2) inject temp filesystem paths for integration tests. Replace `DeviceService::new(None)` with `DeviceService::new(None, test_bindings)`. Replace `ProfileService::new()` with `ProfileService::new(test_config_manager)`. Similar for RuntimeService.\n\nRestrictions: Maintain test coverage. Do not change test assertions. Only update service construction. Tests should still pass with same behavior. Prefer injecting mocks for unit tests, real deps with temp paths for integration tests.\n\nSuccess: Existing service tests updated to use DI constructors. Tests still pass. Coverage maintained. Tests are now more explicit about dependencies. Clear distinction between unit and integration tests.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 7: Documentation and Examples\n\n- [ ] 7.1 Create services/README.md with DI documentation\n  - File: core/src/services/README.md (new file)\n  - Write comprehensive documentation explaining DI pattern in KeyRx\n  - Include sections: Overview, Architecture, Using ApiContext, Writing Tests, Migration Guide, Best Practices\n  - Provide code examples for each section\n  - Purpose: Guide developers in using and extending DI pattern\n  - _Leverage: Implementation from all previous phases_\n  - _Requirements: 6.1, 6.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Technical writer with Rust expertise\n\nTask: Create `core/src/services/README.md` following requirements 6.1 and 6.2. Write comprehensive DI documentation. Structure: (1) Overview - explain dependency injection and why KeyRx uses it, (2) Architecture - describe trait abstraction layer, service implementations, ApiContext, (3) Production Usage - show ApiContext::with_defaults() usage, (4) Testing - show mocking examples with code, (5) Migration Guide - help developers update existing code, (6) Best Practices - do's and don'ts. Include 5-8 code examples. Keep under 500 lines total.\n\nRestrictions: Write in clear, tutorial style. Code examples must compile. Explain concepts simply. Target audience is contributors new to the codebase. Focus on practical usage, not theory.\n\nSuccess: README created with all required sections. Code examples are clear and correct. Documentation is helpful for new contributors. Covers both production and test usage. Migration guide is actionable. Under 500 lines.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 7.2 Add doc comments to all public trait methods\n  - Files: core/src/services/traits.rs\n  - Add comprehensive doc comments to every public trait method\n  - Include parameter descriptions, return value descriptions, error conditions\n  - Add usage examples where helpful\n  - Purpose: Provide inline documentation for service contracts\n  - _Leverage: Existing service method documentation_\n  - _Requirements: 6.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Technical documentation specialist\n\nTask: Add doc comments to all trait methods in `core/src/services/traits.rs` following requirement 6.1. For each method, add doc comment with: (1) Brief description of what method does, (2) Parameters section with each parameter explained, (3) Returns section explaining return value, (4) Errors section listing possible errors, (5) Example showing typical usage. Use Rust doc comment format (///). Be concise but complete.\n\nRestrictions: Do not modify method signatures. Only add documentation. Keep each doc comment under 20 lines unless complex method needs more. Focus on contract specification, not implementation details.\n\nSuccess: Every trait method has comprehensive doc comment. Documentation explains what, not how. Parameters, returns, and errors documented. Examples provided where helpful. Documentation is clear and useful.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 7.3 Add doc comments to ApiContext and mocks\n  - Files: core/src/api.rs, core/src/services/mocks.rs\n  - Add doc comments to ApiContext struct, constructors, and key methods\n  - Add doc comments to mock structs and builder methods\n  - Include usage examples\n  - Purpose: Document API layer and testing utilities\n  - _Leverage: Existing documentation patterns_\n  - _Requirements: 6.1_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Technical documentation specialist\n\nTask: Add doc comments following requirement 6.1. In `core/src/api.rs`: document ApiContext struct explaining its purpose, document new() and with_defaults() constructors with usage examples, add module-level doc comment explaining API layer. In `core/src/services/mocks.rs`: add module-level doc comment explaining mock testing, document each mock struct, document key builder methods. Include examples showing typical test setup.\n\nRestrictions: Do not change code logic. Only add documentation. Keep comments concise. Focus on helping users understand when and how to use these components.\n\nSuccess: ApiContext fully documented with examples. Mock structs documented with testing examples. Module-level docs provide context. Documentation helps developers quickly understand usage patterns.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the code changes\n3. Use log-implementation tool to record implementation details with comprehensive artifacts field\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 8: Verify and Measure Impact\n\n- [ ] 8.1 Run full test suite and measure performance\n  - Command: `cargo test --lib` and `cargo test --all`\n  - Measure total test runtime (expect <0.5s for unit tests)\n  - Verify all tests pass\n  - Check for any test failures or warnings\n  - Purpose: Validate DI implementation and measure improvement\n  - _Leverage: cargo test infrastructure_\n  - _Requirements: 5.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: QA validation specialist\n\nTask: Verify test suite performance following requirement 5.2. Run `time cargo test --lib` to measure unit test runtime. Run `time cargo test --all` to measure full suite. Record timings. Verify all tests pass. Check that unit tests using mocks complete in <0.5s total. Compare against original 2.46s baseline. Document any failures or warnings. Run tests multiple times to get consistent measurements.\n\nRestrictions: Do not fix code issues in this task, only measure and report. If tests fail, document failures but do not fix yet. This is a verification task only.\n\nSuccess: Test suite measurements recorded. Unit tests complete in <0.5s (target <0.2s). Full suite results documented. All tests pass, or failures are documented with details. Performance improvement quantified (expected 10-12x speedup for unit tests).\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the verification\n3. Use log-implementation tool to record results\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 8.2 Verify test coverage with cargo-llvm-cov\n  - Command: `cargo llvm-cov --lib --summary-only`\n  - Measure code coverage percentage\n  - Verify meets 80% overall minimum\n  - Check critical paths have 90%+ coverage\n  - Purpose: Ensure DI implementation maintains/improves test coverage\n  - _Leverage: cargo-llvm-cov tool_\n  - _Requirements: 5.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Code coverage specialist\n\nTask: Measure test coverage following requirement 5.2. Run `cargo llvm-cov --lib --summary-only` to get overall coverage. Run `cargo llvm-cov --lib --html` to generate detailed report. Check coverage for: (1) services/traits.rs, (2) services/device.rs, (3) services/profile.rs, (4) services/runtime.rs, (5) api.rs. Verify overall coverage 80%, critical paths 90%. Document any gaps in coverage.\n\nRestrictions: Do not add new tests yet, only measure current coverage. If coverage is insufficient, document gaps but do not fix. This is verification only.\n\nSuccess: Coverage measurements recorded. Overall coverage 80% verified (or gaps documented). Critical path coverage 90% verified (or gaps documented). HTML report generated for analysis. Any coverage gaps identified with specific line numbers.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the verification\n3. Use log-implementation tool to record results\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 8.3 Run clippy and ensure no new warnings\n  - Command: `cargo clippy --all-targets -- -D warnings`\n  - Verify no clippy warnings introduced\n  - Check for common DI-related issues (unnecessary clones, incorrect trait bounds, etc.)\n  - Purpose: Ensure code quality standards maintained\n  - _Leverage: cargo clippy linter_\n  - _Requirements: Non-functional requirements (code quality)_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Code quality specialist\n\nTask: Verify code quality. Run `cargo clippy --all-targets -- -D warnings` and ensure it passes. Check specifically for: (1) unnecessary Arc clones, (2) trait object issues, (3) async trait warnings, (4) unused imports or dead code. Document any clippy warnings or errors. If issues found, categorize as critical (must fix) or minor (nice to fix).\n\nRestrictions: Do not fix issues in this task, only document them. This is verification only. If clippy fails, document all warnings/errors with file locations.\n\nSuccess: Clippy check completed. Either: (1) No warnings (ideal), or (2) All warnings documented with severity and locations. Any DI-specific issues identified. Ready for cleanup task if needed.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the verification\n3. Use log-implementation tool to record results\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 8.4 Verify file size compliance (max 500 lines)\n  - Command: `find core/src -name \"*.rs\" -exec wc -l {} + | awk '$1 > 500 {print}'`\n  - Check all modified files are under 500-line limit\n  - Check specifically: traits.rs, mocks.rs, api.rs\n  - Purpose: Ensure code quality standards met\n  - _Leverage: User's code quality guidelines_\n  - _Requirements: Non-functional requirements (code quality)_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Code metrics specialist\n\nTask: Verify file size compliance. Run `wc -l core/src/services/traits.rs core/src/services/mocks.rs core/src/api.rs` to check lines. Verify: traits.rs <500 lines (target ~300), mocks.rs <500 lines (target ~400), api.rs <500 lines (target ~250). If any file exceeds limit, document file, current size, and suggest split points. Check for any other modified files exceeding limit.\n\nRestrictions: Measure only, do not refactor. If limits exceeded, document but do not fix. This is verification only.\n\nSuccess: All file sizes documented. Either: (1) All files under 500 lines (compliant), or (2) Violations documented with split recommendations. User's code quality standard verified.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the verification\n3. Use log-implementation tool to record results\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 8.5 Run formatter and ensure consistency\n  - Command: `cargo fmt --check`\n  - Verify all code is properly formatted\n  - Run `cargo fmt` if needed to auto-format\n  - Purpose: Ensure code formatting standards maintained\n  - _Leverage: cargo fmt tool_\n  - _Requirements: Non-functional requirements (code quality)_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Code formatting specialist\n\nTask: Verify code formatting. Run `cargo fmt --check` to check if code is formatted. If check fails, run `cargo fmt` to auto-format all code. Verify formatting succeeds without errors. Commit any formatting changes separately from functional changes.\n\nRestrictions: Just run formatter, no manual code changes. Trust cargo fmt to apply project's formatting rules. If formatter makes changes, review them briefly but trust the tool.\n\nSuccess: All code properly formatted. `cargo fmt --check` passes. If formatter made changes, they are committed separately. Code follows project formatting standards consistently.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the verification\n3. Use log-implementation tool to record results\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 9: Fix Any Issues Found During Verification\n\n- [ ] 9.1 Fix any test failures identified in 8.1\n  - Files: Various test files as needed\n  - Address any test failures from verification phase\n  - Ensure all tests pass\n  - Purpose: Achieve 100% passing tests\n  - _Leverage: Test failure details from 8.1_\n  - _Requirements: 5.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Bug fix specialist\n\nTask: Fix test failures identified in task 8.1. Review failure details. For each failure: (1) Identify root cause, (2) Fix implementation or test as appropriate, (3) Verify fix locally, (4) Re-run affected tests. Prioritize actual bugs over flaky tests. Ensure fixes don't break other tests.\n\nRestrictions: Only fix issues identified in verification. Do not add new features or refactor beyond what's needed for fixes. Keep changes minimal and focused.\n\nSuccess: All test failures resolved. `cargo test --all` passes completely. Fixes are minimal and targeted. No regressions introduced. Tests are stable and reliable.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the fixes\n3. Use log-implementation tool to record fixes with comprehensive artifacts\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 9.2 Fix any clippy warnings identified in 8.3\n  - Files: Various source files as needed\n  - Address clippy warnings from verification phase\n  - Ensure `cargo clippy -- -D warnings` passes\n  - Purpose: Achieve clean code quality checks\n  - _Leverage: Clippy warning details from 8.3_\n  - _Requirements: Non-functional requirements_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Code quality specialist\n\nTask: Fix clippy warnings identified in task 8.3. Review each warning. Apply fixes: (1) Remove unnecessary clones/allocations, (2) Fix trait bound issues, (3) Remove unused code, (4) Address any async trait warnings. Run `cargo clippy --all-targets -- -D warnings` after each fix to verify. Ensure all warnings resolved.\n\nRestrictions: Only fix warnings identified in verification. Follow clippy's suggestions unless they conflict with design. Keep fixes minimal and correct.\n\nSuccess: All clippy warnings resolved. `cargo clippy --all-targets -- -D warnings` passes cleanly. Code quality improved. No false positives suppressed unnecessarily.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the fixes\n3. Use log-implementation tool to record fixes with comprehensive artifacts\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 9.3 Fix any file size violations identified in 8.4\n  - Files: Any files exceeding 500 lines\n  - Split large files into smaller modules\n  - Maintain all functionality and API surface\n  - Purpose: Meet code quality standards\n  - _Leverage: Violation details from 8.4_\n  - _Requirements: Non-functional requirements_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Code refactoring specialist\n\nTask: Fix file size violations identified in task 8.4. For each file over 500 lines: (1) Identify logical split points, (2) Create submodules, (3) Move code to submodules, (4) Re-export from parent module to maintain API, (5) Verify compilation and tests. Keep public API unchanged.\n\nRestrictions: Only split files that exceeded limit. Maintain exact same functionality and public API. Do not refactor logic, only reorganize into smaller files. Each new file should be under 500 lines ideally under 300.\n\nSuccess: All files under 500-line limit. Public API unchanged. All tests still pass. Code is better organized with logical module boundaries. Imports remain simple for users.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the refactoring\n3. Use log-implementation tool to record changes with comprehensive artifacts\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 9.4 Add tests if coverage gaps identified in 8.2\n  - Files: New test files or additions to existing tests\n  - Write tests to cover any gaps below 80% threshold\n  - Focus on critical paths to reach 90% coverage\n  - Purpose: Meet test coverage standards\n  - _Leverage: Coverage report from 8.2_\n  - _Requirements: 5.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Test coverage specialist\n\nTask: Add tests to fill coverage gaps identified in task 8.2. Review coverage report. For each gap: (1) Identify uncovered lines/branches, (2) Write targeted tests to cover them, (3) Verify coverage improves, (4) Ensure tests are meaningful (not just hitting lines). Prioritize critical paths to reach 90%, then fill other gaps to reach 80% overall.\n\nRestrictions: Write quality tests, not just coverage-boosting tests. Test real scenarios and edge cases. Use mocks for unit tests, real services for integration tests. Keep tests maintainable.\n\nSuccess: Test coverage 80% overall, 90% for critical paths (services, API). New tests are meaningful and valuable. Coverage gaps filled with quality tests. Tests pass reliably.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Implement the new tests\n3. Use log-implementation tool to record tests with comprehensive artifacts\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Phase 10: Final Validation and Documentation\n\n- [ ] 10.1 Run full CI checks (just ci-check)\n  - Command: `just ci-check` or equivalent full CI validation\n  - Verify all checks pass: fmt, clippy, tests, docs\n  - Ensure no regressions\n  - Purpose: Final validation before completion\n  - _Leverage: Project's CI configuration_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: CI/CD specialist\n\nTask: Run full CI validation. Execute `just ci-check` or run all CI steps manually: (1) cargo fmt --check, (2) cargo clippy --all-targets -- -D warnings, (3) cargo test --all, (4) cargo doc --no-deps. Verify all pass. Document results. If any failures, refer back to appropriate fix task.\n\nRestrictions: This is final validation only. Do not fix issues in this task. If checks fail, document and create follow-up tasks.\n\nSuccess: All CI checks pass. CI is green. Project is ready for use. Any failures are documented with clear next steps.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Run the validation\n3. Use log-implementation tool to record results\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 10.2 Update CODEBASE_EVALUATION.md with results\n  - File: CODEBASE_EVALUATION.md\n  - Add \"Implementation Results\" section documenting outcomes\n  - Record test performance improvements (before/after timings)\n  - Note any deviations from original plan\n  - Purpose: Document the impact of DI implementation\n  - _Leverage: Results from all verification tasks_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Technical writer\n\nTask: Update CODEBASE_EVALUATION.md with implementation results. Add new section \"# Implementation Results - Dependency Injection\" at end. Document: (1) Test performance before/after, (2) Code coverage before/after, (3) File organization improvements, (4) Any issues encountered and how resolved, (5) Actual vs estimated effort, (6) Lessons learned. Use tables and numbers to show concrete improvements.\n\nRestrictions: Be factual and specific. Use actual measurements from verification tasks. Acknowledge any issues honestly. Keep professional tone.\n\nSuccess: CODEBASE_EVALUATION.md updated with comprehensive results section. Performance improvements quantified. Coverage improvements shown. Document serves as reference for future work. Stakeholders can clearly see value delivered.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Update the documentation\n3. Use log-implementation tool to record the update\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n- [ ] 10.3 Create migration guide for remaining code\n  - File: core/docs/MIGRATION_TO_DI.md (new file)\n  - Write guide for migrating remaining global API usage to ApiContext\n  - Provide examples for CLI, FFI, and other consumers\n  - Purpose: Help future developers complete migration\n  - _Leverage: Implementation examples from all phases_\n  - _Requirements: 6.1, 6.2_\n  - _Prompt: Implement the task for spec dependency-injection. First run spec-workflow-guide to get the workflow guide, then implement the task:\n\nRole: Technical writer and developer advocate\n\nTask: Create `core/docs/MIGRATION_TO_DI.md` following requirements 6.1 and 6.2. Structure: (1) Introduction - why migrate, benefits, (2) For CLI Commands - show before/after examples, (3) For FFI Layer - show integration patterns, (4) For New Features - best practices from start, (5) Troubleshooting - common issues and solutions, (6) FAQs - answer common questions. Include 6-10 code examples showing real migrations.\n\nRestrictions: Write clearly for developers at all skill levels. Examples must be realistic and correct. Focus on practical migration, not theory. Keep under 400 lines.\n\nSuccess: Migration guide created. Examples are clear and realistic. Guide helps developers migrate code confidently. Covers CLI, FFI, and new feature development. Troubleshooting section addresses common issues. Under 400 lines total.\n\nAfter completing implementation:\n1. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[ ]` to `[-]` for this task before starting\n2. Create the guide\n3. Use log-implementation tool to record the creation\n4. Edit `.spec-workflow/specs/dependency-injection/tasks.md` and change `[-]` to `[x]` when complete_\n\n## Summary\n\n**Total Tasks:** 43 tasks across 10 phases\n\n**Estimated Effort:** 2-3 days (as originally estimated in evaluation)\n\n**Expected Impact:**\n-  50-80% faster tests (2.46s  <0.5s)\n-  Enable true unit testing (pure, isolated, <1ms per test)\n-  Maintain/improve coverage (80% overall, 90% critical paths)\n-  SOLID principles enforced (DIP, ISP)\n-  Testability blockers removed\n-  Zero breaking changes (100% backward compatible)\n-  Clear architecture with trait abstractions\n-  Comprehensive documentation and examples\n\n**Key Deliverables:**\n- 3 service traits defining contracts\n- 3 service implementations with constructor injection\n- ApiContext orchestration layer with DI\n- 3 mock service implementations for testing\n- 20+ new unit tests demonstrating fast, isolated testing\n- Comprehensive documentation (README, migration guide, doc comments)\n- All code quality standards met (formatting, linting, file sizes)\n- Test coverage maintained/improved\n",
  "fileStats": {
    "size": 74212,
    "lines": 987,
    "lastModified": "2025-12-11T15:52:06.392Z"
  },
  "comments": []
}