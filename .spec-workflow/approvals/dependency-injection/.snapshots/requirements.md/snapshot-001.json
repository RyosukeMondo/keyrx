{
  "id": "snapshot_1765468336589_60gqcim4o",
  "approvalId": "approval_1765468336533_o5asv6tkv",
  "approvalTitle": "Dependency Injection - Requirements Document",
  "version": 1,
  "timestamp": "2025-12-11T15:52:16.589Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe KeyRx codebase currently uses global singleton services (`lazy_static!`) which prevents proper unit testing, dependency injection, and parallel test execution. This spec addresses the #1 priority improvement: implementing proper dependency injection to enable fast, isolated unit tests and maintainable code architecture.\n\n**Problem Statement:**\n- Global singletons in `core/src/api.rs` (DEVICE_SERVICE, PROFILE_SERVICE, RUNTIME_SERVICE) block all unit testing\n- Services hardcode their dependencies, preventing mock injection\n- No service traits exist, making interface-based programming impossible\n- Tests must use real I/O (file system, config loading), making them slow (2.46s for full suite)\n- Cannot test error paths without complex filesystem mocking\n- Violates SOLID principles (Dependency Inversion, Interface Segregation)\n\n**Value Proposition:**\n- **50-80% faster tests** (2.46s → ~0.2s for full suite)\n- **Enable true unit testing** - tests run in <1ms with no I/O\n- **Parallel test execution** - no global state conflicts\n- **Easy error path testing** - inject failing mocks\n- **Better code architecture** - follows SOLID principles, adheres to user's DI mandate\n- **Hours saved per week** - tests run hundreds of times per day during development\n\n## Alignment with Product Vision\n\nThis feature supports the core development principles outlined in `~/.claude/CLAUDE.md`:\n\n- **Code Quality Enforcement**: Implements mandatory DI as required by user guidelines\n- **Architecture**: Enforces SOLID principles, specifically Dependency Inversion Principle (DIP)\n- **Testability**: Removes testability blockers by eliminating hard dependencies\n- **No testability blockers**: All external deps injected (APIs, DBs, queues) as mandated\n\n## Requirements\n\n### Requirement 1: Service Trait Abstractions\n\n**User Story:** As a developer, I want service interfaces (traits) defined for all core services, so that I can write tests with mock implementations and follow interface-based programming patterns.\n\n#### Acceptance Criteria\n\n1. WHEN `DeviceServiceTrait` is defined THEN it SHALL include all public methods from `DeviceService` with identical signatures\n2. WHEN `ProfileServiceTrait` is defined THEN it SHALL include all public methods from `ProfileService` with identical signatures\n3. WHEN `RuntimeServiceTrait` is defined THEN it SHALL include all public methods from `RuntimeService` with identical signatures\n4. WHEN existing services implement their traits THEN all methods SHALL delegate to existing implementations without behavior changes\n5. IF a service trait method is `async` THEN it SHALL use `#[async_trait]` annotation\n6. WHEN traits are defined THEN they SHALL be `Send + Sync` to support multi-threaded environments\n\n**Success Metrics:**\n- 3 new trait definitions created (`DeviceServiceTrait`, `ProfileServiceTrait`, `RuntimeServiceTrait`)\n- All 3 existing service structs implement their corresponding traits\n- Zero behavior changes to existing service logic\n- All async methods properly annotated with `#[async_trait]`\n\n### Requirement 2: Injectable API Context\n\n**User Story:** As a developer, I want the API layer to accept injected service dependencies, so that I can provide real or mock implementations based on the execution context (production vs tests).\n\n#### Acceptance Criteria\n\n1. WHEN `ApiContext` struct is created THEN it SHALL hold trait objects (`Arc<dyn Trait>`) for all three services\n2. WHEN `ApiContext::new()` is called with service implementations THEN it SHALL store them for method dispatch\n3. WHEN `ApiContext::with_defaults()` is called THEN it SHALL create real service implementations for production use\n4. WHEN an API method is called on `ApiContext` THEN it SHALL delegate to the appropriate injected service\n5. IF backward compatibility is required THEN a global `GLOBAL_API` context SHALL be provided using `with_defaults()`\n6. WHEN top-level convenience functions are called (e.g., `api::list_devices()`) THEN they SHALL delegate to `GLOBAL_API` for backward compatibility\n\n**Success Metrics:**\n- `ApiContext` struct created with 3 trait object fields\n- `ApiContext::new()` constructor accepts injected dependencies\n- `ApiContext::with_defaults()` provides production implementation\n- All 28 API functions refactored to accept `&self` on `ApiContext`\n- Backward-compatible top-level functions maintain existing API surface\n- Zero breaking changes to existing code using `api.rs`\n\n### Requirement 3: Constructor Injection for Services\n\n**User Story:** As a developer, I want services to accept their dependencies through constructors, so that I can control what implementations are used and test services in isolation.\n\n#### Acceptance Criteria\n\n1. WHEN `DeviceService::new()` is called THEN it SHALL accept `registry: Option<DeviceRegistry>` and `bindings: DeviceBindings` as parameters\n2. WHEN `ProfileService::new()` is called THEN it SHALL accept `config_manager: ConfigManager` as a parameter\n3. WHEN `RuntimeService::new()` is called THEN it SHALL accept its dependencies as constructor parameters\n4. IF a service has optional dependencies THEN they SHALL be `Option<T>` parameters with documented fallback behavior\n5. WHEN a service method needs a dependency THEN it SHALL use the injected instance, NOT a global fallback\n6. IF `DeviceService::get_registry()` fallback to global runtime exists THEN it SHALL be removed\n\n**Success Metrics:**\n- All service constructors accept their dependencies as parameters\n- No hardcoded `::default()` or `::new()` calls within service constructors\n- Fallback to `with_revolutionary_runtime()` in `DeviceService` removed\n- `ProfileService` no longer hardcodes `ConfigManager::default()`\n- All dependencies are explicitly visible in constructor signatures\n\n### Requirement 4: Mock Service Implementations\n\n**User Story:** As a test developer, I want mock implementations of all service traits, so that I can write fast, isolated unit tests without real I/O or external dependencies.\n\n#### Acceptance Criteria\n\n1. WHEN `MockDeviceService` is created THEN it SHALL implement `DeviceServiceTrait`\n2. WHEN `MockProfileService` is created THEN it SHALL implement `ProfileServiceTrait`\n3. WHEN `MockRuntimeService` is created THEN it SHALL implement `RuntimeServiceTrait`\n4. WHEN a mock service is constructed with test data THEN it SHALL return that data from trait methods\n5. WHEN a mock service is configured to fail THEN it SHALL return the specified error from trait methods\n6. IF a mock is called multiple times THEN it SHALL support call counting and verification\n7. WHEN a mock method is async THEN it SHALL return immediately without actual I/O\n\n**Builder Pattern for Mocks:**\n```rust\nlet mock = MockDeviceService::new()\n    .with_devices(vec![test_device])\n    .with_error_on_get(DeviceServiceError::DeviceNotFound(\"test\".into()));\n```\n\n**Success Metrics:**\n- 3 mock service structs created with builder patterns\n- Each mock implements its corresponding trait\n- Mocks support configurable success and error responses\n- Mocks track method calls for verification\n- All mocks are pure in-memory (zero I/O)\n\n### Requirement 5: Test Migration and Coverage\n\n**User Story:** As a project maintainer, I want existing tests updated to use dependency injection, so that the test suite runs faster and is more maintainable.\n\n#### Acceptance Criteria\n\n1. WHEN unit tests for API functions are written THEN they SHALL use `ApiContext` with injected mocks\n2. WHEN unit tests for services are written THEN they SHALL inject mock dependencies into service constructors\n3. IF a test requires real I/O THEN it SHALL be moved to `core/tests/integration/`\n4. WHEN unit tests run THEN they SHALL complete in <1ms per test (no I/O)\n5. WHEN the full test suite runs THEN it SHALL complete in <0.5s (target: 0.2s for 2,440 tests)\n6. IF tests use `ApiContext` directly THEN they SHALL NOT use global singletons\n\n**Test Example:**\n```rust\n#[tokio::test]\nasync fn test_list_devices_success() {\n    let mock = Arc::new(MockDeviceService::new().with_devices(vec![test_device()]));\n    let api = ApiContext::new(mock, mock_profile(), mock_runtime());\n\n    let devices = api.list_devices().await.unwrap();\n    assert_eq!(devices.len(), 1);\n    // ✅ No I/O, runs in <1ms\n}\n```\n\n**Success Metrics:**\n- All API unit tests migrated to use `ApiContext` with mocks\n- All service unit tests inject mock dependencies\n- Unit test directory contains only pure unit tests (no I/O)\n- Integration tests properly separated and labeled\n- Test suite runtime reduced from 2.46s to <0.5s\n- Test coverage maintained or improved (target: 80% overall, 90% critical paths)\n\n### Requirement 6: Documentation and Examples\n\n**User Story:** As a new contributor, I want clear documentation and examples of dependency injection patterns, so that I can write new code following the project's architecture.\n\n#### Acceptance Criteria\n\n1. WHEN `core/src/services/README.md` is created THEN it SHALL document the DI pattern with examples\n2. WHEN a developer reads the docs THEN they SHALL understand how to inject services in tests\n3. WHEN example tests are provided THEN they SHALL demonstrate both success and error path testing\n4. IF best practices exist THEN they SHALL be documented with code examples\n5. WHEN FFI layer documentation is updated THEN it SHALL explain how FFI uses `ApiContext`\n\n**Documentation Sections Required:**\n- Overview of DI pattern in KeyRx\n- How to create and use `ApiContext`\n- How to write unit tests with mocks\n- How to inject services into new code\n- Migration guide for existing code\n- Best practices and anti-patterns\n\n**Success Metrics:**\n- README.md created with comprehensive DI documentation\n- At least 3 example tests provided (success, error, complex scenario)\n- Migration guide helps developers update existing code\n- FFI layer integration documented\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: Each trait file defines one service interface\n- **Dependency Inversion Principle**: High-level modules (API) depend on abstractions (traits), not concrete implementations\n- **Interface Segregation Principle**: Service traits expose only necessary public methods\n- **Open/Closed Principle**: Services can be extended through trait implementations without modifying existing code\n- **Modular Design**: Traits, implementations, and mocks are in separate modules\n- **Clear Interfaces**: Trait definitions serve as contracts between layers\n\n**File Structure:**\n```\ncore/src/\n├── services/\n│   ├── traits.rs          # Service trait definitions\n│   ├── device.rs          # DeviceService (implements DeviceServiceTrait)\n│   ├── profile.rs         # ProfileService (implements ProfileServiceTrait)\n│   ├── runtime.rs         # RuntimeService (implements RuntimeServiceTrait)\n│   └── mocks.rs           # Mock implementations for testing\n├── api.rs                 # ApiContext with injected dependencies\n└── ...\n```\n\n### Performance\n\n- **Test Runtime**: Full unit test suite SHALL complete in <0.5s (target: 0.2s)\n- **Individual Test Speed**: Pure unit tests SHALL complete in <1ms each\n- **Zero Overhead**: Trait object dispatch SHALL add <1ns overhead (vtable lookup)\n- **Memory Efficiency**: `Arc<dyn Trait>` SHALL add only 16 bytes per service reference\n- **Compilation Time**: Trait definitions SHALL NOT significantly impact compile times\n- **Parallel Execution**: Tests SHALL run in parallel without global state conflicts\n\n**Benchmark Targets:**\n```\nBefore DI: 2,440 tests in 2.46s = ~1ms/test (with I/O)\nAfter DI:  2,440 tests in 0.2s = 0.08ms/test (pure unit tests)\n```\n\n### Reliability\n\n- **Backward Compatibility**: Existing code using `api::list_devices()` SHALL continue working\n- **Zero Behavior Changes**: Service logic SHALL remain identical after refactoring\n- **Error Handling**: All error paths SHALL behave identically before and after\n- **Type Safety**: Rust's type system SHALL prevent injection of incompatible implementations\n- **Thread Safety**: All service traits SHALL be `Send + Sync`\n\n### Testability\n\n- **100% Mockable**: Every service SHALL have a mock implementation\n- **Isolated Tests**: Unit tests SHALL NOT depend on external state or I/O\n- **Deterministic**: Mock responses SHALL be predictable and configurable\n- **Error Simulation**: Mocks SHALL easily simulate error conditions\n- **Call Verification**: Mocks SHALL support verifying method calls and arguments\n\n### Maintainability\n\n- **Clear Contracts**: Trait definitions serve as API documentation\n- **Easy Mocking**: Builder pattern makes mock configuration intuitive\n- **Refactoring Safety**: Trait changes trigger compile errors in all implementations\n- **Code Reuse**: Mock implementations reduce test boilerplate\n- **Migration Path**: Backward-compatible global API allows gradual migration\n\n### Security\n\n- **No Privilege Escalation**: Mocks SHALL NOT bypass security checks in real implementations\n- **Secrets Handling**: Mock services SHALL NOT log or expose real credentials\n- **Input Validation**: Service implementations SHALL validate inputs regardless of injection method\n\n### Usability (Developer Experience)\n\n- **Simple API**: `ApiContext::new(device, profile, runtime)` is straightforward\n- **Obvious Defaults**: `ApiContext::with_defaults()` for production use\n- **Test Clarity**: Mock builder pattern is self-documenting\n- **Error Messages**: Trait object casting failures SHALL produce helpful error messages\n- **IDE Support**: Traits SHALL provide autocomplete for all service methods\n",
  "fileStats": {
    "size": 13640,
    "lines": 258,
    "lastModified": "2025-12-11T15:45:02.170Z"
  },
  "comments": []
}