{
  "id": "snapshot_1765468378898_9w7pohmx4",
  "approvalId": "approval_1765468336687_a6jfc6mtr",
  "approvalTitle": "Dependency Injection - Design Document",
  "version": 2,
  "timestamp": "2025-12-11T15:52:58.898Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design implements dependency injection for KeyRx's service layer, replacing global singleton services with trait-based abstractions and constructor injection. The implementation follows SOLID principles, maintains 100% backward compatibility, and enables fast isolated unit testing.\n\n**Core Design Principles:**\n1. **Trait-based abstractions** - Define service contracts as traits\n2. **Constructor injection** - Services accept dependencies as parameters\n3. **Zero behavior changes** - Refactor structure, not logic\n4. **Backward compatibility** - Existing code continues working\n5. **Test-first architecture** - Design enables easy mocking\n\n## Steering Document Alignment\n\n### Technical Standards (~/.claude/CLAUDE.md)\n\n**Architecture Requirements Met:**\n- ✅ **SOLID Principles**: Implements Dependency Inversion (DIP) and Interface Segregation (ISP)\n- ✅ **Dependency Injection**: All external deps injected as mandated\n- ✅ **No testability blockers**: Removes global singletons, enables mocking\n- ✅ **Error Handling**: Maintains existing error hierarchy\n- ✅ **Code Quality**: Max 500 lines/file, max 50 lines/function enforced\n\n**Testing Requirements Met:**\n- ✅ **Unit tests**: Pure, isolated, mockable dependencies\n- ✅ **80% coverage minimum**: Framework enables comprehensive testing\n- ✅ **No globals**: Services are injected, not accessed via statics\n\n### Project Structure\n\n**Module Organization:**\n```\ncore/src/\n├── services/\n│   ├── mod.rs             # Re-exports all service types\n│   ├── traits.rs          # Service trait definitions\n│   ├── device.rs          # DeviceService implementation\n│   ├── profile.rs         # ProfileService implementation\n│   ├── runtime.rs         # RuntimeService implementation\n│   └── mocks.rs           # Test mock implementations\n├── api.rs                 # ApiContext with DI\n└── ...\n```\n\n**File Size Targets:**\n- `services/traits.rs`: ~300 lines (3 traits × ~100 lines each)\n- `services/mocks.rs`: ~400 lines (3 mocks × ~130 lines each)\n- `api.rs`: ~250 lines (refactored from 197 lines)\n- Each file stays well under 500-line limit ✅\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`DeviceService` (core/src/services/device.rs)**: Extract trait interface from existing implementation\n  - Reuse: All existing methods become trait methods\n  - Extend: Add constructor parameter for `DeviceBindings`\n  - Preserve: Zero logic changes to existing implementation\n\n- **`ProfileService` (core/src/services/profile.rs)**: Extract trait interface\n  - Reuse: All existing methods become trait methods\n  - Extend: Add constructor parameter for `ConfigManager`\n  - Preserve: Zero logic changes\n\n- **`RuntimeService` (core/src/services/runtime.rs)**: Extract trait interface\n  - Reuse: All existing methods become trait methods\n  - Extend: Add constructor parameters for dependencies\n  - Preserve: Zero logic changes\n\n- **`api.rs` functions**: Convert to methods on `ApiContext`\n  - Reuse: All 28 existing functions become `ApiContext` methods\n  - Extend: Accept `&self` to access injected services\n  - Preserve: Top-level convenience functions for backward compatibility\n\n### Integration Points\n\n- **FFI Layer (core/src/ffi/)**: Will use `ApiContext::with_defaults()` for production\n  - Integration: FFI context can hold `ApiContext` instance\n  - Benefit: FFI can provide different contexts for testing\n  - Change: Minimal - just use `ApiContext` instead of direct function calls\n\n- **CLI Commands (core/src/cli/)**: Will use `ApiContext::with_defaults()` for production\n  - Integration: CLI commands instantiate `ApiContext` at startup\n  - Benefit: CLI tests can inject mocks\n  - Change: Minimal - pass `ApiContext` to command handlers\n\n- **Test Suite (core/tests/)**: Will use `ApiContext::new()` with mocks\n  - Integration: Tests create `ApiContext` with `MockService` implementations\n  - Benefit: Fast, isolated tests with controlled behavior\n  - Change: Major - all tests refactored to use DI, but much simpler\n\n## Architecture\n\n### Overall Architecture Pattern: Service-Oriented with Dependency Injection\n\n```mermaid\ngraph TD\n    subgraph \"Application Layer\"\n        CLI[CLI Commands]\n        FFI[FFI Layer]\n    end\n\n    subgraph \"API Layer\"\n        API[ApiContext]\n    end\n\n    subgraph \"Service Layer Abstraction\"\n        DT[DeviceServiceTrait]\n        PT[ProfileServiceTrait]\n        RT[RuntimeServiceTrait]\n    end\n\n    subgraph \"Service Implementations - Production\"\n        DS[DeviceService]\n        PS[ProfileService]\n        RS[RuntimeService]\n    end\n\n    subgraph \"Service Implementations - Testing\"\n        MDS[MockDeviceService]\n        MPS[MockProfileService]\n        MRS[MockRuntimeService]\n    end\n\n    subgraph \"Data Layer\"\n        REG[DeviceRegistry]\n        BIND[DeviceBindings]\n        CFG[ConfigManager]\n    end\n\n    CLI --> API\n    FFI --> API\n\n    API -->|uses| DT\n    API -->|uses| PT\n    API -->|uses| RT\n\n    DS -.implements.-> DT\n    PS -.implements.-> PT\n    RS -.implements.-> RT\n\n    MDS -.implements.-> DT\n    MPS -.implements.-> PT\n    MRS -.implements.-> RT\n\n    DS --> REG\n    DS --> BIND\n    PS --> CFG\n    RS --> CFG\n\n    style API fill:#e1f5e1\n    style DT fill:#fff4e6\n    style PT fill:#fff4e6\n    style RT fill:#fff4e6\n    style MDS fill:#e3f2fd\n    style MPS fill:#e3f2fd\n    style MRS fill:#e3f2fd\n```\n\n### Modular Design Principles\n\n1. **Single File Responsibility**:\n   - `traits.rs`: Only service trait definitions\n   - `mocks.rs`: Only mock implementations\n   - Each service file: Only that service's implementation\n\n2. **Component Isolation**:\n   - Traits define contracts independently of implementations\n   - Mocks are completely isolated from real implementations\n   - Services don't know about their consumers\n\n3. **Service Layer Separation**:\n   - **API Layer** (`api.rs`): Orchestrates service calls, owns service instances\n   - **Service Traits** (`traits.rs`): Define contracts\n   - **Service Implementations** (`device.rs`, `profile.rs`, `runtime.rs`): Business logic\n   - **Data Layer** (existing): Configuration, registry, bindings\n\n4. **Dependency Flow**: Unidirectional, top-down\n   - Application → API → Service Traits → Service Implementations → Data Layer\n   - No circular dependencies\n   - Each layer only knows about its immediate dependencies\n\n## Components and Interfaces\n\n### Component 1: Service Traits\n\n**File:** `core/src/services/traits.rs` (~300 lines)\n\n**Purpose:** Define service contracts as Rust traits that all implementations must follow.\n\n**Interfaces:**\n```rust\n/// Device management service contract\n#[async_trait]\npub trait DeviceServiceTrait: Send + Sync {\n    async fn list_devices(&self) -> Result<Vec<DeviceView>, DeviceServiceError>;\n    async fn get_device(&self, device_key: &str) -> Result<DeviceView, DeviceServiceError>;\n    async fn set_remap_enabled(&self, device_key: &str, enabled: bool) -> Result<DeviceView, DeviceServiceError>;\n    async fn assign_profile(&self, device_key: &str, profile_id: &str) -> Result<DeviceView, DeviceServiceError>;\n    async fn unassign_profile(&self, device_key: &str) -> Result<DeviceView, DeviceServiceError>;\n    async fn set_label(&self, device_key: &str, label: Option<String>) -> Result<DeviceView, DeviceServiceError>;\n}\n\n/// Profile management service contract\npub trait ProfileServiceTrait: Send + Sync {\n    fn list_virtual_layouts(&self) -> Result<Vec<VirtualLayout>, ProfileServiceError>;\n    fn save_virtual_layout(&self, layout: VirtualLayout) -> Result<VirtualLayout, ProfileServiceError>;\n    fn delete_virtual_layout(&self, id: &str) -> Result<(), ProfileServiceError>;\n    fn list_hardware_profiles(&self) -> Result<Vec<HardwareProfile>, ProfileServiceError>;\n    fn save_hardware_profile(&self, profile: HardwareProfile) -> Result<HardwareProfile, ProfileServiceError>;\n    fn delete_hardware_profile(&self, id: &str) -> Result<(), ProfileServiceError>;\n    fn list_keymaps(&self) -> Result<Vec<Keymap>, ProfileServiceError>;\n    fn save_keymap(&self, keymap: Keymap) -> Result<Keymap, ProfileServiceError>;\n    fn delete_keymap(&self, id: &str) -> Result<(), ProfileServiceError>;\n}\n\n/// Runtime configuration service contract\npub trait RuntimeServiceTrait: Send + Sync {\n    fn get_config(&self) -> Result<RuntimeConfig, RuntimeServiceError>;\n    fn add_slot(&self, device: DeviceInstanceId, slot: ProfileSlot) -> Result<RuntimeConfig, RuntimeServiceError>;\n    fn remove_slot(&self, device: DeviceInstanceId, slot_id: &str) -> Result<RuntimeConfig, RuntimeServiceError>;\n    fn reorder_slot(&self, device: DeviceInstanceId, slot_id: &str, new_priority: u32) -> Result<RuntimeConfig, RuntimeServiceError>;\n    fn set_slot_active(&self, device: DeviceInstanceId, slot_id: &str, active: bool) -> Result<RuntimeConfig, RuntimeServiceError>;\n}\n```\n\n**Dependencies:** Only standard library and existing error types\n\n**Design Notes:**\n- All traits are `Send + Sync` for thread safety\n- Async methods use `#[async_trait]` macro\n- Return types match existing service implementations exactly\n- No new error types introduced\n\n**Reuses:** Existing error types (`DeviceServiceError`, `ProfileServiceError`, `RuntimeServiceError`)\n\n---\n\n### Component 2: ApiContext\n\n**File:** `core/src/api.rs` (refactored, ~250 lines)\n\n**Purpose:** API orchestration layer that owns service instances and provides unified API surface.\n\n**Interface:**\n```rust\n/// API context holding injected service dependencies\npub struct ApiContext {\n    device_service: Arc<dyn DeviceServiceTrait>,\n    profile_service: Arc<dyn ProfileServiceTrait>,\n    runtime_service: Arc<dyn RuntimeServiceTrait>,\n}\n\nimpl ApiContext {\n    /// Create new API context with injected services\n    pub fn new(\n        device_service: Arc<dyn DeviceServiceTrait>,\n        profile_service: Arc<dyn ProfileServiceTrait>,\n        runtime_service: Arc<dyn RuntimeServiceTrait>,\n    ) -> Self;\n\n    /// Create API context with default production services\n    pub fn with_defaults() -> Self;\n\n    // Device API\n    #[tracing::instrument(skip(self))]\n    pub async fn list_devices(&self) -> anyhow::Result<Vec<DeviceView>>;\n\n    #[tracing::instrument(skip(self, device_key))]\n    pub async fn get_device(&self, device_key: String) -> anyhow::Result<DeviceView>;\n\n    // ... all 28 API methods as &self methods\n}\n\n// Backward-compatible global context\nlazy_static! {\n    static ref GLOBAL_API: ApiContext = ApiContext::with_defaults();\n}\n\n// Backward-compatible top-level functions\npub async fn list_devices() -> anyhow::Result<Vec<DeviceView>> {\n    GLOBAL_API.list_devices().await\n}\n// ... all 28 functions delegate to GLOBAL_API\n```\n\n**Dependencies:**\n- Service traits from `services::traits`\n- Existing error types\n- `Arc` for shared ownership\n- `lazy_static` for global context (backward compatibility only)\n\n**Design Rationale:**\n- **Why `Arc<dyn Trait>`?** Allows multiple references, trait objects enable polymorphism\n- **Why global `GLOBAL_API`?** Backward compatibility - existing code continues working\n- **Why both methods and functions?** Methods for new code (testable), functions for existing code (compatible)\n\n**Reuses:** All existing API function logic, just refactored to methods\n\n---\n\n### Component 3: Service Implementations with Constructor Injection\n\n**Files:**\n- `core/src/services/device.rs` (modified, ~130 lines)\n- `core/src/services/profile.rs` (modified, ~90 lines)\n- `core/src/services/runtime.rs` (modified, TBD lines)\n\n**Purpose:** Concrete service implementations with injected dependencies.\n\n**DeviceService Example:**\n```rust\npub struct DeviceService {\n    registry: Option<DeviceRegistry>,\n    bindings: DeviceBindings,\n}\n\nimpl DeviceService {\n    /// Create new DeviceService with injected dependencies\n    pub fn new(registry: Option<DeviceRegistry>, bindings: DeviceBindings) -> Self {\n        Self { registry, bindings }\n    }\n\n    /// Convenience constructor with default bindings path\n    pub fn with_defaults(registry: Option<DeviceRegistry>) -> Self {\n        Self::new(registry, DeviceBindings::with_path(DeviceBindings::default_path()))\n    }\n}\n\n#[async_trait]\nimpl DeviceServiceTrait for DeviceService {\n    async fn list_devices(&self) -> Result<Vec<DeviceView>, DeviceServiceError> {\n        // Existing implementation, no changes\n        let mut views = Vec::new();\n        // ... existing logic ...\n        Ok(views)\n    }\n\n    // ... all trait methods implemented with existing logic\n}\n```\n\n**Key Changes:**\n- Constructor now accepts dependencies as parameters\n- Remove fallback to `with_revolutionary_runtime()` global\n- Remove hardcoded `DeviceBindings::default_path()` in constructor\n- Provide `with_defaults()` convenience method for production use\n- Implement trait methods with zero logic changes\n\n**ProfileService Example:**\n```rust\npub struct ProfileService {\n    config_manager: ConfigManager,\n}\n\nimpl ProfileService {\n    pub fn new(config_manager: ConfigManager) -> Self {\n        Self { config_manager }\n    }\n\n    pub fn with_defaults() -> Self {\n        Self::new(ConfigManager::default())\n    }\n}\n\nimpl ProfileServiceTrait for ProfileService {\n    // Implement all trait methods with existing logic\n}\n```\n\n**Dependencies:** Only injected dependencies, no globals\n\n**Reuses:** 100% of existing service logic, zero behavior changes\n\n---\n\n### Component 4: Mock Service Implementations\n\n**File:** `core/src/services/mocks.rs` (~400 lines)\n\n**Purpose:** In-memory mock implementations for fast unit testing.\n\n**Interface:**\n```rust\n/// Mock device service for testing\npub struct MockDeviceService {\n    devices: Vec<DeviceView>,\n    get_error: Option<DeviceServiceError>,\n    set_remap_error: Option<DeviceServiceError>,\n    // ... error fields for each method\n    call_counts: HashMap<String, usize>,\n}\n\nimpl MockDeviceService {\n    pub fn new() -> Self;\n\n    // Builder methods\n    pub fn with_devices(mut self, devices: Vec<DeviceView>) -> Self;\n    pub fn with_get_error(mut self, error: DeviceServiceError) -> Self;\n    pub fn with_list_error(mut self, error: DeviceServiceError) -> Self;\n    // ... error configuration for each method\n\n    // Verification methods\n    pub fn get_call_count(&self, method: &str) -> usize;\n    pub fn was_called(&self, method: &str) -> bool;\n}\n\n#[async_trait]\nimpl DeviceServiceTrait for MockDeviceService {\n    async fn list_devices(&self) -> Result<Vec<DeviceView>, DeviceServiceError> {\n        self.call_counts.entry(\"list_devices\".into()).and_modify(|c| *c += 1).or_insert(1);\n\n        if let Some(err) = &self.list_error {\n            return Err(err.clone());\n        }\n\n        Ok(self.devices.clone())\n    }\n\n    // ... all trait methods return configured data or errors\n}\n```\n\n**Design Features:**\n- **Builder pattern** - Fluent API for configuration\n- **Call tracking** - Record which methods were called\n- **Flexible errors** - Configure specific methods to fail\n- **Pure in-memory** - Zero I/O, instant execution\n- **Clone data** - Return clones of test data\n\n**Usage Example:**\n```rust\n#[tokio::test]\nasync fn test_api_handles_storage_error() {\n    let mock = Arc::new(\n        MockDeviceService::new()\n            .with_list_error(DeviceServiceError::Io(\n                std::io::Error::new(std::io::ErrorKind::PermissionDenied, \"test\")\n            ))\n    );\n\n    let api = ApiContext::new(mock, mock_profile(), mock_runtime());\n\n    let result = api.list_devices().await;\n    assert!(result.is_err());\n    // ✅ Tested error path in <1ms, no real I/O\n}\n```\n\n**Dependencies:** Only trait definitions and error types\n\n**Reuses:** None - purely new code for testing\n\n---\n\n### Component 5: Service Module Organization\n\n**File:** `core/src/services/mod.rs` (~50 lines)\n\n**Purpose:** Re-export all service types for convenient imports.\n\n**Interface:**\n```rust\n// Public API\npub mod traits;\npub use traits::{DeviceServiceTrait, ProfileServiceTrait, RuntimeServiceTrait};\n\npub mod device;\npub use device::DeviceService;\n\npub mod profile;\npub use profile::ProfileService;\n\npub mod runtime;\npub use runtime::RuntimeService;\n\n// Test-only exports\n#[cfg(test)]\npub mod mocks;\n\n#[cfg(test)]\npub use mocks::{MockDeviceService, MockProfileService, MockRuntimeService};\n```\n\n**Dependencies:** Submodules\n\n**Reuses:** Existing module structure pattern\n\n## Data Models\n\n### Existing Models (No Changes)\n\nAll existing data models remain unchanged:\n\n- **DeviceView** - Device information with binding status\n- **VirtualLayout** - Keyboard layout configuration\n- **HardwareProfile** - Hardware wiring profile\n- **Keymap** - Key remapping configuration\n- **ProfileSlot** - Runtime profile slot\n- **RuntimeConfig** - Runtime configuration\n- **DeviceInstanceId** - Device identifier\n- **DeviceBindings** - Device binding storage\n- **ConfigManager** - Configuration management\n- **DeviceRegistry** - Device registry\n\n### New Types Introduced\n\n**None** - This is purely a refactoring for architecture, no new data models needed.\n\n## Error Handling\n\n### Error Scenarios\n\n#### 1. Service Initialization Fails\n\n**Scenario:** `DeviceService::new()` called with invalid bindings path\n\n**Handling:**\n```rust\n// Services don't fail at construction - they accept whatever is passed\n// Errors happen when methods are called with invalid state\nimpl DeviceService {\n    pub fn new(registry: Option<DeviceRegistry>, bindings: DeviceBindings) -> Self {\n        // Always succeeds, defers validation to method calls\n        Self { registry, bindings }\n    }\n}\n```\n\n**User Impact:** None at construction, errors surface when methods called\n\n---\n\n#### 2. Mock Service Configured to Fail\n\n**Scenario:** Test configures mock to return error\n\n**Handling:**\n```rust\n#[async_trait]\nimpl DeviceServiceTrait for MockDeviceService {\n    async fn list_devices(&self) -> Result<Vec<DeviceView>, DeviceServiceError> {\n        if let Some(err) = &self.list_error {\n            return Err(err.clone());  // Return configured error\n        }\n        Ok(self.devices.clone())\n    }\n}\n```\n\n**User Impact:** Test receives expected error, can verify error handling\n\n---\n\n#### 3. Trait Object Downcast Fails\n\n**Scenario:** Developer tries to downcast `Arc<dyn Trait>` to concrete type\n\n**Handling:**\n```rust\n// DON'T DO THIS - defeats purpose of trait abstraction\nlet concrete = device_service.downcast_ref::<DeviceService>(); // ❌ Wrong\n\n// DO THIS - use trait methods only\ndevice_service.list_devices().await; // ✅ Correct\n```\n\n**User Impact:** Compile error if attempting invalid downcast, clear message\n\n---\n\n#### 4. Service Method Returns Error\n\n**Scenario:** Real service encounters I/O error, mock returns configured error\n\n**Handling:** Error propagates through trait method to caller, identical behavior before and after refactoring\n\n**User Impact:** Same error handling as before, no behavior changes\n\n## Testing Strategy\n\n### Unit Testing Approach\n\n**Philosophy:** Unit tests should be fast (<1ms), isolated (no I/O), and deterministic (no external state).\n\n**Test Organization:**\n```\ncore/tests/\n├── unit/\n│   ├── api/\n│   │   ├── device_api_tests.rs    # Test ApiContext device methods\n│   │   ├── profile_api_tests.rs   # Test ApiContext profile methods\n│   │   └── runtime_api_tests.rs   # Test ApiContext runtime methods\n│   ├── services/\n│   │   ├── device_tests.rs         # Test DeviceService logic (with mock deps)\n│   │   ├── profile_tests.rs        # Test ProfileService logic (with mock deps)\n│   │   └── runtime_tests.rs        # Test RuntimeService logic (with mock deps)\n│   └── mocks/\n│       └── mock_behavior_tests.rs  # Test mock implementations themselves\n├── integration/\n│   ├── api_integration_tests.rs    # Test real services with filesystem\n│   └── service_integration_tests.rs\n└── ...\n```\n\n**Unit Test Examples:**\n\n```rust\n// core/tests/unit/api/device_api_tests.rs\n#[tokio::test]\nasync fn test_list_devices_returns_mock_data() {\n    let test_device = DeviceView {\n        key: \"test:device\".into(),\n        connected: true,\n        // ... other fields\n    };\n\n    let mock = Arc::new(\n        MockDeviceService::new().with_devices(vec![test_device.clone()])\n    );\n\n    let api = ApiContext::new(\n        mock,\n        Arc::new(MockProfileService::new()),\n        Arc::new(MockRuntimeService::new()),\n    );\n\n    let devices = api.list_devices().await.unwrap();\n\n    assert_eq!(devices.len(), 1);\n    assert_eq!(devices[0].key, \"test:device\");\n    // ✅ Runs in <1ms, no I/O\n}\n\n#[tokio::test]\nasync fn test_get_device_handles_not_found() {\n    let mock = Arc::new(\n        MockDeviceService::new()\n            .with_get_error(DeviceServiceError::DeviceNotFound(\"missing\".into()))\n    );\n\n    let api = ApiContext::new(mock, mock_profile(), mock_runtime());\n\n    let result = api.get_device(\"missing\".into()).await;\n\n    assert!(result.is_err());\n    match result.unwrap_err().downcast_ref::<DeviceServiceError>() {\n        Some(DeviceServiceError::DeviceNotFound(key)) => assert_eq!(key, \"missing\"),\n        _ => panic!(\"Wrong error type\"),\n    }\n    // ✅ Tested error path in <1ms\n}\n\n#[tokio::test]\nasync fn test_service_method_called_correct_number_of_times() {\n    let mock = Arc::new(MockDeviceService::new());\n    let api = ApiContext::new(Arc::clone(&mock), mock_profile(), mock_runtime());\n\n    let _ = api.list_devices().await;\n    let _ = api.list_devices().await;\n\n    // Verify mock was called exactly twice\n    assert_eq!(mock.get_call_count(\"list_devices\"), 2);\n    // ✅ Verified behavior in <1ms\n}\n```\n\n**Key Components to Test:**\n- ✅ `ApiContext` methods delegate to correct services\n- ✅ Error propagation through API layer\n- ✅ Mock services return configured data\n- ✅ Mock services return configured errors\n- ✅ Mock call tracking works correctly\n- ✅ Trait implementations match method signatures\n- ✅ Service constructors accept dependencies correctly\n\n---\n\n### Integration Testing\n\n**Philosophy:** Integration tests verify real components work together, can use I/O.\n\n**Location:** `core/tests/integration/`\n\n**Test Examples:**\n\n```rust\n// core/tests/integration/api_integration_tests.rs\n#[tokio::test]\nasync fn test_api_with_real_services_and_temp_storage() {\n    let temp_dir = tempfile::tempdir().unwrap();\n\n    let bindings = DeviceBindings::with_path(temp_dir.path().join(\"bindings.json\"));\n    let device_service = Arc::new(DeviceService::new(None, bindings));\n\n    let config_manager = ConfigManager::with_base_path(temp_dir.path());\n    let profile_service = Arc::new(ProfileService::new(config_manager));\n\n    let runtime_service = Arc::new(RuntimeService::with_defaults());\n\n    let api = ApiContext::new(device_service, profile_service, runtime_service);\n\n    // Test real I/O operations\n    let devices = api.list_devices().await.unwrap();\n    assert_eq!(devices.len(), 0); // Empty bindings file\n\n    // ✅ Tests real services with filesystem\n}\n```\n\n**Key Flows to Test:**\n- ✅ Real services with temporary filesystem\n- ✅ Error handling with real I/O failures (permissions, missing files)\n- ✅ Service coordination (e.g., device assignment to profile)\n- ✅ Configuration loading and validation\n\n---\n\n### End-to-End Testing\n\n**Philosophy:** E2E tests verify complete user workflows from CLI/FFI to storage.\n\n**Location:** `core/tests/e2e/`\n\n**Approach:** Use real `ApiContext::with_defaults()` with real filesystem in temp directory\n\n**User Scenarios to Test:**\n1. CLI commands use API correctly\n2. FFI calls work through API layer\n3. Complete workflows (add device → assign profile → enable remap)\n4. Error recovery and user-facing error messages\n\n## Migration Strategy\n\n### Phase 1: Add Traits and Implementations (No Breaking Changes)\n\n1. Create `services/traits.rs` with trait definitions\n2. Implement traits on existing services (`DeviceService`, `ProfileService`, `RuntimeService`)\n3. Update service constructors to accept dependencies\n4. Add `with_defaults()` convenience constructors\n5. Verify all existing code still compiles and works\n\n**Risk:** None - purely additive changes\n\n---\n\n### Phase 2: Refactor API Layer (Backward Compatible)\n\n1. Add `ApiContext` struct to `api.rs`\n2. Convert existing functions to `ApiContext` methods\n3. Keep global `GLOBAL_API` for backward compatibility\n4. Keep top-level convenience functions delegating to `GLOBAL_API`\n5. Update FFI and CLI to use `ApiContext::with_defaults()`\n\n**Risk:** Low - backward compatibility maintained\n\n---\n\n### Phase 3: Add Mock Implementations (Test-Only)\n\n1. Create `services/mocks.rs` with mock implementations\n2. Implement all three traits with mock logic\n3. Add builder methods and call tracking\n4. Export mocks only in test builds (`#[cfg(test)]`)\n\n**Risk:** None - test-only code\n\n---\n\n### Phase 4: Migrate Tests (Iterative)\n\n1. Start with new tests using `ApiContext` and mocks\n2. Gradually migrate existing tests to use DI\n3. Move I/O-dependent tests to `integration/` directory\n4. Verify test suite still passes at each step\n5. Measure test runtime improvement\n\n**Risk:** Medium - requires careful test refactoring, but can be done incrementally\n\n---\n\n### Phase 5: Remove Global Fallbacks (Optional Future Work)\n\n1. Remove `GLOBAL_API` lazy_static (breaking change)\n2. Remove top-level convenience functions\n3. Require all code to explicitly create `ApiContext`\n4. Update all CLI and FFI code to pass `ApiContext` explicitly\n\n**Risk:** High - breaking changes, but improves architecture\n\n**Decision:** Not included in this spec - can be done later if desired\n\n## Performance Considerations\n\n### Trait Object Overhead\n\n- **Virtual dispatch**: ~1ns overhead per method call (negligible)\n- **Memory**: `Arc<dyn Trait>` = 16 bytes (2 pointers: data + vtable)\n- **No heap allocation**: Services allocated once, shared via `Arc`\n\n### Test Performance Improvements\n\n**Before DI:**\n- 2,440 tests in 2.46s = ~1ms/test average\n- Bottleneck: File I/O, config loading, temporary directories\n- Cannot run in parallel due to global state\n\n**After DI:**\n- 2,440 unit tests in ~0.2s = 0.08ms/test\n- Pure memory operations, no I/O\n- Full parallelization with `cargo test -- --test-threads=N`\n- Integration tests still use I/O but isolated\n\n**Expected Speedup:** **10-12x faster** for unit tests\n\n### Compilation Impact\n\n- Trait definitions add ~0.1s to compile time\n- Mock implementations compile only in test builds\n- Incremental compilation unaffected (services still separate modules)\n\n**Expected Impact:** Negligible (<1% increase)\n\n## Backward Compatibility\n\n### Existing Code Continues Working\n\n**Global API Functions:**\n```rust\n// Existing code continues working unchanged\nlet devices = api::list_devices().await?;  // ✅ Still works\n```\n\n**FFI Layer:**\n```rust\n// FFI functions can continue using global API\n#[export_name = \"keyrx_list_devices\"]\npub extern \"C\" fn list_devices() -> *mut c_char {\n    // Uses GLOBAL_API internally\n}\n```\n\n**CLI Commands:**\n```rust\n// CLI can continue using global API\npub async fn run_devices_list() -> Result<()> {\n    let devices = api::list_devices().await?;  // ✅ Still works\n    // ...\n}\n```\n\n### Gradual Migration Path\n\n**New code can use DI:**\n```rust\n// New tests use ApiContext with mocks\nlet api = ApiContext::new(mock_device(), mock_profile(), mock_runtime());\nlet devices = api.list_devices().await?;\n```\n\n**Old code can migrate incrementally:**\n```rust\n// Old code gradually moves to ApiContext\nlet api = ApiContext::with_defaults();  // Production services\nlet devices = api.list_devices().await?;\n```\n\n**No forced migration** - both approaches work simultaneously\n\n## Documentation Plan\n\n### Code Documentation\n\n- Add doc comments to all trait methods\n- Document `ApiContext` usage patterns\n- Document mock builder methods\n- Add usage examples in doc comments\n\n### README.md\n\nCreate `core/src/services/README.md` with:\n- Overview of DI pattern\n- How to use `ApiContext` in production\n- How to write tests with mocks\n- Migration guide for existing code\n- Best practices and anti-patterns\n\n### Example Tests\n\nProvide example tests demonstrating:\n- Success case testing\n- Error path testing\n- Mock configuration\n- Call verification\n\n### Architecture Diagram\n\nInclude architecture diagram showing:\n- Trait abstraction layer\n- Service implementations\n- Mock implementations\n- Dependency injection flow\n",
  "fileStats": {
    "size": 28369,
    "lines": 904,
    "lastModified": "2025-12-11T15:47:16.006Z"
  },
  "comments": []
}