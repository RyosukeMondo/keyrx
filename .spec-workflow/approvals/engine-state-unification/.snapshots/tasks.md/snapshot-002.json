{
  "id": "snapshot_1764768201387_54fo9xcoy",
  "approvalId": "approval_1764767193968_7envc2to9",
  "approvalTitle": "Engine State Unification - Tasks",
  "version": 2,
  "timestamp": "2025-12-03T13:23:21.387Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks Document\n\n## Phase 1: Core Types\n\n- [ ] 1. Create Mutation enum\n  - File: `core/src/engine/state/mutation.rs`\n  - Define all mutation variants (KeyDown, KeyUp, PushLayer, etc.)\n  - Add Debug, Clone derives\n  - Purpose: Explicit state change operations\n  - _Leverage: Existing state change patterns_\n  - _Requirements: 2.1, 2.2_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer designing state mutations | Task: Create Mutation enum in core/src/engine/state/mutation.rs | Restrictions: Cover all state changes, include timestamps, be serializable | _Leverage: Existing state change patterns in engine | Success: Enum covers all mutations, clear semantics | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 2. Create StateChange and Effect types\n  - File: `core/src/engine/state/change.rs`\n  - Define StateChange with version, mutation, effects\n  - Define Effect enum for secondary changes\n  - Add Serialize support\n  - Purpose: Record state changes for events\n  - _Leverage: Event pattern_\n  - _Requirements: 2.3, 4.4_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer creating event types | Task: Create StateChange and Effect in core/src/engine/state/change.rs | Restrictions: Serializable, include version, track all effects | _Leverage: Event sourcing patterns | Success: Changes capture all state effects, serializes correctly | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 3. Create StateError type\n  - File: `core/src/engine/state/error.rs`\n  - Define error variants for invalid mutations\n  - Implement std::error::Error\n  - Purpose: Error handling for state operations\n  - _Leverage: thiserror_\n  - _Requirements: 2.4_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer creating error types | Task: Create StateError in core/src/engine/state/error.rs | Restrictions: Use thiserror, cover all invalid mutations | _Leverage: thiserror patterns | Success: Errors are descriptive, help debugging | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n## Phase 2: State Components\n\n- [ ] 4. Refactor KeyState component\n  - File: `core/src/engine/state/keys.rs`\n  - Extract from KeyStateTracker\n  - Implement is_pressed, press, release methods\n  - Add timestamp tracking\n  - Purpose: Key state as unified component\n  - _Leverage: Existing KeyStateTracker_\n  - _Requirements: 1.2, 3.1_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer refactoring state | Task: Create KeyState in core/src/engine/state/keys.rs from KeyStateTracker | Restrictions: Same functionality, timestamp tracking, efficient lookups | _Leverage: Existing KeyStateTracker | Success: KeyState works identically, cleaner API | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 5. Refactor LayerState component\n  - File: `core/src/engine/state/layers.rs`\n  - Extract from LayerStack\n  - Implement push, pop, active_layers methods\n  - Handle layer priorities\n  - Purpose: Layer state as unified component\n  - _Leverage: Existing LayerStack_\n  - _Requirements: 1.2, 3.2_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer refactoring state | Task: Create LayerState in core/src/engine/state/layers.rs from LayerStack | Restrictions: Same functionality, priority handling, efficient operations | _Leverage: Existing LayerStack | Success: LayerState works identically, cleaner API | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 6. Refactor ModifierState component\n  - File: `core/src/engine/state/modifiers.rs`\n  - Extract from ModifierState\n  - Handle 255 custom modifiers\n  - Implement activate, deactivate, is_active methods\n  - Purpose: Modifier state as unified component\n  - _Leverage: Existing ModifierState_\n  - _Requirements: 1.2, 3.2_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer refactoring state | Task: Create ModifierState in core/src/engine/state/modifiers.rs | Restrictions: Support 255 modifiers, efficient bitmap, clear API | _Leverage: Existing ModifierState | Success: ModifierState supports all modifiers, efficient | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 7. Refactor PendingState component\n  - File: `core/src/engine/state/pending.rs`\n  - Extract from PendingDecisionQueue\n  - Implement add, resolve, clear, timeout methods\n  - Track decision types and timings\n  - Purpose: Pending decisions as unified component\n  - _Leverage: Existing PendingDecisionQueue_\n  - _Requirements: 1.2, 3.4_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer refactoring state | Task: Create PendingState in core/src/engine/state/pending.rs | Restrictions: Track all decision types, efficient resolution, timing aware | _Leverage: Existing PendingDecisionQueue | Success: PendingState handles all decisions, timing works | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n## Phase 3: Unified State\n\n- [ ] 8. Create EngineState container\n  - File: `core/src/engine/state/mod.rs`\n  - Combine all state components\n  - Implement query methods (is_key_pressed, active_layers, etc.)\n  - Add version tracking\n  - Purpose: Single state container\n  - _Leverage: All state components_\n  - _Requirements: 1.1, 1.3, 1.4_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer creating unified state | Task: Create EngineState in core/src/engine/state/mod.rs | Restrictions: Own all components, version tracking, Clone-able | _Leverage: All state components | Success: EngineState provides unified access to all state | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 9. Implement apply() mutation method\n  - File: `core/src/engine/state/mod.rs`\n  - Apply single mutation atomically\n  - Update affected components\n  - Return StateChange\n  - Purpose: Atomic state mutations\n  - _Leverage: Mutation enum, state components_\n  - _Requirements: 2.1, 2.3_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer implementing mutations | Task: Implement apply() in EngineState for atomic mutations | Restrictions: Atomic updates, produce StateChange, handle errors | _Leverage: Mutation enum, components | Success: apply() works for all mutations, changes tracked | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 10. Implement apply_batch() for atomic batches\n  - File: `core/src/engine/state/mod.rs`\n  - Apply multiple mutations atomically\n  - Rollback on failure\n  - Return all StateChanges\n  - Purpose: Batch mutations\n  - _Leverage: apply() method_\n  - _Requirements: 2.2, 2.4_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer implementing batch operations | Task: Implement apply_batch() with rollback on failure | Restrictions: Atomic semantics, full rollback, preserve state on error | _Leverage: apply() method | Success: Batches are atomic, rollback works | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 11. Implement state synchronization\n  - File: `core/src/engine/state/mod.rs`\n  - Sync modifiers when keys released\n  - Sync pending when layers change\n  - Validate invariants after mutations\n  - Purpose: State consistency\n  - _Leverage: State components_\n  - _Requirements: 3.1, 3.2, 3.3, 3.4_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer implementing synchronization | Task: Add state synchronization logic to EngineState mutations | Restrictions: Sync all affected components, validate invariants | _Leverage: Component APIs | Success: State always consistent, invariants enforced | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n## Phase 4: Snapshots and Inspection\n\n- [ ] 12. Create StateSnapshot type\n  - File: `core/src/engine/state/snapshot.rs`\n  - Serializable state representation\n  - Implement From<&EngineState>\n  - Purpose: State export for FFI/debugging\n  - _Leverage: serde_\n  - _Requirements: 4.1, 4.2_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer creating snapshots | Task: Create StateSnapshot in core/src/engine/state/snapshot.rs | Restrictions: Serializable, efficient conversion, include all relevant state | _Leverage: serde | Success: Snapshot captures state, serializes correctly | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 13. Implement state history tracking\n  - File: `core/src/engine/state/history.rs`\n  - Ring buffer of recent StateChanges\n  - Configurable history depth\n  - Purpose: Debugging and replay\n  - _Leverage: StateChange type_\n  - _Requirements: 4.3_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer implementing history | Task: Create StateHistory with ring buffer of changes | Restrictions: Configurable depth, efficient storage, easy iteration | _Leverage: StateChange type | Success: History tracks changes, bounded memory | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 14. Implement state persistence\n  - File: `core/src/engine/state/persistence.rs`\n  - Save/load state to disk\n  - Handle version migration\n  - Fallback to clean state on corruption\n  - Purpose: State persistence across sessions\n  - _Leverage: serde, StateSnapshot_\n  - _Requirements: 5.1, 5.2, 5.3, 5.4_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer implementing persistence | Task: Create state persistence in core/src/engine/state/persistence.rs | Restrictions: Handle migration, detect corruption, safe fallback | _Leverage: serde, StateSnapshot | Success: State persists correctly, handles errors | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n## Phase 5: Integration\n\n- [ ] 15. Update Engine to use EngineState\n  - Files: `core/src/engine/{advanced,processing}.rs`\n  - Replace separate state structs with EngineState\n  - Use apply() for all state changes\n  - Purpose: Engine integration\n  - _Leverage: EngineState_\n  - _Requirements: 1.1_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer integrating state | Task: Update Engine core to use EngineState exclusively | Restrictions: Same behavior, use mutations, maintain performance | _Leverage: EngineState | Success: Engine uses unified state, all tests pass | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 16. Update FFI state exports\n  - File: `core/src/ffi/exports_engine.rs`\n  - Use StateSnapshot for state queries\n  - Emit StateChange events\n  - Purpose: FFI integration\n  - _Leverage: StateSnapshot, StateChange_\n  - _Requirements: 4.1, 4.4_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer updating FFI | Task: Update FFI exports to use StateSnapshot and StateChange | Restrictions: Same API surface, emit events, serialize correctly | _Leverage: StateSnapshot, FFI patterns | Success: FFI provides state snapshots, emits changes | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 17. Remove legacy state structs\n  - Files: Delete or deprecate old state files\n  - Update imports throughout codebase\n  - Verify no dead code\n  - Purpose: Cleanup\n  - _Leverage: New state module_\n  - _Requirements: Non-functional (cleanup)_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer completing cleanup | Task: Remove legacy state structs, update imports | Restrictions: No dead code, clean imports, all tests pass | _Leverage: New state module | Success: Old structs removed, codebase cleaner | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n\n- [ ] 18. Add state invariant tests\n  - File: `core/tests/unit/engine/state_invariants_test.rs`\n  - Property tests for state consistency\n  - Fuzz mutation sequences\n  - Purpose: Verify invariants\n  - _Leverage: proptest_\n  - _Requirements: Non-functional (reliability)_\n  - _Prompt: Implement the task for spec engine-state-unification, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Test Developer | Task: Create property tests for state invariants | Restrictions: Use proptest, fuzz mutations, verify consistency | _Leverage: proptest | Success: Property tests pass, invariants verified | After completion: Mark task [-] as in-progress before starting, use log-implementation tool to record artifacts, then mark [x] when complete_\n",
  "fileStats": {
    "size": 15296,
    "lines": 184,
    "lastModified": "2025-12-03T13:05:54.263Z"
  },
  "comments": []
}