{
  "id": "snapshot_1764768200834_grsdcj3y1",
  "approvalId": "approval_1764767193294_01xqpyode",
  "approvalTitle": "Engine State Unification - Requirements",
  "version": 2,
  "timestamp": "2025-12-03T13:23:20.834Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe engine module (6,001 LOC across 21 files) has state distributed across multiple structs: `KeyStateTracker`, `LayerStack`, `ModifierState`, `PendingDecisionQueue`, and more. This distributed state makes reasoning about consistency difficult and causes subtle timing bugs. This spec unifies engine state under a single facade with explicit mutation boundaries.\n\n## Alignment with Product Vision\n\nThis feature supports KeyRx's product principles:\n- **Performance > Features**: Unified state enables atomic updates and reduces lock contention\n- **Visual > Abstract**: State visible through single inspection point\n- **Safety First**: Consistent state prevents undefined behavior\n\nPer tech.md: \"No Global State: All instances are self-contained structs\" and \"Event Sourcing: Input treated as immutable event stream\"\n\n## Requirements\n\n### Requirement 1: Unified State Container\n\n**User Story:** As a developer, I want all engine state in a single container, so that I can reason about state consistency.\n\n#### Acceptance Criteria\n\n1. WHEN inspecting engine state THEN a single `EngineState` struct SHALL contain all state\n2. IF state is accessed THEN it SHALL be through typed accessors on EngineState\n3. WHEN state is modified THEN it SHALL go through mutation methods\n4. IF state snapshots are needed THEN EngineState SHALL be Clone-able\n\n### Requirement 2: Explicit Mutation Boundaries\n\n**User Story:** As a developer, I want clear mutation boundaries, so that I know exactly when and how state changes.\n\n#### Acceptance Criteria\n\n1. WHEN an event is processed THEN mutations SHALL happen in a single `apply()` call\n2. IF multiple state changes are needed THEN they SHALL be batched atomically\n3. WHEN mutations occur THEN a `StateChange` record SHALL be emitted\n4. IF a mutation fails THEN state SHALL remain unchanged (rollback)\n\n### Requirement 3: State Synchronization\n\n**User Story:** As a developer, I want state components synchronized, so that modifiers, layers, and pending decisions are consistent.\n\n#### Acceptance Criteria\n\n1. WHEN a key is released THEN all dependent state (modifiers, pending) SHALL update\n2. IF a layer is popped THEN affected modifiers SHALL be deactivated\n3. WHEN state is queried THEN it SHALL reflect all prior mutations\n4. IF timing decisions resolve THEN dependent state SHALL update immediately\n\n### Requirement 4: State Inspection API\n\n**User Story:** As a Flutter developer, I want to inspect engine state, so that I can display it in the debugger UI.\n\n#### Acceptance Criteria\n\n1. WHEN state is requested THEN a serializable snapshot SHALL be provided\n2. IF specific state is needed THEN focused queries SHALL be available\n3. WHEN state history is needed THEN recent changes SHALL be accessible\n4. IF real-time updates are needed THEN state change events SHALL be emitted\n\n### Requirement 5: State Persistence\n\n**User Story:** As a user, I want engine state to persist across sessions, so that I don't lose layer/modifier state on restart.\n\n#### Acceptance Criteria\n\n1. WHEN engine stops THEN state SHALL be serializable to disk\n2. IF engine starts THEN previous state SHALL be restorable\n3. WHEN state format changes THEN migration SHALL be supported\n4. IF state is corrupted THEN engine SHALL start with clean state\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: EngineState manages state, engine manages logic\n- **Modular Design**: State components are internal modules\n- **Dependency Management**: State doesn't depend on engine logic\n- **Clear Interfaces**: Public API for state access, internal for mutation\n\n### Performance\n- State access SHALL be O(1) for common operations\n- State cloning SHALL be efficient (< 1ms for typical state)\n- Lock contention SHALL be minimized (consider RwLock)\n\n### Security\n- State SHALL not contain sensitive information (no file paths)\n- State exports SHALL be sanitized for sharing\n\n### Reliability\n- State invariants SHALL be validated after each mutation\n- Invalid state transitions SHALL panic in debug, log in release\n- State corruption SHALL be detectable\n\n### Usability\n- State inspection SHALL be available in one method call\n- State debugging SHALL be supported via Debug impl\n- State documentation SHALL explain all components\n",
  "fileStats": {
    "size": 4324,
    "lines": 99,
    "lastModified": "2025-12-03T13:05:53.442Z"
  },
  "comments": []
}