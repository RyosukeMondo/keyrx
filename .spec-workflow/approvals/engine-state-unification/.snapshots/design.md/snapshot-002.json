{
  "id": "snapshot_1764768201161_8bd2gtwev",
  "approvalId": "approval_1764767193630_0lpw5vatl",
  "approvalTitle": "Engine State Unification - Design",
  "version": 2,
  "timestamp": "2025-12-03T13:23:21.161Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design unifies the distributed engine state into a single `EngineState` struct that owns all state components. The core innovation is the `apply_mutation()` method that batches state changes atomically and emits change events. State components become internal modules that EngineState coordinates.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **No Global State**: EngineState is an instance, not global\n- **Event Sourcing**: Mutations produce StateChange events\n- **Dependency Injection**: State is injectable for testing\n\n### Project Structure (structure.md)\n- State in `core/src/engine/state/`\n- Components: `keys.rs`, `layers.rs`, `modifiers.rs`, `pending.rs`\n- Public API in `core/src/engine/state/mod.rs`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`KeyStateTracker`**: Refactor into state component\n- **`LayerStack`**: Refactor into state component\n- **`ModifierState`**: Refactor into state component\n- **`PendingDecisionQueue`**: Refactor into state component\n\n### Integration Points\n- **Engine core**: Uses EngineState instead of separate structs\n- **FFI exports**: Queries EngineState for snapshots\n- **Flutter debugger**: Displays EngineState\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Engine\"\n        ENG[Engine] --> ES[EngineState]\n        ENG --> PROC[Processor]\n    end\n\n    subgraph \"EngineState\"\n        ES --> KS[KeyState]\n        ES --> LS[LayerState]\n        ES --> MS[ModifierState]\n        ES --> PS[PendingState]\n        ES --> TS[TimingState]\n    end\n\n    subgraph \"Mutations\"\n        MUT[Mutation] --> ES\n        ES --> CHG[StateChange]\n    end\n\n    subgraph \"Queries\"\n        ES --> SNAP[Snapshot]\n        ES --> HIST[History]\n    end\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each state component has one file\n- **Component Isolation**: Components don't reference each other\n- **Unified Coordination**: EngineState coordinates components\n- **Clear Boundaries**: Mutations go through EngineState\n\n## Components and Interfaces\n\n### Component 1: EngineState\n\n- **Purpose:** Unified container for all engine state\n- **Interfaces:**\n  ```rust\n  #[derive(Clone)]\n  pub struct EngineState {\n      keys: KeyState,\n      layers: LayerState,\n      modifiers: ModifierState,\n      pending: PendingState,\n      timing: TimingState,\n      version: u64,\n  }\n\n  impl EngineState {\n      pub fn new() -> Self;\n\n      // === Queries ===\n      pub fn is_key_pressed(&self, key: KeyCode) -> bool;\n      pub fn active_layers(&self) -> &[LayerId];\n      pub fn active_modifiers(&self) -> ModifierSet;\n      pub fn pending_decisions(&self) -> &[PendingDecision];\n      pub fn version(&self) -> u64;\n\n      // === Mutations ===\n      pub fn apply(&mut self, mutation: Mutation) -> Result<StateChange, StateError>;\n      pub fn apply_batch(&mut self, mutations: Vec<Mutation>) -> Result<Vec<StateChange>, StateError>;\n\n      // === Snapshots ===\n      pub fn snapshot(&self) -> StateSnapshot;\n      pub fn diff(&self, other: &Self) -> StateDiff;\n  }\n  ```\n- **Dependencies:** State components\n- **Reuses:** Existing state logic\n\n### Component 2: Mutation Enum\n\n- **Purpose:** Explicit state change operations\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, Clone)]\n  pub enum Mutation {\n      // Key state\n      KeyDown { key: KeyCode, timestamp: u64 },\n      KeyUp { key: KeyCode, timestamp: u64 },\n\n      // Layer state\n      PushLayer { layer: LayerId },\n      PopLayer { layer: LayerId },\n      SetActiveLayer { layer: LayerId },\n\n      // Modifier state\n      ActivateModifier { modifier: ModifierId },\n      DeactivateModifier { modifier: ModifierId },\n      SetModifiers { modifiers: ModifierSet },\n\n      // Pending decisions\n      AddPending { decision: PendingDecision },\n      ResolvePending { id: PendingId, resolution: Resolution },\n      ClearPending { id: PendingId },\n\n      // Timing\n      AdvanceTime { microseconds: u64 },\n  }\n  ```\n- **Dependencies:** Core types\n- **Reuses:** Existing operation concepts\n\n### Component 3: StateChange\n\n- **Purpose:** Record of what changed for event emission\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, Clone, Serialize)]\n  pub struct StateChange {\n      pub version: u64,\n      pub mutation: Mutation,\n      pub effects: Vec<Effect>,\n      pub timestamp: u64,\n  }\n\n  #[derive(Debug, Clone, Serialize)]\n  pub enum Effect {\n      KeyStateChanged { key: KeyCode, pressed: bool },\n      LayerActivated { layer: LayerId },\n      LayerDeactivated { layer: LayerId },\n      ModifierActivated { modifier: ModifierId },\n      ModifierDeactivated { modifier: ModifierId },\n      DecisionResolved { id: PendingId, resolution: Resolution },\n  }\n  ```\n- **Dependencies:** Mutation type\n- **Reuses:** Event pattern\n\n### Component 4: KeyState Component\n\n- **Purpose:** Track which keys are currently pressed\n- **Interfaces:**\n  ```rust\n  #[derive(Clone, Default)]\n  pub(crate) struct KeyState {\n      pressed: HashSet<KeyCode>,\n      timestamps: HashMap<KeyCode, u64>,\n  }\n\n  impl KeyState {\n      pub fn is_pressed(&self, key: KeyCode) -> bool;\n      pub fn press(&mut self, key: KeyCode, timestamp: u64);\n      pub fn release(&mut self, key: KeyCode) -> Option<u64>;\n      pub fn pressed_keys(&self) -> impl Iterator<Item = KeyCode>;\n      pub fn hold_duration(&self, key: KeyCode, now: u64) -> Option<u64>;\n  }\n  ```\n- **Dependencies:** KeyCode\n- **Reuses:** Logic from KeyStateTracker\n\n### Component 5: StateSnapshot\n\n- **Purpose:** Serializable state for FFI and persistence\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, Clone, Serialize, Deserialize)]\n  pub struct StateSnapshot {\n      pub pressed_keys: Vec<KeyCode>,\n      pub active_layers: Vec<LayerId>,\n      pub active_modifiers: Vec<ModifierId>,\n      pub pending_count: usize,\n      pub version: u64,\n      pub timestamp: u64,\n  }\n\n  impl From<&EngineState> for StateSnapshot {\n      fn from(state: &EngineState) -> Self { ... }\n  }\n  ```\n- **Dependencies:** serde\n- **Reuses:** Serialization patterns\n\n## Data Models\n\n### PendingDecision\n```rust\n#[derive(Debug, Clone)]\npub struct PendingDecision {\n    pub id: PendingId,\n    pub decision_type: DecisionType,\n    pub keys: Vec<KeyCode>,\n    pub started_at: u64,\n    pub timeout: u64,\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum DecisionType {\n    TapOrHold,\n    Combo,\n    Sequence,\n}\n```\n\n### StateDiff\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct StateDiff {\n    pub from_version: u64,\n    pub to_version: u64,\n    pub changes: Vec<StateChange>,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid mutation (release unpressed key)**\n   - **Handling:** Return `StateError::InvalidMutation`\n   - **User Impact:** Bug caught early\n\n2. **State invariant violation**\n   - **Handling:** Debug: panic; Release: log and recover\n   - **User Impact:** State remains consistent\n\n3. **Batch mutation partial failure**\n   - **Handling:** Rollback all changes\n   - **User Impact:** Atomic semantics preserved\n\n## Testing Strategy\n\n### Unit Testing\n- Test each state component in isolation\n- Verify mutation effects\n- Test invariant validation\n\n### Integration Testing\n- Test full mutation sequences\n- Verify state synchronization\n- Test rollback behavior\n\n### Property Testing\n- Fuzz mutation sequences\n- Verify state consistency after random operations\n- Test snapshot/restore round-trips\n",
  "fileStats": {
    "size": 7369,
    "lines": 271,
    "lastModified": "2025-12-03T13:05:53.838Z"
  },
  "comments": []
}