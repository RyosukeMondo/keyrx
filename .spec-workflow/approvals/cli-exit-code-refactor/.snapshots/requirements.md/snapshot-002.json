{
  "id": "snapshot_1764768192690_a8gypc3mf",
  "approvalId": "approval_1764767190180_a7kze6t1o",
  "approvalTitle": "CLI Exit Code Refactor - Requirements",
  "version": 2,
  "timestamp": "2025-12-03T13:23:12.690Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe CLI entry point (`core/src/bin/keyrx.rs`, 681 LOC) has critical issues with exit code handling. The current implementation uses brittle string matching to extract exit codes from error messages, and there's a compiler error where `ExitCode::from(i32)` is used but only `from(u8)` is implemented. This spec addresses the complete refactoring of CLI command dispatch and exit code propagation.\n\n## Alignment with Product Vision\n\nThis feature supports KeyRx's product principles:\n- **CLI First, GUI Later**: CLI is the foundation; it must be rock-solid\n- **Testable Configs**: Proper exit codes enable CI/CD integration and scripted testing\n- **Performance > Features**: Clean command dispatch reduces overhead\n\nPer tech.md: All features must be CLI-exercisable with semantic exit codes (0=success, 1=error, 2=assertion fail, 3=timeout).\n\n## Requirements\n\n### Requirement 1: Structured Exit Code System\n\n**User Story:** As a CLI user, I want consistent exit codes across all commands, so that I can reliably script KeyRx operations in CI/CD pipelines.\n\n#### Acceptance Criteria\n\n1. WHEN any command succeeds THEN the CLI SHALL return exit code 0\n2. IF a command fails with a general error THEN the CLI SHALL return exit code 1\n3. WHEN a test assertion fails THEN the CLI SHALL return exit code 2\n4. IF a command times out THEN the CLI SHALL return exit code 3\n5. WHEN validation fails THEN the CLI SHALL return exit code 4\n\n### Requirement 2: Type-Safe Exit Code Propagation\n\n**User Story:** As a developer, I want exit codes propagated through the type system, so that I can't accidentally lose exit code information.\n\n#### Acceptance Criteria\n\n1. WHEN a command returns THEN it SHALL use `CommandResult<T>` type that carries exit code\n2. IF an error occurs THEN the error type SHALL include the intended exit code\n3. WHEN errors are chained THEN the original exit code SHALL be preserved\n4. IF multiple errors occur THEN the most severe exit code SHALL be used\n\n### Requirement 3: Command Struct Extraction\n\n**User Story:** As a maintainer, I want command definitions separate from the entry point, so that adding new commands doesn't bloat keyrx.rs.\n\n#### Acceptance Criteria\n\n1. WHEN a command is defined THEN its struct SHALL live in `cli/commands/{name}.rs`\n2. IF the entry point file exceeds 200 LOC THEN it SHALL only contain dispatch logic\n3. WHEN adding a new command THEN no changes to keyrx.rs SHALL be required\n4. IF a command has subcommands THEN they SHALL be organized in a subdirectory\n\n### Requirement 4: Error Context Preservation\n\n**User Story:** As a user, I want error messages to include context, so that I can understand what failed and why.\n\n#### Acceptance Criteria\n\n1. WHEN an error occurs THEN the message SHALL include the command that failed\n2. IF a file operation fails THEN the path SHALL be included in the error\n3. WHEN a validation error occurs THEN line/column information SHALL be included\n4. IF the error is recoverable THEN a suggested action SHALL be provided\n\n### Requirement 5: Exit Code Documentation\n\n**User Story:** As a script author, I want documented exit codes, so that I can handle all possible outcomes.\n\n#### Acceptance Criteria\n\n1. WHEN `keyrx --help` is run THEN exit codes SHALL be listed\n2. IF `keyrx exit-codes` is run THEN a detailed exit code table SHALL be shown\n3. WHEN a command fails THEN the exit code meaning SHALL be logged at debug level\n4. IF exit codes change THEN the CHANGELOG SHALL document the change\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: Entry point only dispatches; commands implement logic\n- **Modular Design**: Each command is a self-contained module\n- **Dependency Management**: Commands don't import each other\n- **Clear Interfaces**: `CommandResult<T>` is the universal return type\n\n### Performance\n- Command dispatch overhead SHALL be < 1ms\n- Exit code determination SHALL not require string parsing\n\n### Security\n- Exit codes SHALL not leak sensitive information\n- Error messages SHALL sanitize file paths if needed\n\n### Reliability\n- All exit paths SHALL have defined exit codes\n- Panic handler SHALL return exit code 101 (Rust convention)\n\n### Usability\n- Adding a new command SHALL require < 50 LOC boilerplate\n- Exit codes SHALL follow Unix conventions where applicable\n",
  "fileStats": {
    "size": 4370,
    "lines": 97,
    "lastModified": "2025-12-03T12:59:41.427Z"
  },
  "comments": []
}