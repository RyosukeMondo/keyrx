{
  "id": "snapshot_1764767192619_cq2l1wtmd",
  "approvalId": "approval_1764767192598_am7b6osxh",
  "approvalTitle": "Test Organization - Design",
  "version": 1,
  "timestamp": "2025-12-03T13:06:32.619Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design establishes a hierarchical test organization that splits monolithic test files into focused modules, extracts inline tests to dedicated test files, and creates shared fixtures for common setup patterns. The resulting structure supports parallel execution and fast test discovery.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Max 500 lines/file**: Applied to test files\n- **80% test coverage**: Maintained through reorganization\n- **Testing Framework**: cargo test, proptest, criterion\n\n### Project Structure (structure.md)\n- Tests in `core/tests/` organized by category\n- Shared fixtures in `core/tests/fixtures/`\n- Integration tests separated from unit tests\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **proptest**: Property-based testing already in use\n- **serial_test**: For tests that can't run in parallel\n- **Existing test helpers**: Scattered but reusable\n\n### Integration Points\n- **CI pipeline**: Must support new test organization\n- **Coverage tools**: llvm-cov integration\n- **IDE**: Test discovery and navigation\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Test Organization\"\n        ROOT[core/tests/] --> UNIT[unit/]\n        ROOT --> INT[integration/]\n        ROOT --> E2E[e2e/]\n        ROOT --> FIX[fixtures/]\n    end\n\n    subgraph \"Unit Tests\"\n        UNIT --> U_ENG[engine/]\n        UNIT --> U_VAL[validation/]\n        UNIT --> U_SCR[scripting/]\n        UNIT --> U_DRV[drivers/]\n    end\n\n    subgraph \"Integration Tests\"\n        INT --> I_CLI[cli/]\n        INT --> I_FFI[ffi/]\n        INT --> I_FLO[flows/]\n    end\n\n    subgraph \"Fixtures\"\n        FIX --> F_OPS[operations.rs]\n        FIX --> F_SCR[scripts.rs]\n        FIX --> F_DEV[devices.rs]\n    end\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each test file tests one concern\n- **Component Isolation**: Tests don't share mutable state\n- **Fixture Modularity**: Fixtures are composable\n- **Clear Naming**: `test_<module>_<scenario>.rs`\n\n## Components and Interfaces\n\n### Component 1: Test Directory Structure\n\n- **Purpose:** Organize tests by type and domain\n- **Structure:**\n  ```\n  core/tests/\n  ├── fixtures/           # Shared test utilities\n  │   ├── mod.rs\n  │   ├── operations.rs   # PendingOp builders\n  │   ├── scripts.rs      # Rhai script fixtures\n  │   ├── devices.rs      # Mock device fixtures\n  │   └── engine.rs       # Engine test helpers\n  ├── unit/               # Fast, isolated tests\n  │   ├── mod.rs\n  │   ├── engine/\n  │   │   ├── mod.rs\n  │   │   ├── decision_tests.rs\n  │   │   ├── layer_tests.rs\n  │   │   └── modifier_tests.rs\n  │   ├── validation/\n  │   │   ├── mod.rs\n  │   │   ├── conflict_tests.rs\n  │   │   ├── cycle_tests.rs\n  │   │   └── safety_tests.rs\n  │   └── scripting/\n  │       ├── mod.rs\n  │       ├── binding_tests.rs\n  │       └── runtime_tests.rs\n  ├── integration/        # Cross-module tests\n  │   ├── mod.rs\n  │   ├── cli/\n  │   │   ├── check_tests.rs\n  │   │   ├── run_tests.rs\n  │   │   └── simulate_tests.rs\n  │   ├── ffi/\n  │   │   ├── discovery_tests.rs\n  │   │   └── engine_tests.rs\n  │   └── flows/\n  │       ├── remap_flow_tests.rs\n  │       └── combo_flow_tests.rs\n  └── e2e/                # Full system tests\n      ├── mod.rs\n      └── scenario_tests.rs\n  ```\n- **Dependencies:** None (directory structure)\n- **Reuses:** Existing test patterns\n\n### Component 2: Test Fixtures Module\n\n- **Purpose:** Shared builders and helpers for test setup\n- **Interfaces:**\n  ```rust\n  // fixtures/operations.rs\n  pub struct OperationBuilder {\n      ops: Vec<PendingOp>,\n  }\n\n  impl OperationBuilder {\n      pub fn new() -> Self;\n      pub fn remap(self, from: KeyCode, to: KeyCode) -> Self;\n      pub fn block(self, key: KeyCode) -> Self;\n      pub fn combo(self, keys: &[KeyCode], output: KeyCode) -> Self;\n      pub fn build(self) -> Vec<PendingOp>;\n  }\n\n  // fixtures/scripts.rs\n  pub fn minimal_script() -> &'static str;\n  pub fn complex_layer_script() -> &'static str;\n  pub fn script_with_errors() -> &'static str;\n\n  // fixtures/engine.rs\n  pub struct TestEngine {\n      engine: Engine<MockInput, MockScript, MockState>,\n  }\n\n  impl TestEngine {\n      pub fn new() -> Self;\n      pub fn with_script(script: &str) -> Self;\n      pub fn process(&mut self, event: InputEvent) -> Vec<OutputAction>;\n  }\n  ```\n- **Dependencies:** Core types\n- **Reuses:** Builder pattern\n\n### Component 3: Test Categories\n\n- **Purpose:** Organize tests by execution characteristics\n- **Interfaces:**\n  ```rust\n  // Unit tests: fast, isolated, no I/O\n  #[cfg(test)]\n  mod tests {\n      #[test]\n      fn test_specific_behavior() { ... }\n  }\n\n  // Integration tests: cross-module, may have I/O\n  // In tests/integration/\n  #[test]\n  fn test_cli_check_with_valid_script() { ... }\n\n  // E2E tests: full system, may need devices\n  // In tests/e2e/\n  #[test]\n  #[ignore = \"requires real keyboard\"]\n  fn test_full_remap_flow() { ... }\n  ```\n- **Dependencies:** Test framework\n- **Reuses:** Standard Rust test patterns\n\n### Component 4: Validation Test Split\n\n- **Purpose:** Break 27K LOC validation_integration.rs into focused files\n- **Target Files:**\n  ```\n  tests/integration/validation/\n  ├── mod.rs\n  ├── conflict_integration_tests.rs    (~500 LOC)\n  ├── cycle_integration_tests.rs       (~400 LOC)\n  ├── shadowing_integration_tests.rs   (~400 LOC)\n  ├── safety_integration_tests.rs      (~500 LOC)\n  ├── coverage_integration_tests.rs    (~400 LOC)\n  └── edge_case_tests.rs               (~300 LOC)\n  ```\n- **Dependencies:** Validation module\n- **Reuses:** Existing test logic\n\n### Component 5: Phase Test Split\n\n- **Purpose:** Break 21K LOC phase_1_3_integration_test.rs into features\n- **Target Files:**\n  ```\n  tests/integration/phases/\n  ├── mod.rs\n  ├── phase1_basic_remap_tests.rs      (~600 LOC)\n  ├── phase1_block_tests.rs            (~400 LOC)\n  ├── phase2_layer_tests.rs            (~700 LOC)\n  ├── phase2_modifier_tests.rs         (~600 LOC)\n  ├── phase3_combo_tests.rs            (~700 LOC)\n  ├── phase3_timing_tests.rs           (~500 LOC)\n  └── regression_tests.rs              (~400 LOC)\n  ```\n- **Dependencies:** Engine module\n- **Reuses:** Existing test logic\n\n## Data Models\n\n### TestResult\n```rust\npub struct TestResult {\n    pub name: String,\n    pub passed: bool,\n    pub duration: Duration,\n    pub message: Option<String>,\n}\n```\n\n### TestCategory\n```rust\npub enum TestCategory {\n    Unit,\n    Integration,\n    E2E,\n    Property,\n    Benchmark,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Test fixture creation fails**\n   - **Handling:** Panic with clear message about missing dependencies\n   - **User Impact:** Developer knows what's missing\n\n2. **Parallel test conflict**\n   - **Handling:** Use `#[serial]` attribute\n   - **User Impact:** Tests run correctly but sequentially\n\n3. **Missing test file after split**\n   - **Handling:** CI catches with coverage check\n   - **User Impact:** PR blocked until fixed\n\n## Testing Strategy\n\n### Unit Testing\n- Test fixtures themselves have tests\n- Verify builder patterns work correctly\n\n### Integration Testing\n- Run reorganized tests to verify no breakage\n- Compare coverage before/after\n\n### CI Integration\n- Update CI to run test categories appropriately\n- Add coverage thresholds per category\n",
  "fileStats": {
    "size": 7690,
    "lines": 267,
    "lastModified": "2025-12-03T13:05:52.660Z"
  },
  "comments": []
}