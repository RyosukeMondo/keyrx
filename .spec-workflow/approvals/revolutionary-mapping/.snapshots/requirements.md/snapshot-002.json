{
  "id": "snapshot_1764951858864_zj7z0dggu",
  "approvalId": "approval_1764951762318_5pl1jsef3",
  "approvalTitle": "Revolutionary Mapping - Requirements Document",
  "version": 2,
  "timestamp": "2025-12-05T16:24:18.864Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document - Revolutionary Mapping\n\n## Introduction\n\nThe Revolutionary Mapping feature transforms KeyRx from a simple key remapper into a professional-grade Input Management System by decoupling physical devices from logical profiles. This paradigm shift solves the fundamental scalability problem of managing multiple identical devices (e.g., two Stream Decks with different purposes) and enables instant, purpose-specific configuration swapping.\n\n**Purpose:** Enable users to:\n- Uniquely identify and manage multiple identical input devices independently\n- Create portable, hardware-independent profiles that can be assigned to any compatible device\n- Toggle remapping per device without affecting other devices\n- Swap device behavior instantly by changing profiles\n- Support custom device layouts beyond standard keyboards (5×5 macro pads, split keyboards, Stream Decks)\n\n**Value:** This feature positions KeyRx as the only input management tool that treats devices as individuals and profiles as portable configurations, solving pain points that competitors cannot address.\n\n## Alignment with Product Vision\n\nThis feature directly supports KeyRx's product vision:\n\n**\"Logic > Configuration\"**: Profiles remain scriptable via Rhai while adding device-profile decoupling for true flexibility.\n\n**\"True Blank Canvas\"**: Extends the existing row-col physical abstraction to support any device layout, not just keyboards.\n\n**\"Progressive Complexity\"**: Simple users can use pre-made profiles; power users can create complex, portable configurations.\n\n**\"CLI First, GUI Later\"**: All device and profile management operations will be CLI-accessible before UI implementation.\n\n**New Product Capability**: Transforms KeyRx from a \"keyboard remapper\" into an \"input management system\" - a category upgrade that differentiates us from all competitors.\n\n## Requirements\n\n### Requirement 1: Unique Device Identity\n\n**User Story:** As a power user with two identical Stream Decks, I want each device to be uniquely identified by its serial number, so that I can configure them independently without conflicts.\n\n#### Acceptance Criteria\n\n1. WHEN a device connects to the system THEN KeyRx SHALL extract a unique identifier comprising (vendor_id, product_id, serial_number)\n2. IF a device has a hardware serial number (USB iSerial descriptor) THEN KeyRx SHALL use it as the unique identifier\n3. IF a device lacks a hardware serial number THEN KeyRx SHALL generate a stable synthetic identifier based on USB port topology and VID:PID hash\n4. WHEN two devices with identical VID:PID but different serials connect THEN KeyRx SHALL track them as separate entities in the device registry\n5. WHEN a user assigns a custom label to a device THEN KeyRx SHALL persist this label across sessions and associate it with the device identity\n\n---\n\n### Requirement 2: Device Registry (Runtime State Management)\n\n**User Story:** As a user managing multiple devices, I want to see all connected devices with their current state, so that I can understand which devices are active and what profiles they're using.\n\n#### Acceptance Criteria\n\n1. WHEN a device connects THEN KeyRx SHALL register it in the device registry with initial state (identity, connected_at timestamp, state: Passthrough)\n2. WHEN a device disconnects THEN KeyRx SHALL remove it from the active device registry\n3. WHEN querying device state THEN KeyRx SHALL return: device identity, is_remapping_enabled flag, active_profile_id (if assigned), runtime state (Active/Passthrough/Failed)\n4. WHEN a device state changes (remap toggle, profile assignment) THEN KeyRx SHALL emit a DeviceEvent for UI synchronization\n5. IF no devices are connected THEN the device registry SHALL return an empty list without errors\n\n---\n\n### Requirement 3: Profile Registry (Persistent Configuration Storage)\n\n**User Story:** As a user, I want to create and manage profiles independently of any connected device, so that I can design configurations before the hardware arrives or swap profiles between devices.\n\n#### Acceptance Criteria\n\n1. WHEN creating a profile THEN KeyRx SHALL store: profile_id (UUID), name, layout_type (Matrix/Standard/Split), mappings (row,col → KeyAction), created_at, modified_at timestamps\n2. WHEN saving a profile THEN KeyRx SHALL persist it to `$XDG_CONFIG_HOME/keyrx/profiles/{profile_id}.json` using atomic write (temp file + rename)\n3. WHEN loading profiles on startup THEN KeyRx SHALL read all `.json` files from the profiles directory and build an in-memory registry\n4. WHEN deleting a profile THEN KeyRx SHALL remove it from the filesystem and emit a ProfileDeleted event\n5. WHEN searching for compatible profiles for a device THEN KeyRx SHALL return only profiles whose layout_type matches the device's layout definition\n6. IF a profile file is corrupted THEN KeyRx SHALL log an error, skip that profile, and continue loading other profiles\n7. WHEN updating a profile THEN KeyRx SHALL update the modified_at timestamp automatically\n\n---\n\n### Requirement 4: Per-Device Remap Control\n\n**User Story:** As a user with 5 input devices, I want to enable/disable remapping for each device individually, so that I can temporarily use a device in passthrough mode without affecting others.\n\n#### Acceptance Criteria\n\n1. WHEN a device is registered THEN it SHALL default to is_remapping_enabled = false (safe default, requires user opt-in)\n2. WHEN a user toggles remapping for a device THEN KeyRx SHALL update the is_remapping_enabled flag and change runtime state (Active ↔ Passthrough)\n3. IF is_remapping_enabled is false THEN input from that device SHALL pass through without any processing (bypass all profile mappings)\n4. IF is_remapping_enabled is true AND active_profile_id is set THEN input SHALL be processed through the assigned profile\n5. IF is_remapping_enabled is true BUT active_profile_id is null THEN the device SHALL remain in Passthrough state\n6. WHEN toggling remap state THEN the change SHALL take effect immediately (< 100ms) without requiring restart\n\n---\n\n### Requirement 5: Profile-to-Device Assignment\n\n**User Story:** As a content creator, I want to assign my \"OBS Controls\" profile to one Stream Deck and my \"Photoshop Shortcuts\" profile to another identical Stream Deck, so that each device serves a different purpose.\n\n#### Acceptance Criteria\n\n1. WHEN a user assigns a profile to a device THEN KeyRx SHALL validate layout compatibility (device layout matches profile layout_type)\n2. IF layouts are incompatible THEN KeyRx SHALL return an error with details (e.g., \"Device has 3×5 layout but profile requires 5×5\")\n3. WHEN a profile is assigned THEN KeyRx SHALL update device_state.active_profile_id and persist the binding to `device_bindings.json`\n4. WHEN a device reconnects THEN KeyRx SHALL automatically reload the previously assigned profile from device_bindings.json\n5. WHEN unassigning a profile THEN KeyRx SHALL set active_profile_id to null and set device to Passthrough state\n6. IF a referenced profile is deleted THEN devices using it SHALL transition to Passthrough state and log a warning\n\n---\n\n### Requirement 6: Device-Profile Bindings Persistence\n\n**User Story:** As a user, I want my profile assignments and device labels to persist across application restarts, so that I don't have to reconfigure my devices every time I restart KeyRx.\n\n#### Acceptance Criteria\n\n1. WHEN a profile is assigned to a device THEN KeyRx SHALL write the binding to `.spec-workflow/keyrx/device_bindings.json` using atomic write\n2. WHEN KeyRx starts THEN it SHALL load device_bindings.json and apply bindings to any connected devices\n3. IF a device in bindings file is not connected THEN KeyRx SHALL retain the binding for future connection\n4. WHEN a user sets a device label THEN it SHALL be stored in device_bindings.json under the device identity\n5. IF device_bindings.json is missing THEN KeyRx SHALL create it with an empty bindings array\n6. IF device_bindings.json is corrupted THEN KeyRx SHALL create a backup and start with empty bindings, logging an error\n\n---\n\n### Requirement 7: Device Definition Library (Layout Awareness)\n\n**User Story:** As a macro pad owner, I want KeyRx to understand my device's 5×5 grid layout, so that the visual editor displays the correct button arrangement instead of a generic keyboard.\n\n#### Acceptance Criteria\n\n1. WHEN KeyRx starts THEN it SHALL load all device definitions from `device_definitions/**/*.toml` recursively\n2. WHEN a device connects THEN KeyRx SHALL look up its definition using (vendor_id, product_id) as the key\n3. IF a device definition exists THEN KeyRx SHALL use it to translate scancodes to (row, col) positions\n4. IF no device definition exists THEN KeyRx SHALL fall back to a generic ANSI keyboard layout\n5. WHEN a device definition defines a matrix_map THEN it SHALL map each scancode/HID usage ID to a (row, col) tuple\n6. IF a scancode is not in the matrix_map THEN KeyRx SHALL log a warning and ignore that key press\n7. WHEN loading device definitions THEN KeyRx SHALL validate: vendor_id/product_id are non-zero, rows/cols are non-zero, matrix_map contains valid positions\n\n---\n\n### Requirement 8: Serial Number Extraction (Windows)\n\n**User Story:** As a Windows user with two identical keyboards, I want KeyRx to distinguish them using their serial numbers, so that I can assign different profiles to each.\n\n#### Acceptance Criteria\n\n1. WHEN a device connects on Windows THEN KeyRx SHALL extract the device path from Raw Input API (format: `\\\\?\\HID#VID_vvvv&PID_pppp&MI_ii#<InstanceID>#{ClassGUID}`)\n2. WHEN parsing the device path THEN KeyRx SHALL extract the InstanceID segment (between second and third `#` delimiters)\n3. IF HidD_GetSerialNumberString succeeds THEN KeyRx SHALL use the returned serial number string\n4. IF HidD_GetSerialNumberString fails THEN KeyRx SHALL use the InstanceID as the serial (which may be port-based)\n5. IF the InstanceID is port-based (e.g., `7&3a2b4c5&0&0000`) THEN KeyRx SHALL warn the user that the device configuration is port-dependent\n6. WHEN a port-bound device is moved to a different USB port THEN KeyRx SHALL treat it as a new device (separate entry in device registry)\n\n---\n\n### Requirement 9: Serial Number Extraction (Linux)\n\n**User Story:** As a Linux user, I want KeyRx to extract unique device identifiers using the evdev interface, so that I can manage multiple identical devices independently.\n\n#### Acceptance Criteria\n\n1. WHEN a device connects on Linux THEN KeyRx SHALL open the evdev device file (`/dev/input/eventX`)\n2. WHEN querying for unique identifier THEN KeyRx SHALL use the EVIOCGUNIQ ioctl (`device.unique_name()`)\n3. IF EVIOCGUNIQ returns a non-empty string THEN KeyRx SHALL use it as the serial number\n4. IF EVIOCGUNIQ returns empty THEN KeyRx SHALL read udev properties (`ID_SERIAL` or `ID_SERIAL_SHORT` from `/sys/class/input/eventX/device/`)\n5. IF udev properties are unavailable THEN KeyRx SHALL generate a synthetic serial using: `synthetic_{vid:04x}{pid:04x}_{phys_path_hash:016x}`\n6. WHEN generating a synthetic serial THEN KeyRx SHALL hash the `phys` path (USB port topology) to create a stable identifier\n7. IF a synthetic serial is used THEN KeyRx SHALL warn the user that the device configuration is port-dependent\n\n---\n\n### Requirement 10: Input Processing Pipeline Integration\n\n**User Story:** As a power user, I want sub-millisecond latency when using profiles, so that KeyRx feels invisible during use.\n\n#### Acceptance Criteria\n\n1. WHEN an input event arrives THEN KeyRx SHALL resolve the device identity from the OS handle in < 50μs (p99)\n2. WHEN device identity is resolved THEN KeyRx SHALL load the device state from the registry in < 10μs (cached lookup)\n3. IF is_remapping_enabled is false THEN KeyRx SHALL bypass all processing and output the event as-is (< 10μs passthrough latency)\n4. IF is_remapping_enabled is true THEN KeyRx SHALL load the assigned profile from cache in < 100μs (p99)\n5. WHEN translating scancodes to (row, col) THEN KeyRx SHALL use a cached translation map in < 20μs (p99)\n6. WHEN resolving (row, col) to KeyAction THEN KeyRx SHALL perform HashMap lookup in < 10μs (p99)\n7. WHEN the full pipeline completes THEN total latency SHALL be < 1ms (p99) from input event to output injection\n8. IF any pipeline stage fails THEN KeyRx SHALL fall back to passthrough mode for that event and log an error\n\n---\n\n### Requirement 11: Navigation & UX - Hardware-First Philosophy\n\n**User Story:** As a new user, I want to set up my devices before creating mappings, so that the workflow feels natural (connect hardware → configure behavior).\n\n#### Acceptance Criteria\n\n1. WHEN the user opens KeyRx UI THEN the default landing page SHALL be the Devices tab\n2. WHEN viewing the navigation sidebar THEN the Devices icon SHALL appear above the Editor icon\n3. WHEN no devices are connected THEN the Devices tab SHALL display an empty state message: \"No devices connected. Connect a device to get started.\"\n4. WHEN one or more devices are connected THEN the Devices tab SHALL display a list of DeviceCard components (one per device)\n5. WHEN a user first connects a device THEN KeyRx SHALL prompt: \"Would you like to label this device?\" with a text input field\n6. IF the user provides a label THEN it SHALL be stored and displayed instead of the generic device name\n\n---\n\n### Requirement 12: Devices Tab UI - Per-Device Controls\n\n**User Story:** As a user managing multiple devices, I want to see all my devices in one view with controls for each, so that I can quickly toggle remapping and change profiles.\n\n#### Acceptance Criteria\n\n1. WHEN viewing the Devices tab THEN each device SHALL be displayed in a DeviceCard widget showing: user label (or fallback name), VID:PID:Serial, profile selector dropdown, remap toggle switch\n2. WHEN clicking the remap toggle THEN KeyRx SHALL call the device registry API to set is_remapping_enabled and update the UI state immediately\n3. WHEN selecting a profile from the dropdown THEN KeyRx SHALL validate layout compatibility and display an error if incompatible\n4. IF profile assignment succeeds THEN the dropdown SHALL show the selected profile name\n5. WHEN clicking \"Edit Label\" THEN a dialog SHALL appear with a text field pre-filled with the current label\n6. WHEN saving a new label THEN the DeviceCard SHALL update to show the new label immediately\n7. WHEN clicking \"Manage Profiles\" THEN the UI SHALL navigate to the device-specific profiles page\n8. WHEN the remap toggle is OFF THEN the toggle SHALL display \"OFF\" in red/gray and the profile selector SHALL be disabled (grayed out)\n9. WHEN the remap toggle is ON THEN the toggle SHALL display \"ON\" in green and the profile selector SHALL be enabled\n\n---\n\n### Requirement 13: Visual Editor - Dynamic Layout Rendering\n\n**User Story:** As a Stream Deck owner, I want the visual editor to show a 3×5 grid of buttons (matching my hardware), so that I can visually map each button to actions.\n\n#### Acceptance Criteria\n\n1. WHEN opening the Visual Editor THEN a profile selector dropdown SHALL appear at the top\n2. WHEN selecting a profile THEN the editor SHALL read the profile's layout_type (Matrix, Standard, or Split)\n3. IF layout_type is Matrix{rows: 3, cols: 5} THEN the editor SHALL render a 3×5 grid of clickable buttons\n4. IF layout_type is Standard(ANSI) THEN the editor SHALL render a full ANSI 104-key keyboard layout\n5. WHEN rendering a layout THEN each physical position SHALL display its current mapping (if any)\n6. IF a position is unmapped THEN it SHALL display as an empty button with a dashed border\n7. WHEN a user clicks a physical position THEN it SHALL highlight and prompt: \"Now select an output key\"\n8. WHEN a user selects an output key from the soft keyboard palette THEN the mapping SHALL be created and the button SHALL update to show the output key label\n\n---\n\n### Requirement 14: Soft Keyboard Palette\n\n**User Story:** As a user creating mappings, I want to see all available output keys in a searchable palette, so that I can easily find and assign keys without typing keycode names.\n\n#### Acceptance Criteria\n\n1. WHEN the Visual Editor is open THEN a soft keyboard palette SHALL be displayed on the right side of the screen\n2. WHEN rendering the palette THEN it SHALL display all KeyCode enum variants as clickable buttons\n3. WHEN typing in the search box THEN the palette SHALL filter keys to show only those matching the search query (case-insensitive)\n4. WHEN clicking a key in the palette THEN it SHALL become the selected output key (highlighted)\n5. IF a physical position is already selected THEN clicking a palette key SHALL create the mapping immediately\n6. WHEN a mapping is created THEN the palette SHALL clear its selection and return to the full key list\n7. WHEN the palette is empty (no keys match search) THEN it SHALL display: \"No keys found\"\n\n---\n\n### Requirement 15: Profile Migration (Backward Compatibility)\n\n**User Story:** As an existing KeyRx user, I want my old device profiles to be automatically migrated to the new system, so that I don't lose my configurations when upgrading.\n\n#### Acceptance Criteria\n\n1. WHEN KeyRx starts with the new system for the first time THEN it SHALL detect old profiles in `~/.config/keyrx/devices/{vid}_{pid}.json` format\n2. IF old profiles exist THEN KeyRx SHALL display a migration prompt: \"Migrate old profiles to the new system?\"\n3. WHEN the user accepts migration THEN KeyRx SHALL convert each old DeviceProfile to a new Profile (UUID ID, layout_type inferred from rows/cols_per_row, mappings from keymap)\n4. WHEN migration completes THEN KeyRx SHALL create a backup of old profiles in `~/.config/keyrx/devices_backup/` before deletion\n5. IF any connected device matches the VID:PID of a migrated profile THEN KeyRx SHALL auto-assign the migrated profile to that device\n6. WHEN migration completes THEN KeyRx SHALL display a summary: \"Migrated X profiles. Y devices auto-assigned.\"\n7. IF migration fails for a profile THEN KeyRx SHALL log the error and continue with other profiles (partial migration allowed)\n\n---\n\n### Requirement 16: FFI Layer - Device Registry Exposure\n\n**User Story:** As a Flutter UI developer, I want to access device registry functions via FFI, so that I can build the Devices tab UI without duplicating logic.\n\n#### Acceptance Criteria\n\n1. WHEN calling `krx_device_registry_list_devices()` THEN it SHALL return a JSON array of DeviceState objects\n2. WHEN calling `krx_device_registry_set_remap_enabled(vid, pid, serial, enabled)` THEN it SHALL update the device state and return \"ok\" or \"error:message\"\n3. WHEN calling `krx_device_registry_assign_profile(vid, pid, serial, profile_id)` THEN it SHALL validate layout compatibility and assign the profile\n4. WHEN calling `krx_device_registry_set_user_label(vid, pid, serial, label)` THEN it SHALL update the user label and persist to device_bindings.json\n5. IF an FFI function encounters a panic THEN it SHALL catch the panic and return \"error:panic occurred\" (never crash across FFI boundary)\n6. IF an FFI function receives null pointers THEN it SHALL return \"error:null pointer\" without dereferencing\n7. WHEN FFI functions return strings THEN the caller SHALL be responsible for freeing the allocated C string memory\n\n---\n\n### Requirement 17: FFI Layer - Profile Registry Exposure\n\n**User Story:** As a UI developer, I want to manage profiles via FFI, so that I can create, list, and delete profiles from the Visual Editor.\n\n#### Acceptance Criteria\n\n1. WHEN calling `krx_profile_registry_list_profiles()` THEN it SHALL return a JSON array of all profiles (id, name, layout_type, created_at, modified_at)\n2. WHEN calling `krx_profile_registry_get_profile(profile_id)` THEN it SHALL return the full profile JSON including mappings\n3. WHEN calling `krx_profile_registry_save_profile(profile_json)` THEN it SHALL parse, validate, and save the profile\n4. WHEN calling `krx_profile_registry_delete_profile(profile_id)` THEN it SHALL remove the profile file and return \"ok\" or \"error:in use by device\"\n5. WHEN calling `krx_profile_registry_find_compatible_profiles(layout_json)` THEN it SHALL return only profiles matching the provided layout_type\n6. IF profile_json is invalid JSON THEN the function SHALL return \"error:invalid JSON: {details}\"\n7. IF profile validation fails THEN the function SHALL return \"error:validation failed: {details}\"\n\n---\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: Each module (DeviceRegistry, ProfileRegistry, DeviceIdentity, CoordinateTranslator) SHALL have a single, well-defined purpose\n- **Modular Design**: Device identity extraction SHALL be platform-specific modules (`identity/windows.rs`, `identity/linux.rs`) implementing a common interface\n- **Dependency Management**: Device registry SHALL NOT depend on profile storage details; profile registry SHALL NOT depend on device detection\n- **Clear Interfaces**: FFI boundary SHALL use JSON for complex types and simple C types for primitives, with panic guards on all `extern \"C\"` functions\n- **File Size Limits**: No single Rust file SHALL exceed 500 lines (excluding comments and blank lines); complex modules SHALL be split into submodules\n- **Function Size Limits**: No function SHALL exceed 50 lines; complex logic SHALL be extracted into helper functions\n- **Test Coverage**: All registry modules SHALL have ≥ 90% test coverage; FFI functions SHALL have panic safety tests\n\n### Performance\n\n- **Input Latency**: Total pipeline latency (device resolution → profile lookup → coordinate translation → action execution) SHALL be < 1ms (p99)\n- **Device Resolution**: Resolving device handle to DeviceIdentity SHALL take < 50μs (p99)\n- **Profile Lookup**: Loading a profile from cache SHALL take < 100μs (p99); cold load from disk < 10ms\n- **Coordinate Translation**: Scancode to (row, col) translation SHALL take < 20μs (p99) using cached translation maps\n- **Passthrough Mode**: When remapping is disabled, event passthrough SHALL add < 10μs overhead\n- **Startup Time**: Loading all profiles and device definitions SHALL complete within 500ms on systems with < 100 profiles\n- **Memory Usage**: Device registry SHALL use < 1KB per device; profile cache SHALL use < 100KB per cached profile\n\n### Security\n\n- **Sandboxing**: Rhai scripts in profiles SHALL NOT have access to filesystem, network, or process spawning\n- **FFI Safety**: All FFI functions SHALL validate pointer arguments (null checks) and use panic guards (`std::panic::catch_unwind`)\n- **Input Validation**: Profile JSON SHALL be validated against schema before loading; invalid profiles SHALL be rejected with clear error messages\n- **File Permissions**: Profile files SHALL be readable/writable only by the user (0600 permissions on Unix)\n- **Port-Bound Warning**: Users SHALL be warned when a device uses a synthetic (port-bound) serial number\n- **Injection Prevention**: User-provided labels and profile names SHALL be sanitized before use in file paths or logs\n\n### Reliability\n\n- **Crash Recovery**: If a profile fails to load, KeyRx SHALL log the error and continue with other profiles (partial failure allowed)\n- **Atomic Writes**: Profile saves and device_bindings.json updates SHALL use atomic write (temp file + rename) to prevent corruption\n- **Backup Creation**: Migration SHALL create backups before modifying old profiles\n- **Graceful Degradation**: If device definition is missing, fall back to generic ANSI layout; if profile is missing, use passthrough mode\n- **Error Logging**: All errors SHALL be logged with structured context (device identity, profile ID, file path, error details)\n- **Panic Prevention**: No panic SHALL occur during normal operation; all potential panic points SHALL use `Result<T, Error>` and proper error handling\n\n### Usability\n\n- **Onboarding**: First-time users SHALL see a clear empty state on the Devices tab prompting them to connect a device\n- **Feedback**: All state changes (remap toggle, profile assignment) SHALL provide immediate visual feedback (< 100ms UI update)\n- **Error Messages**: All error messages SHALL be user-friendly (e.g., \"Device not found. Try reconnecting it.\" instead of \"DeviceNotFoundError\")\n- **Tooltips**: All UI controls (toggle, dropdown, buttons) SHALL have descriptive tooltips\n- **Keyboard Navigation**: All UI elements SHALL be keyboard-accessible (tab navigation, enter to activate)\n- **Accessibility**: Text SHALL have sufficient contrast (WCAG AA compliant); icons SHALL have alt text\n\n### Maintainability\n\n- **Documentation**: All public APIs SHALL have rustdoc comments with examples; all FFI functions SHALL document memory ownership\n- **Code Comments**: Complex algorithms (e.g., synthetic ID generation) SHALL have inline comments explaining the logic\n- **Migration Path**: Old data structures SHALL be clearly marked as deprecated with migration instructions\n- **Feature Flags**: The revolutionary mapping system SHALL be behind a feature flag for gradual rollout\n- **Logging**: All critical paths SHALL have structured logging with appropriate log levels (trace, debug, info, warn, error)\n- **Metrics**: Key operations (device registration, profile assignment) SHALL emit metrics for monitoring\n\n",
  "fileStats": {
    "size": 25226,
    "lines": 357,
    "lastModified": "2025-12-05T16:22:32.908Z"
  },
  "comments": []
}