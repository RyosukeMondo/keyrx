{
  "id": "snapshot_1764952235358_hixe089nr",
  "approvalId": "approval_1764951966702_kscwpsj8k",
  "approvalTitle": "Revolutionary Mapping - Design Document",
  "version": 2,
  "timestamp": "2025-12-05T16:30:35.358Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document - Revolutionary Mapping\n\n## Overview\n\nThe Revolutionary Mapping system introduces a fundamental architectural shift in KeyRx by decoupling physical device identity from logical configuration profiles. This design implements a three-layer architecture: **Identity Layer** (device uniqueness), **Registry Layer** (runtime state + persistent storage), and **Pipeline Layer** (multi-stage input processing).\n\nThe system allows users to manage multiple identical devices independently, swap profiles instantly, and support arbitrary device layouts beyond standard keyboards. The design maintains KeyRx's core performance requirement of <1ms input latency while adding new capabilities.\n\n**Place in Overall System:** This feature extends the existing event processing pipeline by adding device resolution and profile resolution stages before the existing Rhai script execution. It integrates with the current FFI layer to expose new capabilities to the Flutter UI.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Event Sourcing:** The design maintains the existing event sourcing pattern where input events remain immutable and flow through the processing pipeline.\n\n**No Global State:** All registries (DeviceRegistry, ProfileRegistry) are self-contained structs passed via Arc<RwLock<>> for thread-safe shared access.\n\n**Modular Drivers:** Platform-specific serial number extraction is isolated in `identity/windows.rs` and `identity/linux.rs`, implementing a common interface.\n\n**CLI First:** All registry operations (list devices, assign profile, toggle remap) will be CLI-accessible via `keyrx device ...` and `keyrx profile ...` commands before UI implementation.\n\n**Scripting Contract:** Profiles continue to use Rhai scripting as defined in tech.md, with the addition of row-col physical positioning.\n\n**FFI Architecture:** Follows the existing domain-based FFI pattern with new domains: `device_registry.rs`, `profile_registry.rs`, `device_definitions.rs`.\n\n**Performance:** Adheres to the <1ms latency requirement through aggressive caching (profile cache, translation map cache) and lock-free reads where possible.\n\n### Project Structure (structure.md)\n\n**New Modules:**\n- `core/src/identity/` - Device identity and serial extraction\n- `core/src/registry/` - Device and profile registries\n- `core/src/definitions/` - Device definition loader\n- `core/src/engine/device_resolver.rs` - Pipeline stage 1\n- `core/src/engine/profile_resolver.rs` - Pipeline stage 2\n- `core/src/engine/coordinate_translator.rs` - Pipeline stage 3\n\n**Modified Modules:**\n- `core/src/drivers/windows/raw_input.rs` - Add serial extraction\n- `core/src/drivers/linux/evdev_input.rs` - Add serial extraction\n- `core/src/engine/core.rs` - Integrate new pipeline stages\n- `core/src/ffi/domains/` - Add new FFI domains\n\n**New Directories:**\n- `device_definitions/` - TOML device specifications\n- `.config/keyrx/profiles/` - User profile storage\n\n**File Size:** All new files will adhere to the 500-line limit; complex modules will be split into submodules.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`core/src/config/paths.rs`**: Reuse existing config directory resolution for profiles and device_bindings.json storage location\n- **`core/src/drivers/keycodes/`**: Reuse existing KeyCode enum and aliases for profile mappings\n- **`core/src/scripting/engine.rs`**: Reuse Rhai engine for profile script execution\n- **`core/src/discovery/types.rs`**: PhysicalKey struct concept extends to PhysicalPosition; existing row/col layout awareness provides foundation\n- **`core/src/ffi/utils.rs`**: Reuse existing FFI panic guards, string conversion utilities, and error handling patterns\n- **`ui/lib/ffi/`**: Extend existing FFI binding pattern for new registry domains\n- **`ui/lib/services/`**: Follow existing service layer pattern for DeviceRegistryService and ProfileRegistryService\n\n### Integration Points\n\n- **Existing Engine:** New pipeline stages integrate before existing Rhai script execution; passthrough mode bypasses all existing processing\n- **Existing FFI Layer:** New FFI domains follow the same panic-safe, JSON-based pattern as existing `device.rs`, `engine.rs` domains\n- **Existing Discovery:** Old `discovery/` module will be deprecated but kept for migration; new system replaces its functionality\n- **Existing UI Navigation:** Devices tab already exists; we'll enhance it and reorder navigation rather than creating from scratch\n- **Existing Visual Editor:** Current editor provides drag-drop infrastructure; we'll extend it to support dynamic layouts\n\n## Architecture\n\n### High-Level System Architecture\n\n```mermaid\ngraph TB\n    subgraph \"OS Layer\"\n        WIN[Windows Raw Input]\n        LIN[Linux evdev]\n    end\n\n    subgraph \"Identity Layer\"\n        WINSER[Windows Serial Extraction]\n        LINSER[Linux Serial Extraction]\n        DEVID[DeviceIdentity]\n    end\n\n    subgraph \"Registry Layer\"\n        DEVREG[DeviceRegistry<br/>In-Memory]\n        PROFR EG[ProfileRegistry<br/>Cached + Disk]\n        DEFLIB[DeviceDefinitionLibrary<br/>Read-Only]\n        BINDINGS[DeviceBindings<br/>Persistent]\n    end\n\n    subgraph \"Pipeline Layer\"\n        DEVRES[DeviceResolver]\n        PROFRES[ProfileResolver]\n        COORDT[CoordinateTranslator]\n        ACTRES[ActionResolver]\n        EXEC[Executor]\n    end\n\n    subgraph \"FFI Layer\"\n        DEVFFI[device_registry FFI]\n        PROFFFI[profile_registry FFI]\n        DEFFFI[definitions FFI]\n    end\n\n    subgraph \"UI Layer\"\n        DEVPAGE[Devices Page]\n        EDPAGE[Editor Page]\n    end\n\n    WIN --> WINSER\n    LIN --> LINSER\n    WINSER --> DEVID\n    LINSER --> DEVID\n\n    DEVID --> DEVREG\n    DEVREG --> BINDINGS\n    PROFR EG --> BINDINGS\n\n    DEVRES --> DEVREG\n    PROFRES --> PROFR EG\n    COORDT --> DEFLIB\n\n    DEVRES --> PROFRES\n    PROFRES --> COORDT\n    COORDT --> ACTRES\n    ACTRES --> EXEC\n\n    DEVREG --> DEVFFI\n    PROFR EG --> PROFFFI\n    DEFLIB --> DEFFFI\n\n    DEVFFI --> DEVPAGE\n    PROFFFI --> EDPAGE\n    DEFFFI --> EDPAGE\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**:\n  - `identity/windows.rs` - Windows serial extraction only\n  - `registry/device.rs` - Device runtime state only\n  - `registry/profile.rs` - Profile storage only\n  - `registry/bindings.rs` - Device-profile persistence only\n\n- **Component Isolation**:\n  - DeviceRegistry has no knowledge of Profile internal structure\n  - ProfileRegistry has no knowledge of Device connectivity\n  - CoordinateTranslator only knows about scancode → (row, col) mapping\n\n- **Service Layer Separation**:\n  - Identity layer: Extracts device uniqueness (no state management)\n  - Registry layer: Manages state and storage (no I/O knowledge)\n  - Pipeline layer: Processes events (no storage knowledge)\n\n- **Utility Modularity**:\n  - Serial extraction utilities separate from device registration\n  - TOML parsing separate from definition lookup\n  - JSON serialization separate from storage\n\n### Data Flow Through System\n\n```\nInput Event → Device Handle → DeviceIdentity → DeviceState → Profile → (Row,Col) → KeyAction → Output\n     ↓              ↓              ↓               ↓            ↓          ↓           ↓\n   OS Driver    Platform    Identity Cache   Device Reg   Profile Cache  Def Lib   Action Map\n```\n\n## Components and Interfaces\n\n### Component 1: DeviceIdentity (core/src/identity/types.rs)\n\n- **Purpose:** Uniquely identify a physical device across sessions\n- **Interfaces:**\n  ```rust\n  pub struct DeviceIdentity {\n      pub vendor_id: u16,\n      pub product_id: u16,\n      pub serial_number: String,\n      pub user_label: Option<String>,\n  }\n\n  impl DeviceIdentity {\n      pub fn to_key(&self) -> String;  // \"{vid:04x}:{pid:04x}:{serial}\"\n      pub fn from_key(key: &str) -> Result<Self>;\n  }\n  ```\n- **Dependencies:** serde for serialization\n- **Reuses:** None (new foundational component)\n\n---\n\n### Component 2: Windows Serial Extraction (core/src/identity/windows.rs)\n\n- **Purpose:** Extract unique serial number from Windows device path\n- **Interfaces:**\n  ```rust\n  pub fn extract_serial_number(device_path: &str) -> Result<String>;\n  fn parse_instance_id_from_path(path: &str) -> Result<String>;\n  fn read_iserial_descriptor(path: &str) -> Result<String>;\n  ```\n- **Dependencies:** windows-rs (HidD_GetSerialNumberString, CreateFileW)\n- **Reuses:** None (platform-specific)\n\n---\n\n### Component 3: Linux Serial Extraction (core/src/identity/linux.rs)\n\n- **Purpose:** Extract unique serial number from Linux evdev device\n- **Interfaces:**\n  ```rust\n  pub fn extract_serial_number(device_path: &Path) -> Result<String>;\n  fn read_udev_serial(device_path: &Path) -> Result<String>;\n  fn generate_synthetic_id(phys: &str, input_id: InputId) -> String;\n  ```\n- **Dependencies:** evdev crate, std::fs for udev sysfs reading\n- **Reuses:** Existing evdev integration from `drivers/linux/`\n\n---\n\n### Component 4: DeviceRegistry (core/src/registry/device.rs)\n\n- **Purpose:** Track runtime state of all connected devices\n- **Interfaces:**\n  ```rust\n  pub struct DeviceRegistry {\n      devices: Arc<RwLock<HashMap<DeviceIdentity, DeviceState>>>,\n      event_tx: mpsc::UnboundedSender<DeviceEvent>,\n  }\n\n  impl DeviceRegistry {\n      pub fn new(event_tx: mpsc::UnboundedSender<DeviceEvent>) -> Self;\n      pub async fn register_device(&self, identity: DeviceIdentity, state: DeviceState) -> Result<()>;\n      pub async fn unregister_device(&self, identity: &DeviceIdentity) -> Result<()>;\n      pub async fn set_remap_enabled(&self, identity: &DeviceIdentity, enabled: bool) -> Result<()>;\n      pub async fn assign_profile(&self, identity: &DeviceIdentity, profile_id: ProfileId) -> Result<()>;\n      pub async fn get_device_state(&self, identity: &DeviceIdentity) -> Option<DeviceState>;\n      pub async fn list_devices(&self) -> Vec<DeviceState>;\n  }\n  ```\n- **Dependencies:** tokio for async, serde for serialization\n- **Reuses:** Existing event channel pattern from `engine/multi_device.rs`\n\n---\n\n### Component 5: ProfileRegistry (core/src/registry/profile.rs)\n\n- **Purpose:** Manage persistent profile storage and in-memory cache\n- **Interfaces:**\n  ```rust\n  pub struct ProfileRegistry {\n      profiles: Arc<RwLock<HashMap<ProfileId, Profile>>>,\n      storage_path: PathBuf,\n  }\n\n  impl ProfileRegistry {\n      pub fn new(storage_path: PathBuf) -> Result<Self>;\n      pub async fn save_profile(&self, profile: Profile) -> Result<()>;\n      pub async fn get_profile(&self, id: &ProfileId) -> Option<Profile>;\n      pub async fn delete_profile(&self, id: &ProfileId) -> Result<()>;\n      pub async fn list_profiles(&self) -> Vec<Profile>;\n      pub async fn find_compatible_profiles(&self, layout: &LayoutType) -> Vec<Profile>;\n\n      fn load_all_profiles(&self) -> Result<()>;\n      fn validate_profile(&self, profile: &Profile) -> Result<()>;\n      async fn write_profile_to_disk(&self, profile: &Profile) -> Result<()>;\n  }\n  ```\n- **Dependencies:** tokio::fs for async I/O, serde_json for serialization\n- **Reuses:** Existing config paths from `config/paths.rs`\n\n---\n\n### Component 6: DeviceBindings (core/src/registry/bindings.rs)\n\n- **Purpose:** Persist device-profile assignments and user labels\n- **Interfaces:**\n  ```rust\n  pub struct DeviceBindings {\n      bindings: HashMap<DeviceIdentity, DeviceBinding>,\n      file_path: PathBuf,\n  }\n\n  impl DeviceBindings {\n      pub fn load(file_path: PathBuf) -> Result<Self>;\n      pub fn save(&self) -> Result<()>;\n      pub fn get_binding(&self, identity: &DeviceIdentity) -> Option<&DeviceBinding>;\n      pub fn set_binding(&mut self, identity: DeviceIdentity, binding: DeviceBinding);\n      pub fn remove_binding(&mut self, identity: &DeviceIdentity);\n  }\n  ```\n- **Dependencies:** serde_json for file I/O\n- **Reuses:** Atomic write pattern from existing `discovery/storage.rs`\n\n---\n\n### Component 7: DeviceDefinitionLibrary (core/src/definitions/library.rs)\n\n- **Purpose:** Load and lookup device layout definitions from TOML files\n- **Interfaces:**\n  ```rust\n  pub struct DeviceDefinitionLibrary {\n      definitions: HashMap<(u16, u16), DeviceDefinition>,  // (VID, PID) -> Definition\n  }\n\n  impl DeviceDefinitionLibrary {\n      pub fn load_from_directory(dir: &Path) -> Result<Self>;\n      pub fn find_definition(&self, vid: u16, pid: u16) -> Option<&DeviceDefinition>;\n      pub fn list_definitions(&self) -> Vec<&DeviceDefinition>;\n\n      fn load_definition(path: &Path) -> Result<DeviceDefinition>;\n      fn validate_definition(def: &DeviceDefinition) -> Result<()>;\n  }\n  ```\n- **Dependencies:** toml crate, walkdir for recursive file search\n- **Reuses:** None (new)\n\n---\n\n### Component 8: DeviceResolver (core/src/engine/device_resolver.rs)\n\n- **Purpose:** Resolve OS device handle to DeviceState\n- **Interfaces:**\n  ```rust\n  pub struct DeviceResolver {\n      device_registry: Arc<RwLock<DeviceRegistry>>,\n  }\n\n  impl DeviceResolver {\n      pub fn new(registry: Arc<RwLock<DeviceRegistry>>) -> Self;\n      pub async fn resolve(&self, device_handle: RawDeviceHandle) -> Result<Option<DeviceState>>;\n\n      fn extract_identity(&self, handle: RawDeviceHandle) -> Result<DeviceIdentity>;\n  }\n  ```\n- **Dependencies:** Platform-specific identity extraction modules\n- **Reuses:** Existing RawDeviceHandle type from drivers\n\n---\n\n### Component 9: ProfileResolver (core/src/engine/profile_resolver.rs)\n\n- **Purpose:** Load profiles from cache or registry\n- **Interfaces:**\n  ```rust\n  pub struct ProfileResolver {\n      profile_registry: Arc<RwLock<ProfileRegistry>>,\n      profile_cache: Arc<RwLock<HashMap<ProfileId, Arc<Profile>>>>,\n  }\n\n  impl ProfileResolver {\n      pub fn new(registry: Arc<RwLock<ProfileRegistry>>) -> Self;\n      pub async fn resolve(&self, profile_id: &ProfileId) -> Result<Arc<Profile>>;\n      pub async fn invalidate_cache(&self, profile_id: &ProfileId);\n  }\n  ```\n- **Dependencies:** None\n- **Reuses:** Standard Arc caching pattern\n\n---\n\n### Component 10: CoordinateTranslator (core/src/engine/coordinate_translator.rs)\n\n- **Purpose:** Translate scancodes to (row, col) physical positions\n- **Interfaces:**\n  ```rust\n  pub struct CoordinateTranslator {\n      definitions: Arc<DeviceDefinitionLibrary>,\n      translation_cache: Arc<RwLock<HashMap<DeviceIdentity, HashMap<u16, PhysicalPosition>>>>,\n  }\n\n  impl CoordinateTranslator {\n      pub fn new(definitions: Arc<DeviceDefinitionLibrary>) -> Self;\n      pub async fn translate(&self, device_identity: &DeviceIdentity, scancode: u16) -> Result<PhysicalPosition>;\n  }\n  ```\n- **Dependencies:** DeviceDefinitionLibrary\n- **Reuses:** Existing PhysicalPosition concept from discovery/types.rs\n\n---\n\n### Component 11: FFI - Device Registry (core/src/ffi/domains/device_registry.rs)\n\n- **Purpose:** Expose device registry to Flutter UI\n- **Interfaces:**\n  ```rust\n  #[no_mangle]\n  pub extern \"C\" fn krx_device_registry_list_devices() -> *mut c_char;\n\n  #[no_mangle]\n  pub extern \"C\" fn krx_device_registry_set_remap_enabled(\n      vendor_id: u16, product_id: u16, serial: *const c_char, enabled: bool\n  ) -> *mut c_char;\n\n  #[no_mangle]\n  pub extern \"C\" fn krx_device_registry_assign_profile(\n      vendor_id: u16, product_id: u16, serial: *const c_char, profile_id: *const c_char\n  ) -> *mut c_char;\n\n  #[no_mangle]\n  pub extern \"C\" fn krx_device_registry_set_user_label(\n      vendor_id: u16, product_id: u16, serial: *const c_char, label: *const c_char\n  ) -> *mut c_char;\n  ```\n- **Dependencies:** libc, existing FFI utilities\n- **Reuses:** Panic guard pattern from `ffi/utils.rs`\n\n---\n\n### Component 12: Flutter - DeviceRegistryService (ui/lib/services/device_registry_service.dart)\n\n- **Purpose:** High-level Dart API wrapping FFI calls\n- **Interfaces:**\n  ```dart\n  class DeviceRegistryService {\n      Future<List<DeviceState>> getDevices();\n      Future<void> toggleRemap(DeviceIdentity device, bool enabled);\n      Future<void> assignProfile(DeviceIdentity device, String profileId);\n      Future<void> setUserLabel(DeviceIdentity device, String label);\n  }\n  ```\n- **Dependencies:** DeviceRegistryFFI (direct FFI bindings)\n- **Reuses:** Existing service layer pattern from `services/device_service.dart`\n\n---\n\n### Component 13: Flutter - DeviceCard Widget (ui/lib/widgets/device_card.dart)\n\n- **Purpose:** Display single device with controls\n- **Interfaces:**\n  ```dart\n  class DeviceCard extends StatelessWidget {\n      final DeviceState deviceState;\n      final Function(bool) onRemapToggle;\n      final Function(String) onProfileSelect;\n      final VoidCallback onEditLabel;\n  }\n  ```\n- **Dependencies:** Material widgets, ProfileSelector, RemapToggle\n- **Reuses:** Existing Card widget patterns from UI\n\n---\n\n### Component 14: Flutter - LayoutGrid Widget (ui/lib/widgets/layout_grid.dart)\n\n- **Purpose:** Dynamically render device layouts (matrix, standard, split)\n- **Interfaces:**\n  ```dart\n  class LayoutGrid extends StatelessWidget {\n      final LayoutType layoutType;\n      final Map<PhysicalPosition, KeyAction> mappings;\n      final Function(PhysicalPosition) onKeyTap;\n  }\n  ```\n- **Dependencies:** None\n- **Reuses:** Existing keyboard layout concept from `models/keyboard_layout.dart`, extending to support arbitrary grids\n\n---\n\n## Data Models\n\n### DeviceIdentity\n```rust\npub struct DeviceIdentity {\n    pub vendor_id: u16,           // USB Vendor ID\n    pub product_id: u16,          // USB Product ID\n    pub serial_number: String,    // Hardware serial or synthetic ID\n    pub user_label: Option<String>, // User-friendly name\n}\n```\n\n### DeviceState\n```rust\npub struct DeviceState {\n    pub identity: DeviceIdentity,\n    pub is_remapping_enabled: bool,\n    pub active_profile_id: Option<ProfileId>,\n    pub connected_at: DateTime<Utc>,\n    pub state: DeviceRuntimeState,\n}\n\npub enum DeviceRuntimeState {\n    Active,\n    Passthrough,\n    Failed { error_code: u32 },\n}\n```\n\n### Profile\n```rust\npub struct Profile {\n    pub id: ProfileId,             // UUID\n    pub name: String,\n    pub layout_type: LayoutType,\n    pub mappings: HashMap<PhysicalPosition, KeyAction>,\n    pub created_at: DateTime<Utc>,\n    pub modified_at: DateTime<Utc>,\n    pub description: Option<String>,\n    pub tags: Vec<String>,\n    pub script_source: Option<String>, // Optional Rhai script\n}\n```\n\n### LayoutType\n```rust\npub enum LayoutType {\n    Standard(StandardLayout),      // ANSI, ISO, JIS\n    Matrix { rows: u8, cols: u8 }, // Custom grid\n    Split {                        // Split keyboard\n        left: Box<LayoutType>,\n        right: Box<LayoutType>,\n    },\n}\n\npub enum StandardLayout {\n    ANSI,\n    ISO,\n    JIS,\n}\n```\n\n### PhysicalPosition\n```rust\npub struct PhysicalPosition {\n    pub row: u8,\n    pub col: u8,\n}\n```\n\n### KeyAction\n```rust\npub enum KeyAction {\n    Key(KeyCode),                  // Single key output\n    Chord {                        // Modifier + key (e.g., Ctrl+C)\n        modifiers: Vec<KeyCode>,\n        key: KeyCode,\n    },\n    Script(String),                // Rhai script execution\n    Block,                         // Suppress key\n    Pass,                          // Passthrough (no remap)\n}\n```\n\n### DeviceBinding\n```rust\npub struct DeviceBinding {\n    pub active_profile_id: Option<ProfileId>,\n    pub is_remapping_enabled: bool,\n    pub last_connected: DateTime<Utc>,\n}\n```\n\n### DeviceDefinition\n```rust\npub struct DeviceDefinition {\n    pub name: String,\n    pub vendor_id: u16,\n    pub product_id: u16,\n    pub manufacturer: Option<String>,\n    pub layout: LayoutDefinition,\n    pub matrix_map: HashMap<u16, PhysicalPosition>, // scancode -> (row, col)\n    pub visual: Option<VisualMetadata>,\n}\n\npub struct LayoutDefinition {\n    pub layout_type: String,       // \"Matrix\", \"Standard\", \"Split\"\n    pub rows: u8,\n    pub cols: Option<u8>,\n    pub cols_per_row: Option<Vec<u8>>,\n}\n\npub struct VisualMetadata {\n    pub key_width: u16,\n    pub key_height: u16,\n    pub key_spacing: u8,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Device Serial Extraction Fails**\n   - **Handling:** Fall back to synthetic ID generation; log warning; set flag `is_port_bound = true`\n   - **User Impact:** User sees warning: \"This device doesn't have a serial number. Configuration is tied to USB port.\"\n\n2. **Profile File Corrupted**\n   - **Handling:** Skip loading that profile; log error with file path; continue with other profiles\n   - **User Impact:** Profile doesn't appear in list; error shown in logs/console\n\n3. **Profile Assignment - Layout Incompatible**\n   - **Handling:** Return error from `assign_profile()` with details: \"Device has 3×5 layout but profile requires 5×5\"\n   - **User Impact:** Dialog shows error; assignment is rejected; device remains in current state\n\n4. **Device Registry - Device Not Found**\n   - **Handling:** Return `Error::DeviceNotFound(identity)` from registry methods\n   - **User Impact:** UI shows: \"Device not connected. Please reconnect device.\"\n\n5. **FFI Panic**\n   - **Handling:** `catch_unwind()` in all extern \"C\" functions; return \"error:panic occurred\"\n   - **User Impact:** Operation fails gracefully; UI shows generic error; app doesn't crash\n\n6. **Device Definition Missing**\n   - **Handling:** Fall back to generic ANSI layout; log info message\n   - **User Impact:** Editor shows standard keyboard layout instead of custom layout\n\n7. **Profile Load - Rhai Script Invalid**\n   - **Handling:** Validate script on load; if invalid, set `script_source = None` and use mappings only\n   - **User Impact:** Profile loads but without advanced scripting; user can fix script in editor\n\n8. **Atomic Write Failure**\n   - **Handling:** If temp file write succeeds but rename fails, retry once; if still fails, return error without corrupting original\n   - **User Impact:** Save operation fails; user sees error; original profile preserved\n\n9. **Migration - Old Profile Parse Error**\n   - **Handling:** Log error; skip that profile; continue with others; include in migration report\n   - **User Impact:** Migration summary shows: \"Migrated 9/10 profiles. 1 failed (see logs).\"\n\n## Testing Strategy\n\n### Unit Testing\n\n**Core Modules:**\n- `identity/windows.rs`: Test `parse_instance_id_from_path()` with various device path formats\n- `identity/linux.rs`: Test `generate_synthetic_id()` with different phys paths; verify hash stability\n- `registry/device.rs`: Test all CRUD operations; concurrent access tests\n- `registry/profile.rs`: Test save/load roundtrip; validation; compatibility filtering\n- `registry/bindings.rs`: Test load/save; missing file handling\n- `definitions/library.rs`: Test TOML parsing; validation; VID:PID lookup\n\n**Key Unit Tests:**\n```rust\n#[test]\nfn test_device_identity_key_roundtrip() {\n    let identity = DeviceIdentity { /* ... */ };\n    let key = identity.to_key();\n    let parsed = DeviceIdentity::from_key(&key).unwrap();\n    assert_eq!(identity, parsed);\n}\n\n#[tokio::test]\nasync fn test_device_registry_concurrent_access() {\n    // Spawn 10 tasks reading/writing device registry concurrently\n    // Verify no data races or deadlocks\n}\n\n#[test]\nfn test_profile_validation_rejects_invalid_layout() {\n    let profile = Profile {\n        layout_type: LayoutType::Matrix { rows: 0, cols: 5 }, // Invalid: 0 rows\n        /* ... */\n    };\n    assert!(validate_profile(&profile).is_err());\n}\n```\n\n### Integration Testing\n\n**Cross-Module Tests:**\n- Device registration → profile assignment → remap toggle → input processing (full flow)\n- Profile save → app restart → profile reload → verify mappings intact\n- Two identical devices → different profiles → verify isolation\n- Device disconnect/reconnect → verify bindings persist\n- Migration: old profile files → new system → verify conversion\n\n**Key Integration Tests:**\n```rust\n#[tokio::test]\nasync fn test_multi_device_isolation() {\n    let registry = DeviceRegistry::new(/* ... */);\n    let profile_registry = ProfileRegistry::new(/* ... */);\n\n    // Register two identical devices (same VID:PID, different serials)\n    let device1 = DeviceIdentity { serial_number: \"ABC123\", /* ... */ };\n    let device2 = DeviceIdentity { serial_number: \"XYZ789\", /* ... */ };\n\n    // Assign different profiles\n    registry.assign_profile(&device1, \"profile-work\".into()).await.unwrap();\n    registry.assign_profile(&device2, \"profile-gaming\".into()).await.unwrap();\n\n    // Verify isolation\n    let state1 = registry.get_device_state(&device1).await.unwrap();\n    let state2 = registry.get_device_state(&device2).await.unwrap();\n    assert_eq!(state1.active_profile_id, Some(\"profile-work\".into()));\n    assert_eq!(state2.active_profile_id, Some(\"profile-gaming\".into()));\n}\n\n#[tokio::test]\nasync fn test_profile_persistence() {\n    let profile = Profile { /* ... */ };\n    let registry = ProfileRegistry::new(temp_dir()).unwrap();\n\n    // Save profile\n    registry.save_profile(profile.clone()).await.unwrap();\n\n    // Simulate restart: create new registry instance\n    let new_registry = ProfileRegistry::new(temp_dir()).unwrap();\n\n    // Verify profile loaded\n    let loaded = new_registry.get_profile(&profile.id).await.unwrap();\n    assert_eq!(loaded, profile);\n}\n```\n\n### End-to-End Testing\n\n**User Scenarios:**\n1. **First-Time User Setup:**\n   - Connect device → See empty state → Assign label → Assign profile → Toggle remap ON → Verify input remapped\n\n2. **Multi-Device Power User:**\n   - Connect 3 devices → Label each → Assign different profiles → Toggle remap individually → Verify each device works independently\n\n3. **Profile Swapping:**\n   - Connect device with profile A active → Swap to profile B → Verify behavior changes immediately (< 100ms)\n\n4. **Migration:**\n   - Start with old KeyRx data → Upgrade to new version → Accept migration prompt → Verify all old profiles converted → Verify devices auto-assigned\n\n5. **Custom Layout:**\n   - Connect 5×5 macro pad → Open editor → Verify 5×5 grid displayed → Create mappings → Verify mappings work\n\n**E2E Test Implementation:**\n```rust\n#[tokio::test]\nasync fn test_e2e_profile_swap() {\n    let mut engine = Engine::new_with_revolutionary_mapping(/* ... */);\n    let device = simulate_device_connection(/* VID:PID:Serial */);\n\n    // Assign profile A\n    engine.assign_profile(&device.identity, \"profile-vim\").await.unwrap();\n    engine.set_remap_enabled(&device.identity, true).await.unwrap();\n\n    // Simulate key press (expecting Vim-style mapping)\n    let input = simulate_key_press(&device, \"H\"); // Vim left\n    let output = engine.process_input(input).await.unwrap();\n    assert_eq!(output, KeyCode::Left);\n\n    // Swap to profile B (gaming)\n    engine.assign_profile(&device.identity, \"profile-gaming\").await.unwrap();\n\n    // Same key, different output\n    let input = simulate_key_press(&device, \"H\");\n    let output = engine.process_input(input).await.unwrap();\n    assert_eq!(output, KeyCode::H); // Passthrough in gaming profile\n}\n```\n\n### Performance Testing\n\n**Benchmarks (using Criterion):**\n```rust\nfn bench_device_resolution(c: &mut Criterion) {\n    c.bench_function(\"device_resolution\", |b| {\n        b.iter(|| {\n            // Measure time from raw handle to DeviceState\n        });\n    });\n}\n\nfn bench_profile_lookup(c: &mut Criterion) {\n    c.bench_function(\"profile_lookup_cached\", |b| {\n        b.iter(|| {\n            // Measure cached profile load\n        });\n    });\n}\n\nfn bench_full_pipeline(c: &mut Criterion) {\n    c.bench_function(\"full_pipeline\", |b| {\n        b.iter(|| {\n            // Measure end-to-end: raw event → output\n        });\n    });\n}\n```\n\n**Performance Targets:**\n- Device resolution: <50μs (p99)\n- Profile lookup (cached): <100μs (p99)\n- Coordinate translation: <20μs (p99)\n- Full pipeline: <1ms (p99)\n\n### Fuzz Testing\n\n**Fuzzing Targets:**\n- Device path parsing (random strings)\n- Profile JSON deserialization (malformed JSON)\n- TOML parsing (malformed device definitions)\n- Concurrent registry access (random operation sequences)\n\n```rust\n#[cfg(test)]\nmod fuzz {\n    use proptest::prelude::*;\n\n    proptest! {\n        #[test]\n        fn test_device_path_parsing_never_panics(path in \"\\\\PC.*\") {\n            let _ = parse_instance_id_from_path(&path); // Should return Err, not panic\n        }\n\n        #[test]\n        fn test_profile_json_never_panics(json in \".*\") {\n            let _ = serde_json::from_str::<Profile>(&json); // Should return Err, not panic\n        }\n    }\n}\n```\n\n## Security Considerations\n\n1. **Sandboxing:** Rhai scripts in profiles continue to use existing sandbox (no FS/network access)\n2. **FFI Boundary:** All extern \"C\" functions validate pointers and use panic guards\n3. **File Permissions:** Profile files written with 0600 permissions (user-only read/write)\n4. **Input Validation:** Profile names and device labels sanitized before use in file paths\n5. **Port-Bound Warning:** Users explicitly warned when devices lack hardware serials\n\n## Migration Path\n\n**Old System:** `~/.config/keyrx/devices/{vid}_{pid}.json` per VID:PID\n**New System:** `~/.config/keyrx/profiles/{uuid}.json` per profile + `device_bindings.json`\n\n**Migration Process:**\n1. Detect old files on first run with new system\n2. Prompt user: \"Migrate old profiles?\"\n3. Convert each old file to new Profile (generate UUID, infer layout from rows/cols)\n4. For each connected device matching old VID:PID, create binding to migrated profile\n5. Backup old files to `devices_backup/`\n6. Write migration report\n\n## Performance Optimizations\n\n1. **Caching:**\n   - Profile cache: Arc<Profile> shared across pipeline stages\n   - Translation map cache: HashMap<scancode, (row, col)> per device\n   - Device registry: In-memory HashMap for O(1) lookups\n\n2. **Lock Contention:**\n   - Use RwLock for registries (many readers, few writers)\n   - Minimize lock hold time (clone data before releasing)\n   - Consider lock-free structures (dashmap) for hot paths\n\n3. **Async I/O:**\n   - Use tokio::fs for non-blocking profile I/O\n   - Batch profile loads on startup\n\n4. **Lazy Loading:**\n   - Device definitions loaded once on startup\n   - Profiles loaded into cache on first access\n\n",
  "fileStats": {
    "size": 30021,
    "lines": 855,
    "lastModified": "2025-12-05T16:26:00.676Z"
  },
  "comments": []
}