{
  "id": "snapshot_1765450427809_vg25gap36",
  "approvalId": "approval_1765450427779_6e2pyar08",
  "approvalTitle": "Dart Binding Code Generation - Requirements",
  "version": 1,
  "timestamp": "2025-12-11T10:53:47.809Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe Dart Binding Code Generation feature automatically generates type-safe Dart FFI bindings from JSON contracts, eliminating manual synchronization between Rust exports and Dart imports. This ensures that the Dart UI always has correct function signatures and type definitions that match the Rust core.\n\n**Current Problem**: Developers manually write Dart FFI bindings in `ui/lib/ffi/bindings.dart`, duplicating type information and function signatures. When Rust FFI changes, Dart bindings must be manually updated, leading to potential mismatches and runtime errors.\n\n**Solution**: Create a code generator tool that reads JSON contracts and produces Dart FFI bindings with proper type mappings, null safety, and error handling.\n\n## Alignment with Product Vision\n\nThis feature completes the contract-driven development vision by establishing JSON contracts as the single source of truth for both Rust and Dart. It supports KeyRx's \"Performance > Features\" principle by enabling compile-time verification of the entire FFI boundary, catching errors before they reach the user.\n\nBy automating binding generation, this feature enables rapid iteration on FFI interfaces without the maintenance burden of manual synchronization.\n\n## Requirements\n\n### Requirement 1: Generate Dart FFI Function Signatures\n\n**User Story:** As a UI developer, I want Dart FFI bindings generated automatically, so that I don't have to manually keep them in sync with Rust.\n\n#### Acceptance Criteria\n\n1. WHEN the generator runs THEN it SHALL:\n   - Read all `*.ffi-contract.json` files from the contracts directory\n   - Generate a Dart file `lib/ffi/generated_bindings.dart` with all FFI function signatures\n   - Use `dart:ffi` types for C interop\n2. WHEN a contract specifies `function: \"keyrx_config_save_profile\"` THEN the generated signature SHALL be:\n   ```dart\n   late final _keyrx_config_save_profile _save_profile_ptr = _dylib\n       .lookup<NativeFunction<_keyrx_config_save_profile_native>>('keyrx_config_save_profile')\n       .asFunction();\n   ```\n3. WHEN parameter types are defined THEN they SHALL be mapped to appropriate Dart FFI types\n4. WHEN the generator fails THEN it SHALL exit with a non-zero code and descriptive error message\n\n### Requirement 2: Type Mapping from Contract to Dart\n\n**User Story:** As a UI developer, I want automatic type conversion between Dart and FFI types, so that I can work with idiomatic Dart types.\n\n#### Acceptance Criteria\n\n1. WHEN the contract type is `string` THEN the generator SHALL:\n   - Use `Pointer<Utf8>` for C strings\n   - Provide helper methods for `String` ↔ `Pointer<Utf8>` conversion\n2. WHEN the contract type is a custom struct THEN the generator SHALL:\n   - Use `Pointer<Utf8>` for JSON-serialized data\n   - Generate Dart classes with `fromJson` and `toJson` methods\n3. WHEN the contract type is `int` THEN it SHALL map to Dart `int`\n4. WHEN the contract type is `bool` THEN it SHALL map to Dart `bool`\n5. WHEN the contract type is `void` THEN it SHALL map to Dart `void`\n\n### Requirement 3: Error Handling Wrappers\n\n**User Story:** As a UI developer, I want automatic error handling for FFI calls, so that I don't have to manually check error pointers.\n\n#### Acceptance Criteria\n\n1. WHEN an FFI function has an error pointer THEN the generator SHALL create a wrapper that:\n   - Allocates the error pointer\n   - Calls the native function\n   - Checks if the error pointer is non-null\n   - Throws a Dart exception with the error message if an error occurred\n   - Frees the error pointer\n2. WHEN no error occurs THEN the wrapper SHALL return the result normally\n3. WHEN an FFI call panics THEN the Dart wrapper SHALL throw `FfiException` with the panic message\n4. Example generated wrapper:\n   ```dart\n   HardwareProfile saveProfile(String profileId, HardwareProfile profile) {\n     final errorPtr = calloc<Pointer<Utf8>>();\n     final result = _save_profile_ptr(\n       profileId.toNativeUtf8(),\n       jsonEncode(profile).toNativeUtf8(),\n       errorPtr\n     );\n     if (errorPtr.value.address != 0) {\n       final error = errorPtr.value.toDartString();\n       calloc.free(errorPtr);\n       throw FfiException(error);\n     }\n     calloc.free(errorPtr);\n     return HardwareProfile.fromJson(jsonDecode(result.toDartString()));\n   }\n   ```\n\n### Requirement 4: Null Safety and Memory Management\n\n**User Story:** As a UI developer, I want automatic memory management for FFI calls, so that I don't cause memory leaks or crashes.\n\n#### Acceptance Criteria\n\n1. WHEN allocating C strings THEN the wrapper SHALL use `calloc` from `package:ffi`\n2. WHEN the FFI call completes THEN the wrapper SHALL free all allocated memory\n3. WHEN a null pointer is returned THEN the wrapper SHALL handle it gracefully (return null or throw exception based on contract)\n4. WHEN the contract specifies `nullable: true` THEN the Dart type SHALL be nullable (`String?`)\n5. WHEN the contract specifies `nullable: false` THEN null results SHALL throw `FfiException(\"Unexpected null return\")`\n\n### Requirement 5: Type-Safe Dart Classes from Contracts\n\n**User Story:** As a UI developer, I want Dart classes generated for custom types, so that I have type safety and auto-complete in the IDE.\n\n#### Acceptance Criteria\n\n1. WHEN a contract defines a custom type (e.g., `HardwareProfile`) THEN the generator SHALL:\n   - Create a Dart class with fields matching the contract schema\n   - Generate `fromJson` factory constructor\n   - Generate `toJson` method\n   - Use `@JsonSerializable` annotation for code generation compatibility\n2. WHEN nested types exist THEN the generator SHALL recursively generate classes\n3. WHEN optional fields exist THEN they SHALL be nullable Dart types\n4. Example generated class:\n   ```dart\n   class HardwareProfile {\n     final String id;\n     final String name;\n     final int vendorId;\n     final int productId;\n\n     HardwareProfile({\n       required this.id,\n       required this.name,\n       required this.vendorId,\n       required this.productId,\n     });\n\n     factory HardwareProfile.fromJson(Map<String, dynamic> json) => HardwareProfile(\n       id: json['id'] as String,\n       name: json['name'] as String,\n       vendorId: json['vendor_id'] as int,\n       productId: json['product_id'] as int,\n     );\n\n     Map<String, dynamic> toJson() => {\n       'id': id,\n       'name': name,\n       'vendor_id': vendorId,\n       'product_id': productId,\n     };\n   }\n   ```\n\n### Requirement 6: CLI Tool for Generation\n\n**User Story:** As a developer, I want a CLI tool to regenerate Dart bindings, so that I can update them whenever contracts change.\n\n#### Acceptance Criteria\n\n1. WHEN I run `cargo run --bin generate-dart-bindings` THEN it SHALL:\n   - Read all contracts from `core/contracts/*.ffi-contract.json`\n   - Generate `ui/lib/ffi/generated_bindings.dart`\n   - Generate `ui/lib/models/generated_models.dart` for custom types\n   - Run `dart format` on generated files\n2. WHEN generation succeeds THEN it SHALL exit with code 0 and print: \"Dart bindings generated successfully\"\n3. WHEN generation fails THEN it SHALL exit with code 1 and print a descriptive error\n4. WHEN contracts are unchanged THEN the tool SHALL skip regeneration (check file timestamps)\n5. WHEN contracts change THEN the tool SHALL regenerate only affected files\n\n### Requirement 7: Integration with Build Process\n\n**User Story:** As a developer, I want Dart bindings to be regenerated automatically during the build, so that I never have stale bindings.\n\n#### Acceptance Criteria\n\n1. WHEN running `just build` THEN the Dart binding generator SHALL run before compiling Dart code\n2. WHEN running `just dev` THEN the generator SHALL watch contract files for changes and regenerate automatically\n3. WHEN CI runs THEN it SHALL verify that generated bindings are up-to-date (fail if regeneration would produce different output)\n4. WHEN pre-commit hooks run THEN they SHALL verify bindings are current\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility**: Generator tool only handles Dart code generation; contract parsing is a separate module\n- **Modular Design**: Separate modules for type mapping, code generation, and file writing\n- **Clear Interfaces**: Define structs for `DartFunction`, `DartType`, and `DartClass`\n\n### Performance\n\n- Generation SHALL complete in under 3 seconds for all contracts\n- Generated code SHALL have minimal runtime overhead\n- Generated code SHALL be formatted and ready for version control\n\n### Reliability\n\n- Generator SHALL produce deterministic output (same input → same output)\n- Generator SHALL never produce invalid Dart code\n- Generated bindings SHALL pass `dart analyze` without warnings\n\n### Usability\n\n- Generated code SHALL include comments referencing the source contract\n- Error messages SHALL indicate which contract file and function caused the issue\n- Documentation SHALL include examples of using generated bindings\n\n### Security\n\n- Generated code SHALL validate all JSON deserialization\n- Generated code SHALL handle malformed JSON gracefully (throw exception, not crash)\n- Generated code SHALL never expose raw pointers to Flutter UI\n",
  "fileStats": {
    "size": 9187,
    "lines": 201,
    "lastModified": "2025-12-11T10:53:36.953Z"
  },
  "comments": []
}