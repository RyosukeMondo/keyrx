{
  "id": "snapshot_1765451763107_4saqqm8x6",
  "approvalId": "approval_1765451763079_oia199ey9",
  "approvalTitle": "Dart Binding Code Generation - Design",
  "version": 1,
  "timestamp": "2025-12-11T11:16:03.107Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Dart Binding Code Generation feature automatically generates type-safe Dart FFI bindings from JSON contracts using a CLI tool. This eliminates manual synchronization between Rust FFI exports and Dart imports, ensuring that the Flutter UI always has correct function signatures and type definitions.\n\nThe generator produces Dart classes with proper null safety, memory management, error handling wrappers, and JSON serialization/deserialization for complex types.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **CLI First**: Generator is a Rust CLI tool (`generate-dart-bindings`) that integrates with the build system\n- **Error Handling**: Generated Dart code throws `FfiException` for FFI errors with structured error messages\n- **Performance**: Generated bindings have minimal overhead; direct FFI calls with efficient JSON serialization\n- **Dependency Injection**: Generated code follows Dart patterns for testability\n\n### Project Structure (structure.md)\n\n- **Generator Tool**: `core/tools/generate_dart_bindings/` - Rust CLI tool for code generation\n- **Generated Files**:\n  - `ui/lib/ffi/generated_bindings.dart` - FFI function signatures and wrappers\n  - `ui/lib/models/generated_models.dart` - Dart classes for custom types\n- **Naming**: Generated classes follow Dart `PascalCase`, functions follow `camelCase`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **ContractRegistry**: Load and parse JSON contracts\n- **FfiContract / FunctionContract**: Already models contract structure\n- **TypeDefinition**: Contract type information for mapping to Dart types\n- **FFI Library Loading**: Existing pattern in `ui/lib/ffi/` for loading native library\n\n### Integration Points\n\n- **Dart FFI**: Uses `dart:ffi` package for C interop\n- **JSON Serialization**: Uses `dart:convert` for JSON marshaling\n- **Build System**: Integrates with `justfile` for automatic regeneration\n- **Existing Bridge**: Can work alongside manual `bridge.dart` for custom wrappers\n\n## Architecture\n\nThe code generation system follows a template-based generation pipeline:\n\n```\nContract JSON → Load → Map Types → Generate Code → Format → Write Files\n```\n\n### Modular Design Principles\n\n- **Single File per Concern**: Separate files for bindings and models\n- **Template-Based**: Use string templates for consistent code generation\n- **Modular Generator**: Separate modules for type mapping, code generation, and file writing\n\n```mermaid\ngraph TD\n    A[Load Contracts] --> B[Parse Type Definitions]\n    B --> C[Generate Type Mappings]\n    C --> D[Generate FFI Signatures]\n    D --> E[Generate Wrapper Functions]\n    E --> F[Generate Model Classes]\n    F --> G[Format with dart format]\n    G --> H[Write to Files]\n```\n\n## Components and Interfaces\n\n### Component 1: CLI Tool (`generate_dart_bindings`)\n- **Purpose:** Main entry point for code generation\n- **Interfaces:**\n  - Command: `cargo run --bin generate-dart-bindings`\n  - Exit codes: 0 (success), 1 (error)\n- **Dependencies:** `clap` for CLI, `ContractRegistry` for contract loading\n- **Reuses:** Contract loading from `keyrx_core`\n\n**CLI Interface:**\n```bash\n# Generate all bindings\ncargo run --bin generate-dart-bindings\n\n# Generate for specific domain\ncargo run --bin generate-dart-bindings --domain config\n\n# Check if regeneration needed (timestamps)\ncargo run --bin generate-dart-bindings --check\n\n# Verbose mode\ncargo run --bin generate-dart-bindings --verbose\n```\n\n### Component 2: Type Mapper\n- **Purpose:** Convert contract types to Dart FFI types\n- **Interfaces:**\n  - `map_to_dart_ffi_type(contract_type: &str) -> DartFfiType`\n  - `map_to_dart_native_type(contract_type: &str) -> DartType`\n  - `needs_json_serialization(contract_type: &str) -> bool`\n- **Dependencies:** None\n- **Reuses:** Type definitions from contracts\n\n**Type Mapping Table:**\n| Contract Type | Native FFI Type | Dart Type | Conversion |\n|--------------|-----------------|-----------|------------|\n| `string` | `Pointer<Utf8>` | `String` | `.toDartString()` / `.toNativeUtf8()` |\n| `int` | `Int32` | `int` | Direct |\n| `bool` | `Bool` | `bool` | Direct |\n| `void` | `Void` | `void` | - |\n| Custom struct | `Pointer<Utf8>` | `CustomClass` | JSON encode/decode |\n| `Vec<T>` | `Pointer<Utf8>` | `List<T>` | JSON encode/decode |\n\n### Component 3: Bindings Generator\n- **Purpose:** Generate Dart FFI function signatures and wrappers\n- **Interfaces:**\n  - `generate_bindings(contracts: Vec<FfiContract>) -> String`\n  - `generate_function_binding(func: &FunctionContract) -> String`\n  - `generate_wrapper_function(func: &FunctionContract) -> String`\n- **Dependencies:** Type Mapper\n- **Reuses:** None (new functionality)\n\n**Generated Code Structure:**\n```dart\n// Part 1: Type definitions for FFI signatures\ntypedef _keyrx_config_save_hardware_profile_native = Pointer<Utf8> Function(\n  Pointer<Utf8> profileJson,\n  Pointer<Pointer<Utf8>> error,\n);\ntypedef _keyrx_config_save_hardware_profile = Pointer<Utf8> Function(\n  Pointer<Utf8> profileJson,\n  Pointer<Pointer<Utf8>> error,\n);\n\n// Part 2: Function pointer lookup\nlate final _save_hardware_profile_ptr = _dylib\n    .lookup<NativeFunction<_keyrx_config_save_hardware_profile_native>>(\n        'keyrx_config_save_hardware_profile')\n    .asFunction<_keyrx_config_save_hardware_profile>();\n\n// Part 3: High-level wrapper with error handling\nHardwareProfile saveHardwareProfile(String profileJson) {\n  final errorPtr = calloc<Pointer<Utf8>>();\n  try {\n    final profileJsonPtr = profileJson.toNativeUtf8();\n    final resultPtr = _save_hardware_profile_ptr(profileJsonPtr, errorPtr);\n\n    calloc.free(profileJsonPtr);\n\n    if (errorPtr.value.address != 0) {\n      final error = errorPtr.value.toDartString();\n      calloc.free(errorPtr.value);\n      throw FfiException(error);\n    }\n\n    if (resultPtr.address == 0) {\n      throw FfiException('Unexpected null return from FFI');\n    }\n\n    final resultJson = resultPtr.toDartString();\n    keyrx_free_string(resultPtr);\n\n    return HardwareProfile.fromJson(jsonDecode(resultJson));\n  } finally {\n    calloc.free(errorPtr);\n  }\n}\n```\n\n### Component 4: Models Generator\n- **Purpose:** Generate Dart classes for custom types\n- **Interfaces:**\n  - `generate_models(types: HashMap<String, TypeDefinition>) -> String`\n  - `generate_class(name: &str, type_def: &TypeDefinition) -> String`\n- **Dependencies:** Type Mapper\n- **Reuses:** None (new functionality)\n\n**Generated Model Structure:**\n```dart\nclass HardwareProfile {\n  final String id;\n  final String name;\n  final int vendorId;\n  final int productId;\n  final Map<int, String> wiring;\n\n  HardwareProfile({\n    required this.id,\n    required this.name,\n    required this.vendorId,\n    required this.productId,\n    required this.wiring,\n  });\n\n  factory HardwareProfile.fromJson(Map<String, dynamic> json) {\n    return HardwareProfile(\n      id: json['id'] as String,\n      name: json['name'] as String,\n      vendorId: json['vendor_id'] as int,\n      productId: json['product_id'] as int,\n      wiring: (json['wiring'] as Map<String, dynamic>).map(\n        (k, v) => MapEntry(int.parse(k), v as String),\n      ),\n    );\n  }\n\n  Map<String, dynamic> toJson() {\n    return {\n      'id': id,\n      'name': name,\n      'vendor_id': vendorId,\n      'product_id': productId,\n      'wiring': wiring.map((k, v) => MapEntry(k.toString(), v)),\n    };\n  }\n}\n```\n\n### Component 5: File Writer\n- **Purpose:** Write generated code to files and format them\n- **Interfaces:**\n  - `write_bindings(code: &str, path: &Path) -> Result<()>`\n  - `format_dart_code(code: &str) -> Result<String>`\n  - `check_if_regeneration_needed(contracts_dir: &Path, output_file: &Path) -> bool`\n- **Dependencies:** File I/O, `dart format` command\n- **Reuses:** None (new functionality)\n\n**File Writing Strategy:**\n1. Generate code in memory\n2. Run `dart format` on generated code\n3. Check if output file exists and content is identical\n4. Only write if content changed (avoid unnecessary recompilations)\n5. Add header comment with generation timestamp and warning not to edit\n\n### Component 6: Template Engine\n- **Purpose:** Manage code generation templates\n- **Interfaces:**\n  - `render_template(template: &str, context: &HashMap<String, String>) -> String`\n- **Dependencies:** None (simple string replacement)\n- **Reuses:** None (new functionality)\n\n**Template Variables:**\n- `{{function_name}}` - FFI function name\n- `{{dart_function_name}}` - Camel case wrapper name\n- `{{parameters}}` - Function parameters\n- `{{return_type}}` - Dart return type\n- `{{error_handling}}` - Error checking code\n- `{{type_conversion}}` - Marshaling code\n\n## Data Models\n\n### DartBinding\n```rust\nstruct DartBinding {\n    native_typedef: String,\n    dart_typedef: String,\n    function_pointer: String,\n    wrapper_function: String,\n}\n```\n\n### DartModel\n```rust\nstruct DartModel {\n    class_name: String,\n    fields: Vec<DartField>,\n    from_json: String,\n    to_json: String,\n}\n\nstruct DartField {\n    name: String,\n    dart_type: String,\n    json_key: String,\n    is_required: bool,\n}\n```\n\n### GenerationContext\n```rust\nstruct GenerationContext {\n    contracts: Vec<FfiContract>,\n    custom_types: HashMap<String, TypeDefinition>,\n    output_dir: PathBuf,\n    verbose: bool,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Contract File Not Found**\n   - **Handling:** Exit with error code 1 and clear message\n   - **User Impact:** `Error: Contract file not found: core/src/ffi/contracts/config.ffi-contract.json`\n\n2. **Invalid Contract JSON**\n   - **Handling:** Exit with error code 1 and JSON parse error\n   - **User Impact:** `Error: Invalid JSON in config.ffi-contract.json: expected '}' at line 45`\n\n3. **Unknown Contract Type**\n   - **Handling:** Exit with error listing unknown types\n   - **User Impact:** `Error: Unknown type 'CustomWidget' in function 'save_widget'. Add type definition to contract.`\n\n4. **Dart Format Failure**\n   - **Handling:** Write unformatted code and warn user\n   - **User Impact:** `Warning: dart format failed. Generated code may not be formatted correctly.`\n\n5. **File Write Permission Error**\n   - **Handling:** Exit with error code 1\n   - **User Impact:** `Error: Permission denied writing to ui/lib/ffi/generated_bindings.dart`\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Type Mapper Tests**: Test contract type to Dart type mappings\n  - Input: Contract type string\n  - Output: Dart FFI type and native type\n  - Cases: All primitive types, custom types, arrays, nullable types\n\n- **Code Generation Tests**: Test template rendering\n  - Input: Function contract\n  - Output: Generated Dart code\n  - Verify: Syntax is valid, types are correct\n\n- **Model Generation Tests**: Test class generation\n  - Input: Type definition\n  - Output: Dart class with fromJson/toJson\n  - Verify: All fields present, JSON keys correct\n\n### Integration Testing\n\n- **End-to-End Generation**: Test full generation pipeline\n  - Create sample contracts\n  - Run generator\n  - Verify output files exist and contain expected code\n  - Run `dart analyze` on generated code\n  - Verify no warnings or errors\n\n- **Roundtrip Testing**: Test JSON serialization\n  - Create Dart object\n  - Serialize to JSON\n  - Deserialize back to object\n  - Verify equality\n\n### End-to-End Testing\n\n- **Build Integration**: Test integration with build system\n  - Modify contract\n  - Run `just build`\n  - Verify bindings regenerated\n  - Verify Flutter compilation succeeds\n\n- **FFI Testing**: Test generated bindings with real Rust FFI\n  - Call generated Dart functions\n  - Verify results are correct\n  - Test error scenarios\n\n## Implementation Phases\n\n### Phase 1: CLI Tool Setup\n1. Create `core/tools/generate_dart_bindings` binary crate\n2. Implement CLI argument parsing\n3. Load contracts from directory\n4. Validate contract structure\n\n### Phase 2: Type Mapping\n1. Implement contract to Dart FFI type mapping\n2. Handle primitives, strings, custom types\n3. Handle nullable types\n4. Unit test all mappings\n\n### Phase 3: Bindings Generation\n1. Generate FFI type definitions\n2. Generate function pointer lookups\n3. Generate wrapper functions\n4. Add error handling\n\n### Phase 4: Models Generation\n1. Extract custom types from contracts\n2. Generate Dart classes\n3. Generate fromJson/toJson methods\n4. Handle nested types\n\n### Phase 5: Integration\n1. Add file writing with dart format\n2. Integrate with justfile build process\n3. Add CI check for up-to-date bindings\n4. Document usage\n\n## Build System Integration\n\n### Justfile Recipe\n```just\n# Generate Dart FFI bindings\ngen-dart-bindings:\n    cargo run --bin generate-dart-bindings\n    @echo \"Dart bindings regenerated\"\n\n# Build with automatic binding generation\nbuild: gen-dart-bindings\n    cd core && cargo build --release\n    cd ui && flutter build linux --release\n\n# Watch mode for development\ndev-ui: gen-dart-bindings\n    cd ui && flutter run -d linux\n```\n\n### Pre-commit Hook\n```bash\n# Check if bindings are up-to-date\ncargo run --bin generate-dart-bindings --check\nif [ $? -ne 0 ]; then\n    echo \"Error: Dart bindings are out of date. Run: just gen-dart-bindings\"\n    exit 1\nfi\n```\n\n### CI Integration\n```yaml\n- name: Check Dart bindings are up-to-date\n  run: |\n    cargo run --bin generate-dart-bindings\n    git diff --exit-code ui/lib/ffi/generated_bindings.dart ui/lib/models/generated_models.dart\n```\n\n## Generated File Headers\n\nAll generated files include a header:\n```dart\n// GENERATED CODE - DO NOT EDIT\n// This file was generated by the Dart binding generator.\n// Generation time: 2025-12-11 10:53:00 UTC\n// Source contracts: core/src/ffi/contracts/*.ffi-contract.json\n//\n// To regenerate: cargo run --bin generate-dart-bindings\n// Or: just gen-dart-bindings\n\n// ignore_for_file: non_constant_identifier_names, unused_element\n```\n\n## Migration Strategy\n\n### Gradual Migration\n1. Generate bindings alongside existing manual bindings\n2. Update one page at a time to use generated bindings\n3. Test thoroughly\n4. Once all pages migrated, remove manual bindings\n5. Make generated bindings the only source\n\n### Compatibility\n- Generated bindings can coexist with manual bindings\n- Use different import paths to avoid conflicts\n- Gradually migrate Flutter pages to use generated bindings\n",
  "fileStats": {
    "size": 14209,
    "lines": 454,
    "lastModified": "2025-12-11T11:15:50.665Z"
  },
  "comments": []
}