{
  "id": "snapshot_1764771456954_1swouq1cs",
  "approvalId": "approval_1764770439625_ogwjl0u77",
  "approvalTitle": "Logging Standardization Design",
  "version": 2,
  "timestamp": "2025-12-03T14:17:36.954Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design standardizes logging across KeyRx using the `tracing` crate with structured output. The core innovation is a `LogBridge` that routes logs and metrics to both file output and FFI callbacks, enabling real-time observability in Flutter. All println/eprintln calls are replaced with structured tracing macros.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Structured Logging**: JSON format with context\n- **Observability**: Metrics available via FFI\n- **Debug Mode**: Verbose logging when enabled\n\n### Project Structure (structure.md)\n- Logging in `core/src/observability/`\n- Metrics in `core/src/observability/metrics/`\n- FFI bridge in `core/src/ffi/exports_observability.rs`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **tracing crate**: Already used in some places\n- **tracing-subscriber**: Log formatting\n- **perf-monitoring spec**: Metrics components\n\n### Integration Points\n- **All modules**: Use tracing macros\n- **FFI**: Export observability\n- **Flutter**: Receive logs and metrics\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Logging Layer\"\n        CODE[Code] --> |tracing!| TR[Tracing]\n        TR --> FMT[Formatter]\n        FMT --> FILE[File Output]\n        FMT --> FFI[FFI Bridge]\n    end\n\n    subgraph \"Metrics Layer\"\n        CODE --> |record| MC[MetricsCollector]\n        MC --> HIST[Histograms]\n        MC --> CNT[Counters]\n        MC --> FFI\n    end\n\n    subgraph \"FFI Bridge\"\n        FFI --> CB[Callbacks]\n        CB --> FL[Flutter UI]\n    end\n```\n\n### Modular Design Principles\n- **Single Pattern**: All logging through tracing\n- **Pluggable Output**: File, FFI, or both\n- **Structured Data**: JSON-serializable logs\n- **Observable**: Metrics visible externally\n\n## Components and Interfaces\n\n### Component 1: StructuredLogger\n\n- **Purpose:** Configure structured logging output\n- **Interfaces:**\n  ```rust\n  /// Configure structured logging for the application.\n  pub struct StructuredLogger {\n      subscriber: tracing_subscriber::Registry,\n      json_output: bool,\n      ffi_bridge: Option<LogBridge>,\n  }\n\n  impl StructuredLogger {\n      pub fn new() -> Self;\n\n      /// Enable JSON output format.\n      pub fn with_json(mut self) -> Self;\n\n      /// Set minimum log level.\n      pub fn with_level(mut self, level: Level) -> Self;\n\n      /// Add file output.\n      pub fn with_file(mut self, path: &Path) -> Self;\n\n      /// Add FFI bridge for Flutter.\n      pub fn with_ffi_bridge(mut self, bridge: LogBridge) -> Self;\n\n      /// Initialize as global logger.\n      pub fn init(self) -> Result<(), LogError>;\n  }\n\n  /// Log level configuration by module.\n  pub struct LogConfig {\n      pub default_level: Level,\n      pub module_levels: HashMap<String, Level>,\n  }\n  ```\n- **Dependencies:** tracing, tracing-subscriber\n- **Reuses:** tracing patterns\n\n### Component 2: LogBridge\n\n- **Purpose:** Bridge logs to FFI for Flutter\n- **Interfaces:**\n  ```rust\n  /// Bridge for sending logs to FFI.\n  pub struct LogBridge {\n      callback: Option<LogCallback>,\n      buffer: Mutex<RingBuffer<LogEntry>>,\n      enabled: AtomicBool,\n  }\n\n  pub type LogCallback = extern \"C\" fn(*const LogEntryFfi);\n\n  impl LogBridge {\n      pub fn new() -> Self;\n\n      /// Set callback for log entries.\n      pub fn set_callback(&self, callback: LogCallback);\n\n      /// Clear callback.\n      pub fn clear_callback(&self);\n\n      /// Get buffered entries (for polling).\n      pub fn drain(&self) -> Vec<LogEntry>;\n\n      /// Enable/disable bridge.\n      pub fn set_enabled(&self, enabled: bool);\n  }\n\n  impl<S: Subscriber> Layer<S> for LogBridge {\n      fn on_event(&self, event: &Event, ctx: Context<S>) {\n          // Convert to LogEntry and send via callback or buffer\n      }\n  }\n\n  #[derive(Debug, Clone, Serialize)]\n  pub struct LogEntry {\n      pub timestamp: u64,\n      pub level: Level,\n      pub target: String,\n      pub message: String,\n      pub fields: HashMap<String, Value>,\n      pub span: Option<String>,\n  }\n\n  #[repr(C)]\n  pub struct LogEntryFfi {\n      pub timestamp: u64,\n      pub level: u8,\n      pub target: *const c_char,\n      pub message: *const c_char,\n      pub fields_json: *const c_char,\n  }\n  ```\n- **Dependencies:** tracing-subscriber\n- **Reuses:** Layer pattern\n\n### Component 3: MetricsBridge\n\n- **Purpose:** Bridge metrics to FFI for Flutter\n- **Interfaces:**\n  ```rust\n  /// Bridge for sending metrics to FFI.\n  pub struct MetricsBridge {\n      collector: Arc<dyn MetricsCollector>,\n      callback: Option<MetricsCallback>,\n      update_interval: Duration,\n  }\n\n  pub type MetricsCallback = extern \"C\" fn(*const MetricsSnapshotFfi);\n\n  impl MetricsBridge {\n      pub fn new(collector: Arc<dyn MetricsCollector>) -> Self;\n\n      /// Set callback for metrics updates.\n      pub fn set_callback(&self, callback: MetricsCallback);\n\n      /// Set update interval for callbacks.\n      pub fn set_interval(&self, interval: Duration);\n\n      /// Get current snapshot.\n      pub fn snapshot(&self) -> MetricsSnapshot;\n\n      /// Start background update thread.\n      pub fn start_updates(&self);\n\n      /// Stop background updates.\n      pub fn stop_updates(&self);\n  }\n\n  #[repr(C)]\n  pub struct MetricsSnapshotFfi {\n      pub timestamp: u64,\n      pub event_latency_p50: u64,\n      pub event_latency_p95: u64,\n      pub event_latency_p99: u64,\n      pub events_processed: u64,\n      pub errors_count: u64,\n      pub memory_used: u64,\n  }\n  ```\n- **Dependencies:** MetricsCollector (from perf-monitoring)\n- **Reuses:** Callback patterns\n\n### Component 4: TracingMacros\n\n- **Purpose:** Convenience macros for common patterns\n- **Interfaces:**\n  ```rust\n  /// Log with structured context.\n  ///\n  /// # Example\n  /// ```rust\n  /// log_event!(Level::INFO, \"key_processed\",\n  ///     key_code = event.key,\n  ///     latency_us = elapsed.as_micros(),\n  /// );\n  /// ```\n  #[macro_export]\n  macro_rules! log_event {\n      ($level:expr, $event:literal, $($field:tt)*) => {\n          tracing::event!($level, event = $event, $($field)*);\n      };\n  }\n\n  /// Log error with context.\n  #[macro_export]\n  macro_rules! log_error {\n      ($err:expr, $context:literal) => {\n          tracing::error!(\n              error = %$err,\n              context = $context,\n              \"Error occurred\"\n          );\n      };\n      ($err:expr, $context:literal, $($field:tt)*) => {\n          tracing::error!(\n              error = %$err,\n              context = $context,\n              $($field)*,\n              \"Error occurred\"\n          );\n      };\n  }\n\n  /// Create a timed span.\n  #[macro_export]\n  macro_rules! timed_span {\n      ($name:literal) => {\n          tracing::info_span!($name)\n      };\n      ($name:literal, $($field:tt)*) => {\n          tracing::info_span!($name, $($field)*)\n      };\n  }\n  ```\n- **Dependencies:** tracing\n- **Reuses:** Macro patterns\n\n### Component 5: PrintlnMigrator\n\n- **Purpose:** Tool to help migrate println calls\n- **Interfaces:**\n  ```rust\n  /// Guide for migrating println/eprintln to tracing.\n  ///\n  /// Before:\n  /// ```rust\n  /// println!(\"Processing key: {}\", key);\n  /// eprintln!(\"Error: {}\", err);\n  /// ```\n  ///\n  /// After:\n  /// ```rust\n  /// tracing::info!(key = %key, \"Processing key\");\n  /// tracing::error!(error = %err, \"Error occurred\");\n  /// ```\n  ///\n  /// Migration rules:\n  /// - println! -> tracing::info! or tracing::debug!\n  /// - eprintln! -> tracing::error! or tracing::warn!\n  /// - dbg! -> tracing::debug! with fields\n  /// - User-facing messages -> keep println but wrap in UI layer\n  ```\n- **Dependencies:** None (documentation)\n- **Reuses:** Migration patterns\n\n### Component 6: FFI Exports\n\n- **Purpose:** Export observability to Flutter\n- **Interfaces:**\n  ```rust\n  /// FFI exports for observability.\n\n  /// Set log callback.\n  #[no_mangle]\n  pub extern \"C\" fn keyrx_set_log_callback(callback: LogCallback) {\n      LOG_BRIDGE.set_callback(callback);\n  }\n\n  /// Set log level.\n  #[no_mangle]\n  pub extern \"C\" fn keyrx_set_log_level(level: u8) -> bool {\n      // Update tracing filter\n  }\n\n  /// Get buffered log entries.\n  #[no_mangle]\n  pub extern \"C\" fn keyrx_drain_logs() -> FfiArray<LogEntryFfi> {\n      LOG_BRIDGE.drain().into_ffi()\n  }\n\n  /// Set metrics callback.\n  #[no_mangle]\n  pub extern \"C\" fn keyrx_set_metrics_callback(callback: MetricsCallback) {\n      METRICS_BRIDGE.set_callback(callback);\n  }\n\n  /// Get metrics snapshot.\n  #[no_mangle]\n  pub extern \"C\" fn keyrx_get_metrics() -> MetricsSnapshotFfi {\n      METRICS_BRIDGE.snapshot().into_ffi()\n  }\n  ```\n- **Dependencies:** LogBridge, MetricsBridge\n- **Reuses:** FFI patterns\n\n## Data Models\n\n### LogLevel Mapping\n```rust\n#[repr(u8)]\npub enum FfiLogLevel {\n    Trace = 0,\n    Debug = 1,\n    Info = 2,\n    Warn = 3,\n    Error = 4,\n}\n\nimpl From<Level> for FfiLogLevel {\n    fn from(level: Level) -> Self {\n        match level {\n            Level::TRACE => Self::Trace,\n            Level::DEBUG => Self::Debug,\n            Level::INFO => Self::Info,\n            Level::WARN => Self::Warn,\n            Level::ERROR => Self::Error,\n        }\n    }\n}\n```\n\n### LogFilter\n```rust\npub struct LogFilter {\n    pub min_level: Level,\n    pub include_targets: Vec<String>,\n    pub exclude_targets: Vec<String>,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Logger initialization fails**\n   - **Handling:** Fall back to stderr\n   - **User Impact:** Logs still work\n\n2. **FFI callback fails**\n   - **Handling:** Buffer entries, log warning\n   - **User Impact:** Some entries may be lost\n\n3. **Log buffer full**\n   - **Handling:** Drop oldest entries\n   - **User Impact:** Oldest logs lost\n\n## Testing Strategy\n\n### Unit Testing\n- Test log formatting\n- Test level filtering\n- Test FFI bridge\n\n### Integration Testing\n- Test full logging pipeline\n- Test metrics collection\n- Test Flutter integration\n\n### Performance Testing\n- Benchmark logging overhead\n- Test under high load\n- Verify disabled logging is zero-cost\n",
  "fileStats": {
    "size": 9942,
    "lines": 398,
    "lastModified": "2025-12-03T14:13:34.686Z"
  },
  "comments": []
}