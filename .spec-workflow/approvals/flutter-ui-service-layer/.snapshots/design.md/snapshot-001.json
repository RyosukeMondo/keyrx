{
  "id": "snapshot_1764538444700_9r7j30c89",
  "approvalId": "approval_1764538444693_l1senijlk",
  "approvalTitle": "Approve design for flutter-ui-service-layer",
  "version": 1,
  "timestamp": "2025-11-30T21:34:04.700Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nIntroduce a Flutter-facing service layer and shared UI primitives so screens no longer talk directly to FFI. Define `PermissionService`, `AudioService`, and `ErrorTranslator` interfaces with real and mock implementations. Extract reusable widgets (error dialog, loading overlay) and container styles. Add lightweight telemetry hooks for start/stop/permission/stream events to aid debugging and analysis.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- No global state: services are injected, FFI stays behind service boundaries.\n- Event-sourcing mindset: UI subscribes to streams via `AudioService`, not manual FFI calls.\n- Dependency injection: services exposed as interfaces; screens depend on abstractions.\n- Observability: trace/log hooks on service calls to support debugging/analysis.\n\n### Project Structure (structure.md)\n- Place services in `ui/lib/services/`.\n- Shared widgets in `ui/lib/ui/widgets/`.\n- Styles in `ui/lib/ui/styles/`.\n- Keep imports layered: UI -> services -> FFI bridge; no UI -> FFI direct.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- Existing FFI bridge in `ui/lib/ffi` for actual Rust calls.\n- Current pages (editor/debugger/console) patterns for routing/state.\n- Existing models for classification results/errors.\n\n### Integration Points\n- Services wrap existing FFI functions (`startAudio`, `stopAudio`, `classificationStream`).\n- PermissionService uses `permission_handler`.\n- ErrorTranslator maps Rust error strings/enums to user-facing messages.\n\n## Architecture\n\nService layer wraps FFI and platform concerns:\n- `PermissionService`: request/check microphone permission, return enum.\n- `AudioService`: start/stop/set BPM, expose `Stream<ClassificationResult>`.\n- `ErrorTranslator`: map engine errors to friendly text + categories.\n- `ServiceRegistry` (simple provider) to inject mocks vs. real.\n\nShared UI:\n- `AppErrorDialog`: standardized error display.\n- `LoadingOverlay`: full-screen blocking overlay.\n- `SurfaceContainer`: styled container helper.\n\nTelemetry:\n- Trace/log in AudioService for start/stop/stream subscribe.\n- Trace/log in PermissionService for outcomes.\n\n### Modular Design Principles\n- Single File Responsibility: one interface/impl per file; widgets isolated.\n- Component Isolation: widgets stateless where possible; services handle side effects.\n- Service Layer Separation: UI calls services; services call FFI.\n- Utility Modularity: styles in a dedicated styles file with constants.\n\n## Components and Interfaces\n\n### PermissionService\n- **Purpose:** Encapsulate microphone permission flow.\n- **Interfaces:** `Future<PermissionResult> requestMicrophone();`\n- **Dependencies:** `permission_handler`.\n- **Reuses:** None; adapters only.\n\n### AudioService\n- **Purpose:** Wrap audio lifecycle + classification stream.\n- **Interfaces:** `Future<void> start(int bpm); Future<void> stop(); Stream<ClassificationResult> stream();`\n- **Dependencies:** FFI bridge; ErrorTranslator; PermissionService (composition).\n- **Reuses:** Existing FFI methods.\n\n### ErrorTranslator\n- **Purpose:** Map Rust errors to user-facing messages and categories.\n- **Interfaces:** `UserMessage translate(Object error);`\n- **Dependencies:** None.\n- **Reuses:** Known Rust error strings/constants.\n\n### Shared Widgets\n- **AppErrorDialog:** `Widget build(BuildContext, String title, String message)`\n- **LoadingOverlay:** `Widget overlay({bool active, Widget child})`\n- **SurfaceContainer:** `Widget surface({Widget child})`\n\n## Data Models\n\n### PermissionResult (enum)\n- `granted | denied | permanentlyDenied | restricted`\n\n### UserMessage\n- `title: String`\n- `body: String`\n- `category: enum { info, warning, error }`\n\n## Error Handling\n\n### Error Scenarios\n1. **Audio start fails (engine busy/device issue)**\n   - **Handling:** AudioService catches, translates via ErrorTranslator, returns failure to UI; UI shows AppErrorDialog.\n   - **User Impact:** Clear message, no crash; state stays idle.\n2. **Permission denied**\n   - **Handling:** PermissionService returns denied; UI shows dialog with guidance; AudioService not invoked.\n   - **User Impact:** No attempt to start audio; actionable copy.\n3. **Stream drops**\n   - **Handling:** AudioService exposes stream errors as translated messages; UI can resubscribe or show toast/dialog.\n   - **User Impact:** User informed; app continues running.\n\n## Testing Strategy\n\n### Unit Testing\n- Service interfaces mocked; real implementations tested with fake FFI/mocks.\n- ErrorTranslator table-driven tests.\n\n### Integration Testing\n- Widget tests: screens using mock services (granted/denied/start fail/start success) ensure dialogs/overlays appear.\n- Stream handling: verify subscription/dispose paths donâ€™t throw.\n\n### End-to-End Testing\n- Happy path: permission granted -> audio start -> stream emits -> UI renders classification.\n- Denied path: permission denied -> no start -> dialog shown.\n- Failure path: start error -> dialog shown -> state reset.\n",
  "fileStats": {
    "size": 4999,
    "lines": 118,
    "lastModified": "2025-11-30T21:33:59.954Z"
  },
  "comments": []
}