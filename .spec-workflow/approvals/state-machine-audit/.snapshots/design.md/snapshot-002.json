{
  "id": "snapshot_1764771446860_6lpmpgswv",
  "approvalId": "approval_1764770436397_sf24crqix",
  "approvalTitle": "State Machine Audit Design",
  "version": 2,
  "timestamp": "2025-12-03T14:17:26.860Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design audits all 15+ state types in KeyRx and creates a unified state management architecture. The core innovation is a `StateGraph` that defines valid transitions with compile-time enforcement, and a `TransitionLog` for debugging and replay. Overlapping state types are consolidated into a clear hierarchy.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **No Global State**: State owned by specific components\n- **Event Sourcing**: Transitions logged for replay\n- **Type Safety**: Invalid transitions caught at compile time\n\n### Project Structure (structure.md)\n- State types in `core/src/engine/state/`\n- Transition graph in `core/src/engine/transitions/`\n- Audit results in `docs/state-audit.md`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **engine-state-unification spec**: Builds on this work\n- **Existing state types**: Refactor, don't rewrite\n- **serde**: State serialization\n\n### Integration Points\n- **Engine**: Uses unified state\n- **FFI**: Exports state snapshots\n- **Debugging**: Uses transition log\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"State Hierarchy\"\n        US[UnifiedState] --> ES[EngineState]\n        US --> RS[RecordingState]\n        US --> DS[DiscoveryState]\n    end\n\n    subgraph \"Transitions\"\n        TR[Transition] --> |validate| SG[StateGraph]\n        SG --> |apply| US\n        SG --> |log| TL[TransitionLog]\n    end\n\n    subgraph \"Validation\"\n        US --> |check| IV[Invariants]\n        IV --> |fail| ER[Error]\n        IV --> |pass| OK[Continue]\n    end\n```\n\n### Modular Design Principles\n- **Explicit Transitions**: All changes through transition enum\n- **Validated Changes**: Invariants checked on every transition\n- **Logged History**: Every transition recorded\n- **Clear Ownership**: Each state type has one owner\n\n## Components and Interfaces\n\n### Component 1: StateInventory (Audit Result)\n\n- **Purpose:** Document all existing state types\n- **Interfaces:**\n  ```rust\n  /// Audit of all state types in codebase.\n  /// This is documentation, not runtime code.\n  pub mod state_inventory {\n      // Engine Domain\n      // - EngineState (advanced.rs) - Serializable snapshot\n      // - EngineState (engine/mod.rs) - Runtime state [DUPLICATE]\n      // - KeyStateTracker - Pressed keys\n      // - ModifierState - Active modifiers\n      // - LayerStack - Layer state\n      // - PendingDecisionQueue - Pending decisions\n\n      // Recording Domain\n      // - RecordingState - Session recording state\n      // - ReplayState - Replay session state\n\n      // Discovery Domain\n      // - DiscoverySessionState - Device discovery state\n\n      // Testing Domain\n      // - MockState - Test mock state\n\n      // FFI Domain\n      // - FfiState - State for FFI export\n\n      // Consolidation Plan:\n      // 1. Merge duplicate EngineState definitions\n      // 2. Extract common SessionState for Recording/Replay\n      // 3. Use composition not inheritance\n  }\n  ```\n- **Dependencies:** None (documentation)\n- **Reuses:** Existing type analysis\n\n### Component 2: StateTransition Enum\n\n- **Purpose:** Explicit enumeration of all valid transitions\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, Clone, Serialize)]\n  pub enum StateTransition {\n      // Engine transitions\n      KeyPressed { key: KeyCode, timestamp: u64 },\n      KeyReleased { key: KeyCode, timestamp: u64 },\n      LayerPushed { layer: LayerId },\n      LayerPopped { layer: LayerId },\n      ModifierActivated { modifier: ModifierId },\n      ModifierDeactivated { modifier: ModifierId },\n      DecisionResolved { id: PendingId, resolution: Resolution },\n\n      // Session transitions\n      RecordingStarted { session_id: String },\n      RecordingStopped,\n      ReplayStarted { session_id: String },\n      ReplayStopped,\n\n      // Discovery transitions\n      DeviceDiscovered { device: DeviceInfo },\n      DeviceLost { device_id: String },\n\n      // System transitions\n      ConfigReloaded,\n      EngineReset,\n      FallbackActivated { reason: String },\n      FallbackDeactivated,\n  }\n\n  impl StateTransition {\n      pub fn timestamp(&self) -> Option<u64>;\n      pub fn category(&self) -> TransitionCategory;\n  }\n\n  #[derive(Debug, Clone, Copy)]\n  pub enum TransitionCategory {\n      Engine,\n      Session,\n      Discovery,\n      System,\n  }\n  ```\n- **Dependencies:** Core types\n- **Reuses:** engine-state-unification Mutation enum\n\n### Component 3: StateGraph\n\n- **Purpose:** Define and enforce valid state transitions\n- **Interfaces:**\n  ```rust\n  pub struct StateGraph {\n      rules: HashMap<(StateKind, TransitionCategory), TransitionRule>,\n  }\n\n  pub struct TransitionRule {\n      pub allowed: bool,\n      pub preconditions: Vec<Precondition>,\n      pub postconditions: Vec<Postcondition>,\n  }\n\n  impl StateGraph {\n      pub fn new() -> Self;\n\n      /// Check if transition is valid\n      pub fn is_valid(&self, from: &UnifiedState, transition: &StateTransition) -> bool;\n\n      /// Apply transition if valid\n      pub fn apply(\n          &self,\n          state: &mut UnifiedState,\n          transition: StateTransition,\n      ) -> Result<TransitionResult, TransitionError>;\n\n      /// Get valid transitions from current state\n      pub fn valid_transitions(&self, state: &UnifiedState) -> Vec<TransitionCategory>;\n  }\n\n  #[derive(Debug)]\n  pub struct TransitionResult {\n      pub transition: StateTransition,\n      pub effects: Vec<StateEffect>,\n      pub duration_micros: u64,\n  }\n\n  #[derive(Debug, thiserror::Error)]\n  pub enum TransitionError {\n      #[error(\"Invalid transition {transition:?} from state {state:?}\")]\n      InvalidTransition {\n          state: StateKind,\n          transition: StateTransition,\n      },\n      #[error(\"Precondition failed: {condition}\")]\n      PreconditionFailed { condition: String },\n      #[error(\"Invariant violated: {invariant}\")]\n      InvariantViolated { invariant: String },\n  }\n  ```\n- **Dependencies:** StateTransition, UnifiedState\n- **Reuses:** State machine patterns\n\n### Component 4: TransitionLog\n\n- **Purpose:** Log all transitions for debugging and replay\n- **Interfaces:**\n  ```rust\n  pub struct TransitionLog {\n      entries: RingBuffer<TransitionEntry>,\n      enabled: AtomicBool,\n  }\n\n  #[derive(Debug, Clone, Serialize)]\n  pub struct TransitionEntry {\n      pub sequence: u64,\n      pub timestamp: u64,\n      pub transition: StateTransition,\n      pub state_before: StateSnapshot,\n      pub state_after: StateSnapshot,\n      pub duration_micros: u64,\n  }\n\n  impl TransitionLog {\n      pub fn new(capacity: usize) -> Self;\n\n      /// Log a transition\n      pub fn log(&self, entry: TransitionEntry);\n\n      /// Get recent entries\n      pub fn recent(&self, count: usize) -> Vec<TransitionEntry>;\n\n      /// Search entries\n      pub fn search(&self, filter: TransitionFilter) -> Vec<TransitionEntry>;\n\n      /// Export for replay\n      pub fn export(&self) -> Vec<TransitionEntry>;\n\n      /// Enable/disable logging\n      pub fn set_enabled(&self, enabled: bool);\n  }\n\n  pub struct TransitionFilter {\n      pub category: Option<TransitionCategory>,\n      pub from_sequence: Option<u64>,\n      pub to_sequence: Option<u64>,\n  }\n  ```\n- **Dependencies:** StateTransition\n- **Reuses:** Ring buffer, logging patterns\n\n### Component 5: StateValidator\n\n- **Purpose:** Validate state invariants\n- **Interfaces:**\n  ```rust\n  pub struct StateValidator {\n      invariants: Vec<Box<dyn Invariant>>,\n  }\n\n  pub trait Invariant: Send + Sync {\n      fn name(&self) -> &str;\n      fn check(&self, state: &UnifiedState) -> Result<(), InvariantViolation>;\n  }\n\n  impl StateValidator {\n      pub fn new() -> Self;\n\n      /// Add an invariant\n      pub fn add<I: Invariant + 'static>(&mut self, invariant: I);\n\n      /// Validate all invariants\n      pub fn validate(&self, state: &UnifiedState) -> Result<(), Vec<InvariantViolation>>;\n\n      /// Validate specific category\n      pub fn validate_category(\n          &self,\n          state: &UnifiedState,\n          category: TransitionCategory,\n      ) -> Result<(), Vec<InvariantViolation>>;\n  }\n\n  #[derive(Debug)]\n  pub struct InvariantViolation {\n      pub invariant: String,\n      pub message: String,\n      pub state_snapshot: StateSnapshot,\n  }\n\n  // Example invariants\n  pub struct NoOrphanedModifiers;\n  pub struct LayerStackNotEmpty;\n  pub struct PendingDecisionsHaveKeys;\n  ```\n- **Dependencies:** UnifiedState, Invariant trait\n- **Reuses:** Validation patterns\n\n## Data Models\n\n### StateKind\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum StateKind {\n    Idle,\n    Processing,\n    Recording,\n    Replaying,\n    Discovering,\n    Fallback,\n}\n```\n\n### StateSnapshot\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct StateSnapshot {\n    pub kind: StateKind,\n    pub pressed_keys: Vec<KeyCode>,\n    pub active_layers: Vec<LayerId>,\n    pub active_modifiers: Vec<ModifierId>,\n    pub pending_count: usize,\n    pub session_id: Option<String>,\n    pub version: u64,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid transition attempted**\n   - **Handling:** Return TransitionError, state unchanged\n   - **User Impact:** Operation rejected with reason\n\n2. **Invariant violated**\n   - **Handling:** Debug: panic; Release: log and recover\n   - **User Impact:** State remains consistent\n\n3. **Log buffer full**\n   - **Handling:** Overwrite oldest entries\n   - **User Impact:** Oldest history lost\n\n## Testing Strategy\n\n### Unit Testing\n- Test each transition type\n- Verify invariant checking\n- Test log operations\n\n### Property Testing\n- Fuzz transition sequences\n- Verify invariants never violated\n- Test state graph completeness\n\n### Integration Testing\n- Test full state machine\n- Verify logging works\n- Test replay from log\n",
  "fileStats": {
    "size": 9725,
    "lines": 359,
    "lastModified": "2025-12-03T14:13:34.694Z"
  },
  "comments": []
}