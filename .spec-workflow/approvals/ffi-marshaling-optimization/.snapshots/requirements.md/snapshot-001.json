{
  "id": "snapshot_1764770437164_ktqvaazec",
  "approvalId": "approval_1764770437127_1dtkq8obq",
  "approvalTitle": "FFI Marshaling Optimization Requirements",
  "version": 1,
  "timestamp": "2025-12-03T14:00:37.164Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nKeyRx's FFI layer has 11 export modules (3,667 LOC) with inconsistent marshaling patterns. Data structures crossing the Rust-Dart boundary repeat serialization logic, error conversion, and JSON handling. This creates maintenance burden, performance overhead, and inconsistency. This spec creates a unified marshaling layer.\n\n## Alignment with Product Vision\n\nThis feature supports KeyRx's product principles:\n- **Performance > Features**: Efficient data transfer to UI\n- **Maintainability**: Consistent marshaling patterns\n- **Developer Experience**: Clear FFI contracts\n\nPer tech.md: \"Clear Interfaces\" for FFI\n\n## Requirements\n\n### Requirement 1: Unified Marshaling Trait\n\n**User Story:** As a developer, I want consistent marshaling, so that FFI data transfer is predictable.\n\n#### Acceptance Criteria\n\n1. WHEN data crosses FFI boundary THEN it SHALL use FfiMarshaler trait\n2. IF a type needs FFI export THEN it SHALL implement the trait\n3. WHEN marshaling fails THEN clear error SHALL be returned\n4. IF type is complex THEN incremental transfer SHALL be possible\n\n### Requirement 2: Error Marshaling\n\n**User Story:** As a developer, I want consistent error passing, so that Flutter handles all errors.\n\n#### Acceptance Criteria\n\n1. WHEN error crosses FFI THEN it SHALL use FfiError type\n2. IF error has code THEN it SHALL be preserved across boundary\n3. WHEN error has context THEN it SHALL be serialized\n4. IF error is internal THEN details SHALL be sanitized\n\n### Requirement 3: Large Data Transfer\n\n**User Story:** As a developer, I want efficient large data transfer, so that recordings don't lag the UI.\n\n#### Acceptance Criteria\n\n1. WHEN data is large (>1MB) THEN streaming SHALL be available\n2. IF shared memory is possible THEN it SHALL be used\n3. WHEN transferring arrays THEN batch encoding SHALL be used\n4. IF transfer fails THEN partial data SHALL be recoverable\n\n### Requirement 4: Callback Consolidation\n\n**User Story:** As a developer, I want unified callbacks, so that event handling is consistent.\n\n#### Acceptance Criteria\n\n1. WHEN events are sent to Flutter THEN single callback pattern SHALL be used\n2. IF multiple event types exist THEN they SHALL share callback infrastructure\n3. WHEN callback is registered THEN type safety SHALL be enforced\n4. IF callback fails THEN fallback SHALL exist\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Marshaling Pattern**: One way to cross FFI\n- **Type Safety**: Compile-time FFI contract verification\n- **Separation of Concerns**: Marshaling separate from business logic\n\n### Performance\n- Marshaling overhead SHALL be < 100 microseconds for typical data\n- Large transfers SHALL not block UI thread\n- Memory copies SHALL be minimized\n\n### Maintainability\n- Adding new FFI type SHALL require < 10 LOC\n- Marshaling code SHALL be generated where possible\n- FFI contracts SHALL be documented\n",
  "fileStats": {
    "size": 2927,
    "lines": 78,
    "lastModified": "2025-12-03T13:58:39.932Z"
  },
  "comments": []
}