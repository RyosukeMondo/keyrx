{
  "id": "snapshot_1764771449923_uqiugyxbu",
  "approvalId": "approval_1764770437476_mi0svpliq",
  "approvalTitle": "FFI Marshaling Optimization Design",
  "version": 2,
  "timestamp": "2025-12-03T14:17:29.923Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design creates a unified FFI marshaling layer using the `FfiMarshaler` trait and procedural macros for automatic implementation. The core innovation is a two-tier system: fast C-compatible structs for small/frequent data, and JSON streaming for large/complex data. All error handling flows through `FfiResult<T>`.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Clear Interfaces**: Unified marshaling trait\n- **Performance**: Zero-copy where possible\n- **Error Handling**: Consistent FFI error propagation\n\n### Project Structure (structure.md)\n- Marshaling in `core/src/ffi/marshal/`\n- Traits in `core/src/ffi/marshal/traits.rs`\n- Implementations in `core/src/ffi/marshal/impls/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **ffi-architecture-overhaul spec**: Builds on this\n- **serde**: JSON serialization\n- **cbindgen**: C header generation\n\n### Integration Points\n- **All FFI exports**: Use marshaling layer\n- **Flutter**: Receives marshaled data\n- **Error system**: Uses FfiError\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Rust Side\"\n        RS[Rust Types] --> |marshal| FM[FfiMarshaler]\n        FM --> |small| CS[C Struct]\n        FM --> |large| JSON[JSON Stream]\n    end\n\n    subgraph \"FFI Boundary\"\n        CS --> FFI[FFI Call]\n        JSON --> FFI\n        FFI --> |error| FE[FfiError]\n    end\n\n    subgraph \"Dart Side\"\n        FFI --> DM[DartMarshaler]\n        DM --> DT[Dart Types]\n        FE --> DE[Dart Error]\n    end\n```\n\n### Modular Design Principles\n- **Trait-Based**: All marshaling through FfiMarshaler\n- **Size-Aware**: Different strategies for different sizes\n- **Error-First**: All operations return FfiResult\n- **Generated**: Derive macros for common cases\n\n## Components and Interfaces\n\n### Component 1: FfiMarshaler Trait\n\n- **Purpose:** Unified interface for FFI data transfer\n- **Interfaces:**\n  ```rust\n  /// Trait for types that can cross FFI boundary.\n  pub trait FfiMarshaler: Sized {\n      /// The C-compatible representation.\n      type CRepr: CRepr;\n\n      /// Convert to C representation.\n      fn to_c(&self) -> FfiResult<Self::CRepr>;\n\n      /// Convert from C representation.\n      fn from_c(c: Self::CRepr) -> FfiResult<Self>;\n\n      /// Estimated size for buffer allocation.\n      fn estimated_size(&self) -> usize;\n\n      /// Whether to use streaming for this instance.\n      fn use_streaming(&self) -> bool {\n          self.estimated_size() > STREAMING_THRESHOLD\n      }\n  }\n\n  /// Marker trait for C-compatible types.\n  pub trait CRepr: Copy + Send + 'static {}\n\n  /// Streaming marshaler for large data.\n  pub trait FfiStreamMarshaler: Sized {\n      type Chunk: CRepr;\n\n      fn chunk_count(&self) -> usize;\n      fn get_chunk(&self, index: usize) -> FfiResult<Self::Chunk>;\n      fn from_chunks(chunks: &[Self::Chunk]) -> FfiResult<Self>;\n  }\n\n  const STREAMING_THRESHOLD: usize = 1024 * 1024; // 1MB\n  ```\n- **Dependencies:** None\n- **Reuses:** Trait patterns\n\n### Component 2: FfiResult Type\n\n- **Purpose:** Result type for FFI operations\n- **Interfaces:**\n  ```rust\n  /// FFI-safe result type.\n  #[repr(C)]\n  pub struct FfiResult<T: CRepr> {\n      success: bool,\n      value: MaybeUninit<T>,\n      error: FfiErrorPtr,\n  }\n\n  impl<T: CRepr> FfiResult<T> {\n      pub fn ok(value: T) -> Self;\n      pub fn err(error: FfiError) -> Self;\n\n      pub fn is_ok(&self) -> bool;\n      pub fn into_result(self) -> Result<T, FfiError>;\n  }\n\n  /// C-compatible error pointer.\n  #[repr(C)]\n  pub struct FfiErrorPtr {\n      ptr: *const FfiErrorData,\n  }\n\n  #[repr(C)]\n  pub struct FfiErrorData {\n      code: u32,\n      message: *const c_char,\n      hint: *const c_char,\n      context: *const c_char,\n  }\n  ```\n- **Dependencies:** FfiError\n- **Reuses:** Result patterns\n\n### Component 3: FfiError\n\n- **Purpose:** FFI-safe error type\n- **Interfaces:**\n  ```rust\n  /// Error type for FFI boundary.\n  #[derive(Debug)]\n  pub struct FfiError {\n      code: u32,\n      message: String,\n      hint: Option<String>,\n      context: Option<String>,\n  }\n\n  impl FfiError {\n      pub fn new(code: u32, message: impl Into<String>) -> Self;\n      pub fn with_hint(self, hint: impl Into<String>) -> Self;\n      pub fn with_context(self, context: impl Into<String>) -> Self;\n\n      /// Convert to C representation (allocates).\n      pub fn to_c(&self) -> FfiErrorData;\n\n      /// Free C representation.\n      pub unsafe fn free_c(data: FfiErrorData);\n\n      /// Create from any error.\n      pub fn from_error<E: std::error::Error>(e: E) -> Self;\n  }\n\n  impl From<CriticalError> for FfiError {\n      fn from(e: CriticalError) -> Self { ... }\n  }\n\n  impl From<anyhow::Error> for FfiError {\n      fn from(e: anyhow::Error) -> Self { ... }\n  }\n  ```\n- **Dependencies:** error-code-registry (if available)\n- **Reuses:** Error conversion patterns\n\n### Component 4: Common Marshalers\n\n- **Purpose:** Pre-built marshalers for common types\n- **Interfaces:**\n  ```rust\n  // Primitive types - direct C repr\n  impl FfiMarshaler for u8 { type CRepr = u8; ... }\n  impl FfiMarshaler for u16 { type CRepr = u16; ... }\n  impl FfiMarshaler for u32 { type CRepr = u32; ... }\n  impl FfiMarshaler for u64 { type CRepr = u64; ... }\n  impl FfiMarshaler for bool { type CRepr = u8; ... }\n\n  // Strings - null-terminated C strings\n  impl FfiMarshaler for String {\n      type CRepr = *const c_char;\n      ...\n  }\n\n  // Arrays - length-prefixed\n  impl<T: FfiMarshaler> FfiMarshaler for Vec<T>\n  where\n      T::CRepr: CRepr,\n  {\n      type CRepr = FfiArray<T::CRepr>;\n      ...\n  }\n\n  #[repr(C)]\n  pub struct FfiArray<T: CRepr> {\n      data: *const T,\n      len: usize,\n      capacity: usize,\n  }\n\n  // JSON fallback for complex types\n  impl<T: Serialize + DeserializeOwned> FfiMarshaler for JsonWrapper<T> {\n      type CRepr = *const c_char; // JSON string\n      ...\n  }\n  ```\n- **Dependencies:** serde\n- **Reuses:** Type conversion patterns\n\n### Component 5: Derive Macro\n\n- **Purpose:** Auto-generate FfiMarshaler implementations\n- **Interfaces:**\n  ```rust\n  /// Derive FfiMarshaler for structs.\n  ///\n  /// # Example\n  /// ```rust\n  /// #[derive(FfiMarshaler)]\n  /// #[ffi(strategy = \"json\")] // or \"c_struct\" or \"auto\"\n  /// pub struct KeyEvent {\n  ///     pub key: KeyCode,\n  ///     pub pressed: bool,\n  ///     pub timestamp: u64,\n  /// }\n  /// ```\n  #[proc_macro_derive(FfiMarshaler, attributes(ffi))]\n  pub fn derive_ffi_marshaler(input: TokenStream) -> TokenStream;\n  ```\n- **Dependencies:** proc-macro2, syn, quote\n- **Reuses:** Derive macro patterns\n\n### Component 6: Callback Registry\n\n- **Purpose:** Unified callback management\n- **Interfaces:**\n  ```rust\n  /// Registry for FFI callbacks.\n  pub struct CallbackRegistry {\n      callbacks: DashMap<CallbackId, Box<dyn FfiCallback>>,\n      next_id: AtomicU64,\n  }\n\n  pub trait FfiCallback: Send + Sync {\n      fn invoke(&self, data: &[u8]) -> FfiResult<()>;\n      fn callback_type(&self) -> &'static str;\n  }\n\n  impl CallbackRegistry {\n      pub fn global() -> &'static Self;\n\n      /// Register a callback, returns ID.\n      pub fn register<C: FfiCallback + 'static>(&self, callback: C) -> CallbackId;\n\n      /// Unregister a callback.\n      pub fn unregister(&self, id: CallbackId) -> bool;\n\n      /// Invoke callback by ID.\n      pub fn invoke(&self, id: CallbackId, data: &[u8]) -> FfiResult<()>;\n  }\n\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct CallbackId(u64);\n  ```\n- **Dependencies:** dashmap\n- **Reuses:** Registry patterns\n\n## Data Models\n\n### FfiArray\n```rust\n#[repr(C)]\npub struct FfiArray<T: CRepr> {\n    pub data: *const T,\n    pub len: usize,\n    pub capacity: usize,\n}\n\nimpl<T: CRepr> FfiArray<T> {\n    pub fn from_vec(v: Vec<T>) -> Self;\n    pub unsafe fn into_vec(self) -> Vec<T>;\n    pub unsafe fn free(self);\n}\n```\n\n### FfiString\n```rust\n#[repr(C)]\npub struct FfiString {\n    pub data: *const c_char,\n    pub len: usize,\n}\n\nimpl FfiString {\n    pub fn from_str(s: &str) -> Self;\n    pub unsafe fn to_string(&self) -> String;\n    pub unsafe fn free(self);\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Marshaling fails**\n   - **Handling:** Return FfiResult::err with details\n   - **User Impact:** Flutter receives error\n\n2. **Memory allocation fails**\n   - **Handling:** Return null pointer with error\n   - **User Impact:** Graceful failure\n\n3. **Invalid callback ID**\n   - **Handling:** Return error, log warning\n   - **User Impact:** Callback silently fails\n\n## Testing Strategy\n\n### Unit Testing\n- Test each marshaler\n- Test round-trip conversion\n- Test error propagation\n\n### Integration Testing\n- Test FFI boundary crossing\n- Test callback invocation\n- Test large data streaming\n\n### Memory Testing\n- Verify no leaks\n- Test allocation failure\n- Verify proper cleanup\n",
  "fileStats": {
    "size": 8755,
    "lines": 348,
    "lastModified": "2025-12-03T14:13:34.685Z"
  },
  "comments": []
}