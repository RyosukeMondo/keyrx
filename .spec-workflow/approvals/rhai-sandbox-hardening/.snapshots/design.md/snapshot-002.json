{
  "id": "snapshot_1764771453276_hkw8ugn02",
  "approvalId": "approval_1764770438546_sp5e12k8b",
  "approvalTitle": "Rhai Sandbox Hardening Design",
  "version": 2,
  "timestamp": "2025-12-03T14:17:33.276Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design creates a hardened Rhai sandbox with resource limits, capability tiers, and O(1) registry lookup. The core innovation is the `ScriptCapability` system that assigns tiers to functions at compile time, and the `ResourceBudget` that tracks runtime resource consumption. All function calls go through a validation layer.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Security**: No privilege escalation, resource limits\n- **Performance**: O(1) lookup, minimal validation overhead\n- **Error Handling**: Clear validation errors\n\n### Project Structure (structure.md)\n- Sandbox in `core/src/scripting/sandbox/`\n- Capabilities in `core/src/scripting/capabilities/`\n- Validation in `core/src/scripting/validation/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **Rhai Engine**: Built-in limits configuration\n- **Existing bindings**: Wrap with validation\n- **Error types**: Extend for validation errors\n\n### Integration Points\n- **Rhai registration**: Add capability metadata\n- **Function calls**: Validate through sandbox\n- **Engine**: Configure limits\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Script Execution\"\n        SC[Script Call] --> |validate| VL[Validation Layer]\n        VL --> |check| CAP[Capability Check]\n        CAP --> |allowed| REG[Registry Lookup]\n        REG --> |O(1)| FN[Function]\n    end\n\n    subgraph \"Resource Management\"\n        FN --> |track| RB[ResourceBudget]\n        RB --> |exceeded| TERM[Terminate]\n        RB --> |ok| EXEC[Execute]\n    end\n\n    subgraph \"Capability System\"\n        CAP --> TIER[Capability Tier]\n        TIER --> SAFE[Safe Mode]\n        TIER --> STD[Standard Mode]\n        TIER --> ADV[Advanced Mode]\n    end\n```\n\n### Modular Design Principles\n- **Defense in Depth**: Multiple safety layers\n- **Fail Closed**: Reject on any doubt\n- **Observable**: All rejections logged\n- **Performant**: Minimal overhead\n\n## Components and Interfaces\n\n### Component 1: ScriptCapability\n\n- **Purpose:** Categorize function security tiers\n- **Interfaces:**\n  ```rust\n  /// Capability tier for script functions.\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n  pub enum ScriptCapability {\n      /// Safe for any script - no side effects, bounded execution.\n      Safe = 0,\n      /// Standard operations - may affect engine state.\n      Standard = 1,\n      /// Advanced operations - system interaction, requires trust.\n      Advanced = 2,\n      /// Internal only - not exposed to user scripts.\n      Internal = 3,\n  }\n\n  impl ScriptCapability {\n      /// Check if this capability is allowed in given mode.\n      pub fn is_allowed_in(&self, mode: ScriptMode) -> bool;\n\n      /// Get human-readable description.\n      pub fn description(&self) -> &'static str;\n  }\n\n  #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n  pub enum ScriptMode {\n      Safe,      // Only Safe tier\n      Standard,  // Safe + Standard tiers\n      Full,      // All tiers except Internal\n  }\n  ```\n- **Dependencies:** None\n- **Reuses:** Enum patterns\n\n### Component 2: ResourceBudget\n\n- **Purpose:** Track and limit resource consumption\n- **Interfaces:**\n  ```rust\n  /// Resource budget for script execution.\n  pub struct ResourceBudget {\n      instruction_limit: u64,\n      instruction_count: AtomicU64,\n      recursion_limit: u32,\n      recursion_depth: AtomicU32,\n      memory_limit: usize,\n      memory_used: AtomicUsize,\n      timeout: Duration,\n      start_time: Instant,\n  }\n\n  impl ResourceBudget {\n      pub fn new(config: ResourceConfig) -> Self;\n\n      /// Check if instruction budget exhausted.\n      pub fn check_instructions(&self) -> Result<(), ResourceExhausted>;\n\n      /// Increment instruction count.\n      pub fn increment_instructions(&self, count: u64) -> Result<(), ResourceExhausted>;\n\n      /// Enter recursion level.\n      pub fn enter_recursion(&self) -> Result<RecursionGuard, ResourceExhausted>;\n\n      /// Allocate memory.\n      pub fn allocate(&self, bytes: usize) -> Result<(), ResourceExhausted>;\n\n      /// Check timeout.\n      pub fn check_timeout(&self) -> Result<(), ResourceExhausted>;\n\n      /// Get current usage.\n      pub fn usage(&self) -> ResourceUsage;\n  }\n\n  pub struct ResourceConfig {\n      pub max_instructions: u64,\n      pub max_recursion: u32,\n      pub max_memory: usize,\n      pub timeout: Duration,\n  }\n\n  impl Default for ResourceConfig {\n      fn default() -> Self {\n          Self {\n              max_instructions: 100_000,\n              max_recursion: 64,\n              max_memory: 1024 * 1024, // 1MB\n              timeout: Duration::from_millis(100),\n          }\n      }\n  }\n\n  #[derive(Debug, thiserror::Error)]\n  pub enum ResourceExhausted {\n      #[error(\"Instruction limit exceeded ({count}/{limit})\")]\n      Instructions { count: u64, limit: u64 },\n      #[error(\"Recursion limit exceeded ({depth}/{limit})\")]\n      Recursion { depth: u32, limit: u32 },\n      #[error(\"Memory limit exceeded ({used}/{limit} bytes)\")]\n      Memory { used: usize, limit: usize },\n      #[error(\"Script timeout ({elapsed:?}/{timeout:?})\")]\n      Timeout { elapsed: Duration, timeout: Duration },\n  }\n  ```\n- **Dependencies:** std::sync::atomic\n- **Reuses:** Resource tracking patterns\n\n### Component 3: CapabilityRegistry\n\n- **Purpose:** O(1) lookup of function capabilities\n- **Interfaces:**\n  ```rust\n  /// Registry mapping functions to capabilities.\n  pub struct CapabilityRegistry {\n      by_name: HashMap<String, FunctionCapability>,\n      by_keycode: HashMap<KeyCode, Vec<FunctionCapability>>,\n  }\n\n  #[derive(Debug, Clone)]\n  pub struct FunctionCapability {\n      pub name: String,\n      pub capability: ScriptCapability,\n      pub validator: Option<Box<dyn InputValidator>>,\n      pub description: String,\n  }\n\n  impl CapabilityRegistry {\n      pub fn new() -> Self;\n\n      /// Register a function with capability.\n      pub fn register(&mut self, cap: FunctionCapability);\n\n      /// Get capability for function name - O(1).\n      pub fn get(&self, name: &str) -> Option<&FunctionCapability>;\n\n      /// Get functions for KeyCode - O(1).\n      pub fn for_keycode(&self, key: KeyCode) -> &[FunctionCapability];\n\n      /// Check if function is allowed in mode.\n      pub fn is_allowed(&self, name: &str, mode: ScriptMode) -> bool;\n\n      /// Get all functions for capability tier.\n      pub fn by_tier(&self, tier: ScriptCapability) -> Vec<&FunctionCapability>;\n  }\n  ```\n- **Dependencies:** HashMap\n- **Reuses:** Registry patterns\n\n### Component 4: InputValidator\n\n- **Purpose:** Validate function inputs\n- **Interfaces:**\n  ```rust\n  /// Trait for input validation.\n  pub trait InputValidator: Send + Sync {\n      fn validate(&self, args: &[Dynamic]) -> Result<(), ValidationError>;\n  }\n\n  #[derive(Debug, thiserror::Error)]\n  pub enum ValidationError {\n      #[error(\"Wrong number of arguments: expected {expected}, got {got}\")]\n      WrongArgCount { expected: usize, got: usize },\n      #[error(\"Invalid argument type at position {position}: expected {expected}, got {got}\")]\n      InvalidType { position: usize, expected: String, got: String },\n      #[error(\"Invalid value at position {position}: {message}\")]\n      InvalidValue { position: usize, message: String },\n      #[error(\"Validation failed: {message}\")]\n      Custom { message: String },\n  }\n\n  /// Common validators\n  pub struct RangeValidator {\n      pub position: usize,\n      pub min: i64,\n      pub max: i64,\n  }\n\n  pub struct TypeValidator {\n      pub expected_types: Vec<(&'static str, TypeId)>,\n  }\n\n  pub struct KeyCodeValidator;\n\n  impl InputValidator for RangeValidator { ... }\n  impl InputValidator for TypeValidator { ... }\n  impl InputValidator for KeyCodeValidator { ... }\n  ```\n- **Dependencies:** rhai::Dynamic\n- **Reuses:** Validation patterns\n\n### Component 5: ScriptSandbox\n\n- **Purpose:** Unified sandbox for script execution\n- **Interfaces:**\n  ```rust\n  /// Sandboxed script execution environment.\n  pub struct ScriptSandbox {\n      engine: Engine,\n      capabilities: CapabilityRegistry,\n      mode: ScriptMode,\n      resource_config: ResourceConfig,\n  }\n\n  impl ScriptSandbox {\n      pub fn new(mode: ScriptMode) -> Self;\n\n      /// Configure resource limits.\n      pub fn with_resources(mut self, config: ResourceConfig) -> Self;\n\n      /// Register a function with capability.\n      pub fn register_fn<A, R, F>(&mut self, name: &str, cap: ScriptCapability, f: F)\n      where\n          F: Fn(A) -> R + Send + Sync + 'static;\n\n      /// Execute script with sandbox.\n      pub fn execute(&self, script: &str) -> Result<Dynamic, ScriptError>;\n\n      /// Execute function call with validation.\n      pub fn call_fn(\n          &self,\n          name: &str,\n          args: &[Dynamic],\n      ) -> Result<Dynamic, ScriptError>;\n  }\n\n  #[derive(Debug, thiserror::Error)]\n  pub enum ScriptError {\n      #[error(\"Capability denied: {function} requires {required:?}, mode is {mode:?}\")]\n      CapabilityDenied {\n          function: String,\n          required: ScriptCapability,\n          mode: ScriptMode,\n      },\n      #[error(\"Resource exhausted: {0}\")]\n      ResourceExhausted(#[from] ResourceExhausted),\n      #[error(\"Validation failed: {0}\")]\n      ValidationFailed(#[from] ValidationError),\n      #[error(\"Execution error: {0}\")]\n      Execution(#[from] Box<rhai::EvalAltResult>),\n  }\n  ```\n- **Dependencies:** Rhai, CapabilityRegistry, ResourceBudget\n- **Reuses:** Sandbox patterns\n\n## Data Models\n\n### ResourceUsage\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct ResourceUsage {\n    pub instructions: u64,\n    pub max_instructions: u64,\n    pub recursion_depth: u32,\n    pub max_recursion: u32,\n    pub memory_used: usize,\n    pub max_memory: usize,\n    pub elapsed: Duration,\n    pub timeout: Duration,\n}\n```\n\n### ScriptMetrics\n```rust\n#[derive(Debug, Clone, Serialize)]\npub struct ScriptMetrics {\n    pub calls: u64,\n    pub errors: u64,\n    pub capability_denials: u64,\n    pub resource_exhaustions: u64,\n    pub avg_execution_time: Duration,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Capability denied**\n   - **Handling:** Return ScriptError::CapabilityDenied\n   - **User Impact:** Script fails with clear message\n\n2. **Resource exhausted**\n   - **Handling:** Terminate script, return error\n   - **User Impact:** Script stops, key passes through\n\n3. **Invalid input**\n   - **Handling:** Return validation error\n   - **User Impact:** Script fails with helpful message\n\n## Testing Strategy\n\n### Unit Testing\n- Test each capability tier\n- Test resource limits\n- Test validation rules\n\n### Fuzz Testing\n- Fuzz script inputs\n- Test resource exhaustion\n- Test capability bypass attempts\n\n### Performance Testing\n- Benchmark registry lookup\n- Measure validation overhead\n- Test under load\n",
  "fileStats": {
    "size": 10752,
    "lines": 370,
    "lastModified": "2025-12-03T14:13:34.692Z"
  },
  "comments": []
}