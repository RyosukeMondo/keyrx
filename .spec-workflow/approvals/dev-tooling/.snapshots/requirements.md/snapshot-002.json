{
  "id": "snapshot_1764461327799_sb13a2r79",
  "approvalId": "approval_1764461077500_d8pzyy5rq",
  "approvalTitle": "Dev-Tooling Requirements Document",
  "version": 2,
  "timestamp": "2025-11-30T00:08:47.799Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document: dev-tooling\n\n## Introduction\n\nThis specification establishes development tooling infrastructure for KeyRx to ensure code quality, enable rapid iteration, and support autonomous AI-driven development. It addresses critical gaps in CI/CD, error handling patterns, documentation, and testing infrastructure identified during MVP review.\n\n## Alignment with Product Vision\n\nFrom product.md principles:\n- **CLI First, GUI Later**: Robust CLI tooling enables AI agent autonomy\n- **Performance > Features**: CI gates prevent performance regressions\n- **Safety First**: Pre-commit hooks catch issues before they reach production\n\nFrom CLAUDE.md requirements:\n- Pre-commit hooks mandatory (linting, formatting, tests)\n- 80% test coverage minimum\n- Structured logging with JSON format\n- Custom exception hierarchy with error codes\n\n## Requirements\n\n### REQ-1: Pre-Commit Hooks\n\n**User Story:** As a developer, I want automated code quality checks before each commit, so that bad code never enters the repository.\n\n#### Acceptance Criteria\n\n1. WHEN a developer runs `git commit` THEN rustfmt SHALL check formatting automatically\n2. WHEN formatting check fails THEN the commit SHALL be blocked with clear error message\n3. WHEN a developer runs `git commit` THEN clippy SHALL run with `-D warnings` (deny warnings)\n4. WHEN clippy finds issues THEN the commit SHALL be blocked with actionable fixes\n5. WHEN a developer runs `git commit` THEN `cargo test` SHALL run for affected code\n6. IF any pre-commit check fails THEN exit code SHALL be non-zero\n7. WHEN hooks are installed THEN `cargo fmt --check && cargo clippy && cargo test` SHALL pass\n\n### REQ-2: CI/CD Pipeline\n\n**User Story:** As a maintainer, I want automated builds and tests on every PR, so that broken code is caught before merge.\n\n#### Acceptance Criteria\n\n1. WHEN a PR is opened THEN GitHub Actions SHALL trigger build workflow\n2. WHEN CI runs THEN it SHALL build for both Linux and Windows targets\n3. WHEN CI runs THEN it SHALL execute all tests with `cargo test`\n4. WHEN CI runs THEN it SHALL run `cargo clippy -D warnings`\n5. WHEN CI runs THEN it SHALL verify formatting with `cargo fmt --check`\n6. WHEN any CI check fails THEN the PR SHALL be marked as failing\n7. WHEN CI completes THEN build artifacts SHALL be available for download\n8. WHEN CI runs THEN it SHALL run on Rust stable and check MSRV (1.70+)\n\n### REQ-3: Error Propagation\n\n**User Story:** As a developer, I want all errors to propagate properly, so that I can debug issues without silent failures.\n\n#### Acceptance Criteria\n\n1. WHEN a Rhai function receives invalid key name THEN it SHALL return an error (not log and ignore)\n2. WHEN a CLI command fails THEN it SHALL return `Result::Err` (not call `std::process::exit`)\n3. WHEN `RhaiRuntime::default()` cannot initialize THEN it SHALL NOT panic\n4. WHEN any function encounters an error THEN it SHALL propagate via `Result<T, E>`\n5. WHEN errors are logged THEN they SHALL include context (file, line, operation)\n6. IF a recoverable error occurs THEN the system SHALL continue operating\n7. WHEN `path.to_str()` fails THEN clear error message SHALL be returned (not empty string)\n\n### REQ-4: Scripting API Documentation\n\n**User Story:** As an AI agent, I want comprehensive scripting documentation, so that I can write and validate Rhai scripts autonomously.\n\n#### Acceptance Criteria\n\n1. WHEN documentation is complete THEN all public Rhai functions SHALL be documented\n2. WHEN reading docs THEN `remap(from, to)` behavior and error cases SHALL be clear\n3. WHEN reading docs THEN `block(key)` behavior and error cases SHALL be clear\n4. WHEN reading docs THEN `pass(key)` behavior and error cases SHALL be clear\n5. WHEN reading docs THEN all valid key names SHALL be listed with aliases\n6. WHEN reading docs THEN hook lifecycle (`on_init`, etc.) SHALL be explained\n7. WHEN reading docs THEN error handling expectations SHALL be documented\n8. WHEN documentation is complete THEN example scripts SHALL demonstrate all features\n\n### REQ-5: Mock Infrastructure\n\n**User Story:** As a developer, I want comprehensive mock implementations, so that I can test all code paths including errors.\n\n#### Acceptance Criteria\n\n1. WHEN using MockInput THEN I SHALL be able to configure error responses\n2. WHEN using MockRuntime THEN I SHALL be able to verify which methods were called\n3. WHEN using MockState THEN I SHALL be able to track mutation history\n4. WHEN testing error paths THEN mocks SHALL support configurable failure modes\n5. WHEN asserting behavior THEN mocks SHALL provide call history inspection\n6. WHEN mocks are used THEN they SHALL implement the same trait bounds as production code\n\n### REQ-6: Code Quality Configuration\n\n**User Story:** As a developer, I want consistent code style enforcement, so that the codebase remains maintainable.\n\n#### Acceptance Criteria\n\n1. WHEN `rustfmt.toml` exists THEN it SHALL define project formatting rules\n2. WHEN `.clippy.toml` exists THEN it SHALL configure lint levels\n3. WHEN `Cargo.toml` is configured THEN dev profile SHALL optimize for fast iteration\n4. WHEN lints are configured THEN `unsafe` code SHALL require explicit justification\n5. WHEN code is formatted THEN max line width SHALL be 100 characters\n6. WHEN imports are formatted THEN they SHALL follow Rust standard ordering\n\n### REQ-7: Thread Safety Cleanup\n\n**User Story:** As a developer, I want clear thread safety guarantees, so that async code behaves predictably.\n\n#### Acceptance Criteria\n\n1. WHEN `RhaiRuntime` is refactored THEN `Rc<RefCell>` SHALL be replaced with owned or `Arc<Mutex>`\n2. WHEN traits require `Send` THEN implementations SHALL be thread-safe\n3. WHEN documentation exists THEN thread safety guarantees SHALL be explicit\n4. IF interior mutability is needed THEN `Arc<Mutex>` or `Arc<RwLock>` SHALL be used\n5. WHEN borrowing patterns exist THEN they SHALL NOT be able to panic at runtime\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- All error types implement `std::error::Error`\n- Error context preserved through `anyhow::Context`\n- No `unwrap()` or `expect()` in production code paths\n\n### Performance\n- Pre-commit hooks complete in < 30 seconds\n- CI pipeline completes in < 10 minutes\n- No performance regression from error handling changes\n\n### Reliability\n- Zero panics from error handling code\n- All CI checks reproducible locally\n- Hooks work on Linux, macOS, and Windows\n\n### Maintainability\n- Single source of truth for lint configuration\n- Documentation generated from source where possible\n- Hooks installable via single command\n",
  "fileStats": {
    "size": 6588,
    "lines": 139,
    "lastModified": "2025-11-30T00:01:59.024Z"
  },
  "comments": []
}