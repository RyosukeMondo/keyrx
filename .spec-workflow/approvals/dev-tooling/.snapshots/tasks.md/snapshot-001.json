{
  "id": "snapshot_1764461077621_1df78thbi",
  "approvalId": "approval_1764461077619_y5z0ilobb",
  "approvalTitle": "Dev-Tooling Tasks Document",
  "version": 1,
  "timestamp": "2025-11-30T00:04:37.621Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document: dev-tooling\n\n## Task 1: Create Configuration Files\n\n- [ ] 1.1 Create rustfmt.toml\n  - File: `rustfmt.toml` (repository root)\n  - Configure: max_width=100, edition=2021, imports_granularity=Crate\n  - Enable: format_code_in_doc_comments, format_strings\n  - Purpose: Consistent code formatting across team\n  - _Requirements: REQ-6_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust DevOps Engineer | Task: Create rustfmt.toml at repository root with max_width=100, edition=\"2021\", imports_granularity=\"Crate\", format_code_in_doc_comments=true, format_strings=true, group_imports=\"StdExternalCrate\" | Restrictions: Use only stable rustfmt options, no nightly-only features | Success: cargo fmt --check passes without changes needed. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 1.2 Create clippy.toml\n  - File: `clippy.toml` (repository root)\n  - Configure: cognitive-complexity-threshold=25, too-many-arguments-threshold=7\n  - Purpose: Consistent lint levels\n  - _Requirements: REQ-6_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust DevOps Engineer | Task: Create clippy.toml with cognitive-complexity-threshold=25, too-many-arguments-threshold=7, type-complexity-threshold=250 | Restrictions: Only use stable clippy configuration options | Success: cargo clippy uses the configuration. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 1.3 Update Cargo.toml with dev profile\n  - File: `core/Cargo.toml`\n  - Add [profile.dev] with opt-level=0, debug=true\n  - Add [profile.dev.package.\"*\"] with opt-level=2 for faster deps\n  - Add [lints.rust] and [lints.clippy] sections\n  - Purpose: Fast iteration builds\n  - _Requirements: REQ-6_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust DevOps Engineer | Task: Update core/Cargo.toml to add [profile.dev] with opt-level=0, debug=true. Add [profile.dev.package.\"*\"] with opt-level=2. Add [lints.rust] with unsafe_code=\"warn\". Add [lints.clippy] with unwrap_used=\"warn\", expect_used=\"warn\", panic=\"warn\" | Restrictions: Keep existing dependencies unchanged | Success: cargo build uses optimized profile. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 2: Pre-commit Hooks\n\n- [ ] 2.1 Create install-hooks script\n  - File: `scripts/install-hooks.sh`\n  - Create script that copies .githooks/* to .git/hooks/\n  - Make executable and cross-platform (bash)\n  - Print success message with hook list\n  - Purpose: One-command hook installation\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer | Task: Create scripts/install-hooks.sh that: 1) Creates .git/hooks if missing, 2) Copies all files from .githooks/ to .git/hooks/, 3) Makes them executable with chmod +x, 4) Prints \"Hooks installed: pre-commit\". Use bash shebang, handle errors gracefully | Restrictions: No external dependencies beyond bash, support Linux/macOS | Success: Running ./scripts/install-hooks.sh installs hooks successfully. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 2.2 Create pre-commit hook\n  - File: `.githooks/pre-commit`\n  - Run: cargo fmt --check (fail fast)\n  - Run: cargo clippy -- -D warnings (deny warnings)\n  - Run: cargo test --lib (unit tests only for speed)\n  - Exit non-zero on any failure with clear message\n  - Purpose: Enforce quality before commit\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer | Task: Create .githooks/pre-commit bash script that: 1) Runs cargo fmt --check, exits 1 on failure with \"Format check failed. Run cargo fmt\", 2) Runs cargo clippy -- -D warnings, exits 1 on failure, 3) Runs cargo test --lib, exits 1 on failure. Print status for each step. Use set -e for fail-fast | Restrictions: Keep total runtime under 30 seconds, test only lib not integration tests | Success: git commit is blocked when checks fail. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 3: GitHub Actions CI\n\n- [ ] 3.1 Create CI workflow\n  - File: `.github/workflows/ci.yml`\n  - Trigger on: push to main, pull_request\n  - Jobs: check (fmt, clippy), test, build-linux, build-windows\n  - Use: actions/checkout@v4, dtolnay/rust-toolchain@stable\n  - Cache: Swatinem/rust-cache@v2\n  - Purpose: Automated PR validation\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: GitHub Actions Engineer | Task: Create .github/workflows/ci.yml with: 1) name \"CI\", 2) triggers on push to main and pull_request, 3) Job \"check\" running cargo fmt --check and cargo clippy -- -D warnings, 4) Job \"test\" running cargo test --all-features, 5) Job \"build-linux\" building release binary, 6) Job \"build-windows\" cross-compiling with target x86_64-pc-windows-gnu. Use actions/checkout@v4, dtolnay/rust-toolchain@stable, Swatinem/rust-cache@v2. Set working-directory to ./core for cargo commands | Restrictions: Use only stable Rust, cache dependencies, keep workflow under 10 minutes | Success: PR triggers CI and all jobs pass. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 4: Custom Error Types\n\n- [ ] 4.1 Create error module\n  - File: `core/src/error.rs`\n  - Define KeyRxError enum with thiserror derive\n  - Variants: UnknownKey, ScriptCompileError, ScriptRuntimeError, InvalidPath, Io, PlatformError\n  - Implement Display with actionable messages\n  - Purpose: Structured error handling\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Create core/src/error.rs with KeyRxError enum using thiserror::Error derive. Variants: UnknownKey { key: String }, ScriptCompileError { message: String, line: Option<usize>, column: Option<usize> }, ScriptRuntimeError { message: String }, InvalidPath { path: String, reason: String }, Io(#[from] std::io::Error), PlatformError { message: String }. Add impl From<Box<rhai::EvalAltResult>> for KeyRxError | Restrictions: All variants must have actionable error messages, use #[error(\"...\")] attribute | Success: Error types compile, can be converted from common error sources. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 4.2 Export error module from lib.rs\n  - File: `core/src/lib.rs`\n  - Add `pub mod error;`\n  - Add `pub use error::KeyRxError;`\n  - Purpose: Make errors available to consumers\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/lib.rs to add pub mod error and pub use error::KeyRxError to re-exports | Restrictions: Preserve existing exports | Success: KeyRxError is importable from keyrx_core. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 5: Refactor RhaiRuntime Error Handling\n\n- [ ] 5.1 Remove Rc<RefCell> pattern\n  - File: `core/src/scripting/runtime.rs`\n  - Replace `Rc<RefCell<RemapRegistry>>` with owned `RemapRegistry`\n  - Store reference in Engine instead of cloning Rc\n  - Remove RefCell borrow_mut calls\n  - Purpose: Simpler ownership, no runtime borrow panics\n  - _Requirements: REQ-7_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Refactor core/src/scripting/runtime.rs to remove Rc<RefCell<RemapRegistry>>. Store RemapRegistry directly in RhaiRuntime struct. For Rhai function registration, use a different approach: store pending operations in a Vec and apply them after script execution, OR use rhai's NativeCallContext to access engine state. The lookup_remap method should return from owned registry | Restrictions: Must not introduce runtime panics, maintain thread safety | Success: No Rc<RefCell> in runtime.rs, all tests pass. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 5.2 Add error returns to Rhai functions\n  - File: `core/src/scripting/runtime.rs`\n  - Change remap/block/pass to return Result via Rhai's error mechanism\n  - Use rhai::EvalAltResult for script-visible errors\n  - Log warnings AND return error to script\n  - Purpose: No silent failures in scripts\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with Rhai experience | Task: Update remap/block/pass function registrations in core/src/scripting/runtime.rs to return errors to the script. Use engine.register_result_fn instead of register_fn. Return Err(Box::new(EvalAltResult::ErrorRuntime(...))) for unknown keys. Keep tracing::warn for logging but ALSO return the error | Restrictions: Errors must be catchable in Rhai scripts with try/catch, maintain backwards compatibility for valid key names | Success: Invalid key names cause script errors that can be caught. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 5.3 Fix RhaiRuntime Default impl\n  - File: `core/src/scripting/runtime.rs`\n  - Remove expect() from Default impl\n  - Either: remove Default impl, or return a \"null\" runtime that errors on use\n  - Purpose: No panics on initialization failure\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Remove or fix Default impl for RhaiRuntime in core/src/scripting/runtime.rs. Option 1: Remove Default impl entirely (callers use new()). Option 2: Return runtime with error state that returns Err on any operation. Prefer Option 1 for simplicity | Restrictions: Must not panic, update any code that relies on Default | Success: No expect() calls in runtime.rs. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 6: Refactor CLI Error Handling\n\n- [ ] 6.1 Remove process::exit from check command\n  - File: `core/src/cli/commands/check.rs`\n  - Replace std::process::exit(2) with return Err(...)\n  - Use anyhow::bail! or return KeyRxError\n  - Let main.rs handle exit codes\n  - Purpose: Testable CLI commands\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/cli/commands/check.rs to remove std::process::exit(2). Replace with returning anyhow::Error or KeyRxError::ScriptCompileError. The run() method should return Result<()> and propagate errors | Restrictions: Exit codes should be handled in main.rs only | Success: CheckCommand::run() returns Err on invalid scripts, no process::exit calls. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 6.2 Fix path handling in run command\n  - File: `core/src/cli/commands/run.rs`\n  - Replace path.to_str().unwrap_or_default() with proper error\n  - Return KeyRxError::InvalidPath for non-UTF8 paths\n  - Purpose: Clear error messages for path issues\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/cli/commands/run.rs to fix path handling. Replace to_str().unwrap_or_default() with: path.to_str().ok_or_else(|| anyhow::anyhow!(\"Invalid UTF-8 in path: {:?}\", path))? | Restrictions: Provide clear error message including the problematic path | Success: Non-UTF8 paths produce clear error message. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 6.3 Update main.rs error handling\n  - File: `core/src/bin/keyrx.rs`\n  - Centralize exit code logic in main\n  - Exit 1 for general errors, 2 for validation errors\n  - Print errors to stderr with context\n  - Purpose: Consistent exit code handling\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/bin/keyrx.rs main() to handle errors centrally. Wrap command execution in match, print errors to stderr with eprintln!, exit with code 1 for runtime errors. If error is KeyRxError::ScriptCompileError, exit with code 2 | Restrictions: Keep main() simple, delegate to commands | Success: CLI returns proper exit codes, errors printed to stderr. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 7: Enhanced Mock Infrastructure\n\n- [ ] 7.1 Add call tracking to MockInput\n  - File: `core/src/mocks/mock_input.rs`\n  - Add CallTracker field with Vec<MockCall>\n  - Record all method calls (start, stop, poll_events, send_output)\n  - Add call_history() -> &[MockCall] method\n  - Add with_error_on_start(error) builder method\n  - Purpose: Enable behavior verification in tests\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/mocks/mock_input.rs to add call tracking. Add MockCall enum with variants Start, Stop, PollEvents, SendOutput(OutputAction). Add calls: Vec<MockCall> field. Record each method call. Add call_history(&self) -> &[MockCall]. Add with_error_on_start(anyhow::Error) -> Self builder that causes start() to return error | Restrictions: Keep existing functionality working | Success: Tests can verify which methods were called and in what order. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 7.2 Add call tracking to MockRuntime\n  - File: `core/src/mocks/mock_runtime.rs`\n  - Record calls to execute, call_hook, load_file, lookup_remap\n  - Add configurable return values for lookup_remap\n  - Add with_remap(from, to) builder for test setup\n  - Purpose: Enable script runtime verification\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/mocks/mock_runtime.rs to add call tracking. Add MockRuntimeCall enum. Record all calls. Add with_remap(from: KeyCode, to: KeyCode) -> Self builder that configures lookup_remap to return Remap(to) for from. Add with_block(key: KeyCode) builder. Add call_history() method | Restrictions: Maintain ScriptRuntime trait compliance | Success: Tests can configure mock responses and verify calls. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 7.3 Add history tracking to MockState\n  - File: `core/src/mocks/mock_state.rs`\n  - Track all state mutations with timestamps\n  - Add state_history() -> &[StateChange] method\n  - Add assert_layer_activated(name) helper\n  - Purpose: Enable state change verification\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/mocks/mock_state.rs to add history tracking. Add StateChange enum with variants like LayerActivated(String), ModifierSet(ModifierSet). Record all mutations. Add state_history() method. Add assert_layer_activated(&self, name: &str) that panics if layer wasn't activated | Restrictions: Keep StateStore trait compliance | Success: Tests can verify state mutations occurred. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 8: Documentation\n\n- [ ] 8.1 Create SCRIPTING.md\n  - File: `docs/SCRIPTING.md`\n  - Document: remap(from, to), block(key), pass(key)\n  - Document: on_init() hook lifecycle\n  - Document: error handling (try/catch)\n  - Include: complete examples\n  - Purpose: Enable autonomous script development\n  - _Requirements: REQ-4_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer | Task: Create docs/SCRIPTING.md with: 1) Overview of Rhai scripting in KeyRx, 2) Function reference for remap(from, to), block(key), pass(key) with parameters, return values, errors, 3) Hook lifecycle explaining on_init(), 4) Error handling with try/catch examples, 5) Complete example scripts. Use markdown with code blocks | Restrictions: Keep examples runnable, document all error conditions | Success: AI agent can write valid scripts from documentation alone. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 8.2 Create KEYS.md\n  - File: `docs/KEYS.md`\n  - List all valid key names organized by category\n  - Include all aliases (e.g., Esc = Escape)\n  - Add examples of common remappings\n  - Purpose: Complete key name reference\n  - _Requirements: REQ-4_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer | Task: Create docs/KEYS.md listing all valid key names from KeyCode enum. Organize by category: Letters (A-Z), Numbers (0-9), Function Keys (F1-F12), Modifiers, Navigation, Editing, Whitespace, Locks, Punctuation, Numpad, Media. For each key, list all accepted aliases. Extract this information from core/src/engine/types.rs FromStr implementation | Restrictions: Must match actual implementation exactly | Success: All key names and aliases documented. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 9: Update Trait Documentation\n\n- [ ] 9.1 Document InputSource trait\n  - File: `core/src/traits/input_source.rs`\n  - Add module-level //! documentation\n  - Document thread safety requirements (Send bound)\n  - Document method contracts and error conditions\n  - Purpose: Clear interface contracts\n  - _Requirements: REQ-4_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/traits/input_source.rs with comprehensive documentation. Add //! module doc explaining purpose. For each method, document: what it does, when to call it, error conditions, thread safety. Explain why Send bound is required. Add example implementation sketch in doc comments | Restrictions: Keep docs accurate to actual behavior | Success: Trait is self-documenting for implementors. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 9.2 Document ScriptRuntime trait\n  - File: `core/src/traits/script_runtime.rs`\n  - Document method call order requirements\n  - Document error handling expectations\n  - Add example usage in doc comments\n  - Purpose: Clear interface contracts\n  - _Requirements: REQ-4_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer | Task: Update core/src/traits/script_runtime.rs with comprehensive documentation. Document: 1) Expected call order (load_file before run_script), 2) Error handling for each method, 3) What lookup_remap should return for unmapped keys, 4) Thread safety considerations. Add usage example in module docs | Restrictions: Document actual behavior | Success: Trait implementation requirements are clear. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n## Task 10: Verification and Cleanup\n\n- [ ] 10.1 Run cargo fmt on entire codebase\n  - Run: `cargo fmt` in core/\n  - Verify: `cargo fmt --check` passes\n  - Purpose: Establish clean formatting baseline\n  - _Requirements: REQ-6_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Developer | Task: Run cargo fmt in core/ directory to format all code. Then run cargo fmt --check to verify. Fix any issues that prevent formatting | Restrictions: None | Success: cargo fmt --check exits 0. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 10.2 Fix all clippy warnings\n  - Run: `cargo clippy -- -D warnings`\n  - Fix: All warnings (derive suggestions, etc.)\n  - Purpose: Clean lint baseline\n  - _Requirements: REQ-6_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Developer | Task: Run cargo clippy -- -D warnings in core/ and fix all warnings. Common fixes: add #[derive(Default)] where suggested, use clippy::derive_partial_eq_without_eq if needed, fix any other suggestions | Restrictions: Don't suppress warnings, fix them | Success: cargo clippy -- -D warnings exits 0. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 10.3 Run all tests and verify\n  - Run: `cargo test`\n  - Verify: All 59+ tests pass\n  - Run: `cargo test --release`\n  - Purpose: Confirm no regressions\n  - _Requirements: REQ-1, REQ-2_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer | Task: Run cargo test and cargo test --release in core/. All tests must pass. If any fail, investigate and fix. Document any test changes needed due to error handling refactors | Restrictions: All existing tests must pass or be updated appropriately | Success: All tests pass in both debug and release modes. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n\n- [ ] 10.4 Install and test pre-commit hooks\n  - Run: `./scripts/install-hooks.sh`\n  - Test: Make a commit with formatting issue, verify blocked\n  - Test: Make a clean commit, verify accepted\n  - Purpose: End-to-end hook verification\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec dev-tooling, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer | Task: Run ./scripts/install-hooks.sh. Create test file with bad formatting, attempt commit (should fail). Fix formatting, commit again (should succeed). Delete test file. Verify hooks work end-to-end | Restrictions: Clean up test artifacts | Success: Pre-commit hooks block bad code, allow good code. Mark task [-] in tasks.md before starting, log implementation with log-implementation tool after completion, then mark [x] when complete._\n",
  "fileStats": {
    "size": 24472,
    "lines": 239,
    "lastModified": "2025-11-30T00:04:27.640Z"
  },
  "comments": []
}