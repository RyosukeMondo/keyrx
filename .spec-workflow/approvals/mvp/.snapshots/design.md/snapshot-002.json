{
  "id": "snapshot_1764443818188_mo82687tk",
  "approvalId": "approval_1764443795506_l6xi6dd4s",
  "approvalTitle": "MVP Design Document",
  "version": 2,
  "timestamp": "2025-11-29T19:16:58.188Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: MVP\n\n## Overview\n\nThis design specifies the MVP implementation for KeyRx - completing the foundational infrastructure to make the engine installable, runnable, configurable, and testable via CLI. The design builds upon the existing DI architecture in `core/` and fills in the gaps to achieve a working end-to-end remapping pipeline.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **3-Layer Hybrid Architecture**: Engine (Rust) → Traits → OS Drivers\n- **Dependency Injection**: All components use trait-based DI (`InputSource`, `ScriptRuntime`, `StateStore`)\n- **Tokio Async**: Event loop uses async/await pattern\n- **CLI First**: All features CLI-exercisable before GUI\n\n### Project Structure (structure.md)\n- `core/src/engine/` - Event processing logic\n- `core/src/cli/commands/` - CLI command implementations\n- `core/src/scripting/` - Rhai runtime with remap functions\n- `core/src/drivers/` - Platform-specific input drivers\n- `core/src/mocks/` - Test doubles for all traits\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`Engine<I, S, St>`** (`engine/event_loop.rs`): DI-ready engine skeleton, needs event processing loop\n- **`RhaiRuntime`** (`scripting/runtime.rs`): Script loading/execution, needs remap function bindings\n- **`OutputWriter`** (`cli/output.rs`): JSON/Human output formatting\n- **`MockInput/MockRuntime/MockState`** (`mocks/`): Test doubles for simulation\n- **`clap` CLI skeleton** (`bin/keyrx.rs`): Command structure with check, run, doctor, bench, repl\n\n### Integration Points\n- **Rhai Engine**: Register `remap()`, `block()`, `pass()` functions\n- **Event Pipeline**: InputEvent → ScriptRuntime → OutputAction\n- **CLI Commands**: Complete stub implementations for simulate, bench, repl\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph CLI\n        A[keyrx CLI] --> B{Command}\n        B --> C[run]\n        B --> D[check]\n        B --> E[simulate]\n        B --> F[doctor]\n        B --> G[bench]\n    end\n\n    subgraph Engine\n        C --> H[Engine::new]\n        H --> I[InputSource]\n        H --> J[ScriptRuntime]\n        H --> K[StateStore]\n        I --> L[Event Loop]\n        L --> J\n        J --> M[OutputAction]\n    end\n\n    subgraph Scripting\n        J --> N[Rhai Engine]\n        N --> O[remap/block/pass]\n        O --> P[RemapRegistry]\n    end\n\n    subgraph Drivers\n        I -.-> Q[LinuxInput]\n        I -.-> R[WindowsInput]\n        I -.-> S[MockInput]\n    end\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each command in its own file, each trait in its own file\n- **Component Isolation**: Drivers are hot-swappable via traits\n- **Service Layer Separation**: CLI → Engine → Scripting → Drivers\n- **Utility Modularity**: Output formatting, error handling isolated\n\n## Components and Interfaces\n\n### Component 1: Event Processing Pipeline\n- **Purpose**: Process input events through script runtime to produce output actions\n- **Interfaces**:\n  ```rust\n  impl Engine<I, S, St> {\n      async fn process_event(&mut self, event: InputEvent) -> Result<OutputAction>;\n      async fn run_loop(&mut self) -> Result<()>;\n  }\n  ```\n- **Dependencies**: InputSource, ScriptRuntime, StateStore\n- **Reuses**: Existing Engine struct, trait definitions\n\n### Component 2: Remap Function Registry\n- **Purpose**: Track key remappings defined in Rhai scripts\n- **Interfaces**:\n  ```rust\n  pub struct RemapRegistry {\n      mappings: HashMap<KeyCode, RemapAction>,\n  }\n\n  impl RemapRegistry {\n      fn remap(&mut self, from: KeyCode, to: KeyCode);\n      fn block(&mut self, key: KeyCode);\n      fn lookup(&self, key: KeyCode) -> RemapAction;\n  }\n  ```\n- **Dependencies**: None (pure data structure)\n- **Reuses**: KeyCode enum from engine/types.rs\n\n### Component 3: Simulate Command\n- **Purpose**: Process simulated key events without real input drivers\n- **Interfaces**:\n  ```rust\n  pub struct SimulateCommand {\n      input: String,           // Comma-separated keys\n      script_path: PathBuf,\n      output: OutputWriter,\n  }\n\n  impl SimulateCommand {\n      fn run(&self) -> Result<()>;\n  }\n  ```\n- **Dependencies**: MockInput, RhaiRuntime, InMemoryState\n- **Reuses**: Engine, OutputWriter, MockInput\n\n### Component 4: Bench Command\n- **Purpose**: Measure and report input processing latency\n- **Interfaces**:\n  ```rust\n  pub struct BenchCommand {\n      iterations: usize,\n      output: OutputWriter,\n  }\n\n  impl BenchCommand {\n      fn run(&self) -> Result<BenchResult>;\n  }\n\n  pub struct BenchResult {\n      min_ns: u64,\n      max_ns: u64,\n      mean_ns: u64,\n      p99_ns: u64,\n  }\n  ```\n- **Dependencies**: Engine, MockInput\n- **Reuses**: Criterion patterns, OutputWriter\n\n### Component 5: Doctor Diagnostics\n- **Purpose**: Verify system prerequisites and permissions\n- **Interfaces**:\n  ```rust\n  pub struct DoctorCommand {\n      verbose: bool,\n      output: OutputWriter,\n  }\n\n  pub struct DiagnosticCheck {\n      name: String,\n      status: CheckStatus,\n      message: String,\n  }\n  ```\n- **Dependencies**: Platform-specific checks\n- **Reuses**: OutputWriter\n\n### Component 6: Platform Drivers (Stubs)\n- **Purpose**: OS-specific keyboard hook implementations\n- **Interfaces**: Implement `InputSource` trait\n- **Dependencies**: `windows-rs` (Windows), `evdev` (Linux)\n- **Reuses**: InputSource trait, InputEvent/OutputAction types\n\n## Data Models\n\n### InputEvent\n```rust\npub struct InputEvent {\n    pub key: KeyCode,\n    pub pressed: bool,      // true = key down, false = key up\n    pub timestamp: Instant,\n}\n```\n\n### OutputAction\n```rust\npub enum OutputAction {\n    Emit(KeyCode),          // Output a key\n    Block,                  // Suppress the input\n    Pass,                   // Forward unchanged\n}\n```\n\n### RemapAction\n```rust\npub enum RemapAction {\n    Remap(KeyCode),         // Remap to different key\n    Block,                  // Block this key\n    Pass,                   // Pass through unchanged\n}\n```\n\n### BenchResult\n```rust\npub struct BenchResult {\n    pub iterations: usize,\n    pub min_ns: u64,\n    pub max_ns: u64,\n    pub mean_ns: u64,\n    pub p99_ns: u64,\n    pub warning: Option<String>,  // Set if mean > 1ms\n}\n```\n\n### DiagnosticCheck\n```rust\npub struct DiagnosticCheck {\n    pub name: String,\n    pub status: CheckStatus,  // Passed, Failed, Skipped\n    pub message: String,\n    pub remediation: Option<String>,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Script File Not Found**\n   - **Handling**: Return `Err` with clear path in message\n   - **User Impact**: Exit code 1, display \"Script not found: {path}\"\n\n2. **Script Syntax Error**\n   - **Handling**: Catch Rhai parse error, extract line/column\n   - **User Impact**: Exit code 2, display \"Syntax error at line X, column Y: {message}\"\n\n3. **Permission Denied (Linux uinput)**\n   - **Handling**: Detect during doctor check\n   - **User Impact**: Display remediation: \"Add user to 'input' group or run with sudo\"\n\n4. **Keyboard Hook Failed (Windows)**\n   - **Handling**: Catch Windows API error\n   - **User Impact**: Display \"Failed to install keyboard hook. Antivirus may be blocking.\"\n\n5. **Script Execution Timeout**\n   - **Handling**: Rhai max_operations limit triggers error\n   - **User Impact**: Exit code 1, display \"Script exceeded maximum operations (infinite loop?)\"\n\n## Testing Strategy\n\n### Unit Testing\n- **Engine Event Processing**: Test `process_event` with MockInput, MockRuntime, MockState\n- **RemapRegistry**: Test remap/block/lookup with various key combinations\n- **CLI Commands**: Test command parsing and output formatting\n- **Coverage Target**: 80% for all core modules\n\n### Integration Testing\n- **End-to-End Script Loading**: Load Rhai file, verify hooks detected\n- **Simulate Pipeline**: `simulate --input \"A\" --script test.rhai` → verify output\n- **Doctor Checks**: Verify all diagnostic checks run without panic\n\n### End-to-End Testing\n- **Build Verification**: `cargo build --release` succeeds on Linux and Windows\n- **CLI Smoke Test**: All commands run with `--help` without error\n- **Script Validation**: `keyrx check scripts/std/layouts/ansi.rhai` returns exit 0\n\n### Property-Based Testing\n- **Fuzz RemapRegistry**: Random key sequences produce valid outputs\n- **Fuzz Event Processing**: Random InputEvents don't panic engine\n\n## File Changes Summary\n\n| File | Action | Purpose |\n|------|--------|---------|\n| `core/src/engine/event_loop.rs` | Modify | Add `process_event`, `run_loop` |\n| `core/src/engine/types.rs` | Modify | Add `RemapAction`, ensure `KeyCode` complete |\n| `core/src/scripting/runtime.rs` | Modify | Register remap/block/pass functions |\n| `core/src/scripting/registry.rs` | Create | `RemapRegistry` struct |\n| `core/src/cli/commands/simulate.rs` | Create | Simulate command |\n| `core/src/cli/commands/bench.rs` | Create | Bench command with latency stats |\n| `core/src/cli/commands/doctor.rs` | Modify | Complete platform diagnostics |\n| `core/src/cli/commands/mod.rs` | Modify | Export new commands |\n| `core/src/drivers/linux.rs` | Modify | Stub InputSource implementation |\n| `core/src/drivers/windows.rs` | Modify | Stub InputSource implementation |\n| `core/src/bin/keyrx.rs` | Modify | Wire up simulate command |\n| `scripts/std/example.rhai` | Create | Example remap script |\n| `core/tests/engine_test.rs` | Create | Engine integration tests |\n| `core/tests/simulate_test.rs` | Create | Simulate command tests |\n",
  "fileStats": {
    "size": 9369,
    "lines": 288,
    "lastModified": "2025-11-29T19:14:21.318Z"
  },
  "comments": []
}