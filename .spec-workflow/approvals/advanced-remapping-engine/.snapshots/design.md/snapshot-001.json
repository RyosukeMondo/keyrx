{
  "id": "snapshot_1764477820905_kxnkyefa0",
  "approvalId": "approval_1764477820902_ty33xa589",
  "approvalTitle": "Design: Advanced Remapping Engine",
  "version": 1,
  "timestamp": "2025-11-30T04:43:40.905Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: advanced-remapping-engine\n\n## Overview\n\nThe Advanced Remapping Engine implements a 4-layer architecture for timing-based keyboard customization. The core innovation is treating pending timing decisions as first-class citizens, enabling tap-hold, combos, and other behaviors while maintaining sub-millisecond latency.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Event Sourcing**: All decisions are derived from InputEvent stream\n- **No Global State**: Engine state is encapsulated in structs\n- **Dependency Injection**: TimingConfig is injectable, clock is mockable\n- **< 1ms latency**: No blocking operations, no heap allocations in hot path\n\n### Project Structure (structure.md)\n- New module: `core/src/engine/state/` - state management\n- New module: `core/src/engine/decision/` - timing decisions\n- New module: `core/src/engine/action/` - action execution\n- Extend: `core/src/engine/types.rs` - new types\n- Extend: `core/src/scripting/runtime.rs` - new Rhai functions\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`InputEvent`**: Already has `timestamp_us`, `is_repeat`, `is_synthetic`\n- **`RemapAction`**: Extend with new action types\n- **`Engine<I, S, St>`**: Add decision processing to event loop\n- **`StateStore` trait**: Extend for layer/modifier management\n- **`RhaiRuntime`**: Add new function registrations\n\n### Integration Points\n- **`process_event()`**: Insert decision checking before script lookup\n- **`MockState`**: Extend for testing layer/modifier state\n- **`InMemoryState`**: Production implementation of new state\n\n## Architecture\n\n### 4-Layer Engine Model\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ Layer 4: COMPOSED BEHAVIORS                                     │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │ TapHoldBehavior │ ComboBehavior │ OneShotBehavior        │   │\n│  │ (resolves pending decisions into actions)                │   │\n│  └──────────────────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────────────────┤\n│ Layer 3: ACTION PRIMITIVES                                      │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │ emit_key() │ block() │ modifier_set() │ layer_push()     │   │\n│  │ (translate decisions to OutputAction)                    │   │\n│  └──────────────────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────────────────┤\n│ Layer 2: DECISION PRIMITIVES                                    │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │ PendingDecision { key, started_at, deadline, config }    │   │\n│  │ DecisionQueue (check timeouts, resolve on events)        │   │\n│  └──────────────────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────────────────┤\n│ Layer 1: STATE MANAGEMENT                                       │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │ KeyStateTracker │ ModifierState │ LayerStack │ Timers    │   │\n│  │ (track what's pressed, active, pending)                  │   │\n│  └──────────────────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────────────────┤\n│ Layer 0: EVENT METADATA (from platform-drivers)                 │\n│  InputEvent { key, pressed, timestamp_us, is_repeat, ... }      │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Event Processing Flow\n\n```\nInputEvent\n    │\n    ▼\n┌───────────────────────┐\n│ 1. Skip synthetic?    │──yes──▶ PassThrough\n└───────────┬───────────┘\n            │no\n            ▼\n┌───────────────────────┐\n│ 2. Update KeyState    │ (track pressed keys)\n└───────────┬───────────┘\n            │\n            ▼\n┌───────────────────────┐\n│ 3. Check Safe Mode    │──active──▶ PassThrough\n└───────────┬───────────┘\n            │inactive\n            ▼\n┌───────────────────────┐\n│ 4. Check Combos       │──match──▶ Execute combo action\n└───────────┬───────────┘\n            │no match\n            ▼\n┌───────────────────────┐\n│ 5. Check Pending      │──resolves──▶ Execute resolved action\n│    Decisions          │\n└───────────┬───────────┘\n            │no resolution\n            ▼\n┌───────────────────────┐\n│ 6. Create Pending?    │──tap-hold key──▶ Queue decision, Block\n└───────────┬───────────┘\n            │normal key\n            ▼\n┌───────────────────────┐\n│ 7. Layer Lookup       │ (top to bottom)\n└───────────┬───────────┘\n            │\n            ▼\n┌───────────────────────┐\n│ 8. Apply Modifiers    │ (one-shot consumption)\n└───────────┬───────────┘\n            │\n            ▼\n┌───────────────────────┐\n│ 9. Execute Action     │──▶ OutputAction\n└───────────────────────┘\n```\n\n## Components and Interfaces\n\n### Component 1: KeyStateTracker\n\n**Purpose:** Track which physical keys are currently held\n**File:** `core/src/engine/state/key_state.rs`\n\n```rust\n/// Tracks physical key press state with timestamps.\npub struct KeyStateTracker {\n    /// Currently pressed keys with their press time\n    pressed: HashMap<KeyCode, u64>,  // key -> timestamp_us\n}\n\nimpl KeyStateTracker {\n    pub fn new() -> Self;\n\n    /// Record a key press. Returns false if already pressed (repeat).\n    pub fn key_down(&mut self, key: KeyCode, timestamp_us: u64) -> bool;\n\n    /// Record a key release. Returns hold duration in microseconds.\n    pub fn key_up(&mut self, key: KeyCode, timestamp_us: u64) -> Option<u64>;\n\n    /// Check if a key is currently pressed.\n    pub fn is_pressed(&self, key: KeyCode) -> bool;\n\n    /// Get press timestamp for a key.\n    pub fn press_time(&self, key: KeyCode) -> Option<u64>;\n\n    /// Get all currently pressed keys.\n    pub fn pressed_keys(&self) -> impl Iterator<Item = KeyCode>;\n\n    /// Get count of pressed keys.\n    pub fn pressed_count(&self) -> usize;\n}\n```\n\n**Dependencies:** `KeyCode`\n**Reuses:** None (new component)\n\n### Component 2: ModifierState\n\n**Purpose:** Track standard and virtual modifier state\n**File:** `core/src/engine/state/modifiers.rs`\n\n```rust\n/// Bitmap for 256 virtual modifiers (0-255).\npub struct VirtualModifiers {\n    bits: [u64; 4],  // 256 bits\n}\n\n/// Complete modifier state.\npub struct ModifierState {\n    /// Standard OS modifiers\n    pub standard: StandardModifiers,\n    /// Custom virtual modifiers (Mod_Thumb, etc.)\n    pub virtual_mods: VirtualModifiers,\n    /// One-shot modifier states\n    pub one_shot: OneShotState,\n}\n\n#[derive(Clone, Copy)]\npub struct StandardModifiers {\n    pub left_shift: bool,\n    pub right_shift: bool,\n    pub left_ctrl: bool,\n    pub right_ctrl: bool,\n    pub left_alt: bool,\n    pub right_alt: bool,\n    pub left_meta: bool,\n    pub right_meta: bool,\n}\n\n/// One-shot modifier tracking.\npub struct OneShotState {\n    /// Modifiers that are armed (will apply to next key)\n    armed: VirtualModifiers,\n    /// Modifiers that are locked (persist until disabled)\n    locked: VirtualModifiers,\n}\n\nimpl ModifierState {\n    pub fn new() -> Self;\n    pub fn activate(&mut self, modifier_id: u8);\n    pub fn deactivate(&mut self, modifier_id: u8);\n    pub fn is_active(&self, modifier_id: u8) -> bool;\n    pub fn arm_one_shot(&mut self, modifier_id: u8);\n    pub fn consume_one_shot(&mut self) -> VirtualModifiers;\n}\n```\n\n**Dependencies:** None\n**Reuses:** Pattern from `MockState`\n\n### Component 3: LayerStack\n\n**Purpose:** Manage keyboard layers with priority\n**File:** `core/src/engine/state/layers.rs`\n\n```rust\npub type LayerId = u16;\n\n/// A keyboard layer with mappings.\npub struct Layer {\n    pub id: LayerId,\n    pub name: String,\n    /// Key mappings for this layer\n    pub mappings: HashMap<KeyCode, LayerAction>,\n    /// If true, unmapped keys fall through to lower layers\n    pub transparent: bool,\n}\n\n/// Action within a layer (superset of RemapAction).\npub enum LayerAction {\n    /// Simple remap\n    Remap(KeyCode),\n    /// Block the key\n    Block,\n    /// Tap-hold behavior\n    TapHold { tap: KeyCode, hold: HoldAction },\n    /// Layer control\n    LayerPush(LayerId),\n    LayerPop,\n    LayerToggle(LayerId),\n    /// Modifier control\n    ModifierActivate(u8),\n    ModifierDeactivate(u8),\n    ModifierOneShot(u8),\n    /// Pass through (explicit)\n    Pass,\n}\n\npub enum HoldAction {\n    Key(KeyCode),\n    Modifier(u8),\n    Layer(LayerId),\n}\n\n/// Stack of active layers.\npub struct LayerStack {\n    /// All defined layers\n    layers: HashMap<LayerId, Layer>,\n    /// Active layer IDs in priority order (last = highest)\n    stack: Vec<LayerId>,\n    /// Base layer ID (always at bottom)\n    base: LayerId,\n}\n\nimpl LayerStack {\n    pub fn new() -> Self;\n    pub fn define_layer(&mut self, layer: Layer);\n    pub fn push(&mut self, layer_id: LayerId);\n    pub fn pop(&mut self) -> Option<LayerId>;\n    pub fn toggle(&mut self, layer_id: LayerId);\n    pub fn is_active(&self, layer_id: LayerId) -> bool;\n\n    /// Look up action for key, checking layers top to bottom.\n    pub fn lookup(&self, key: KeyCode) -> Option<&LayerAction>;\n\n    /// Get active layer names for debugging.\n    pub fn active_layers(&self) -> Vec<&str>;\n}\n```\n\n**Dependencies:** `KeyCode`, `LayerAction`\n**Reuses:** Pattern from `RemapRegistry`\n\n### Component 4: TimingConfig\n\n**Purpose:** Configurable timing parameters\n**File:** `core/src/engine/decision/timing.rs`\n\n```rust\n/// Timing configuration for decision-making.\n#[derive(Clone, Debug)]\npub struct TimingConfig {\n    /// Duration (ms) to distinguish tap from hold. Default: 200\n    pub tap_timeout_ms: u32,\n\n    /// Window (ms) for detecting simultaneous keypresses. Default: 50\n    pub combo_timeout_ms: u32,\n\n    /// Delay (ms) before considering a hold. Default: 0\n    pub hold_delay_ms: u32,\n\n    /// If true, emit tap immediately and correct if becomes hold. Default: false\n    pub eager_tap: bool,\n\n    /// If true, consider as hold if another key pressed during hold. Default: true\n    pub permissive_hold: bool,\n\n    /// If true, release tap even if interrupted. Default: false\n    pub retro_tap: bool,\n}\n\nimpl Default for TimingConfig {\n    fn default() -> Self {\n        Self {\n            tap_timeout_ms: 200,\n            combo_timeout_ms: 50,\n            hold_delay_ms: 0,\n            eager_tap: false,\n            permissive_hold: true,\n            retro_tap: false,\n        }\n    }\n}\n```\n\n**Dependencies:** None\n**Reuses:** None (matches tech.md spec exactly)\n\n### Component 5: PendingDecision & DecisionQueue\n\n**Purpose:** Track and resolve timing-based decisions\n**File:** `core/src/engine/decision/pending.rs`\n\n```rust\n/// A pending timing decision waiting for resolution.\n#[derive(Debug, Clone)]\npub enum PendingDecision {\n    TapHold {\n        key: KeyCode,\n        pressed_at: u64,\n        deadline: u64,\n        tap_action: KeyCode,\n        hold_action: HoldAction,\n        /// Has another key been pressed? (for permissive_hold)\n        interrupted: bool,\n    },\n    Combo {\n        keys: SmallVec<[KeyCode; 4]>,\n        started_at: u64,\n        deadline: u64,\n        action: LayerAction,\n        /// Keys pressed so far\n        matched: SmallVec<[KeyCode; 4]>,\n    },\n}\n\n/// Resolution of a pending decision.\npub enum DecisionResolution {\n    /// Decision resolved as tap\n    Tap(KeyCode),\n    /// Decision resolved as hold\n    Hold(HoldAction),\n    /// Combo triggered\n    ComboTriggered(LayerAction),\n    /// Combo timed out, release original keys\n    ComboTimeout(SmallVec<[KeyCode; 4]>),\n    /// Not yet resolved\n    Pending,\n}\n\n/// Queue of pending decisions.\npub struct DecisionQueue {\n    pending: Vec<PendingDecision>,\n    config: TimingConfig,\n}\n\nimpl DecisionQueue {\n    pub fn new(config: TimingConfig) -> Self;\n\n    /// Add a new tap-hold pending decision.\n    pub fn add_tap_hold(\n        &mut self,\n        key: KeyCode,\n        pressed_at: u64,\n        tap: KeyCode,\n        hold: HoldAction,\n    );\n\n    /// Check for resolution based on new event.\n    pub fn check_event(&mut self, event: &InputEvent) -> Vec<DecisionResolution>;\n\n    /// Check for timeout-based resolutions.\n    pub fn check_timeouts(&mut self, now_us: u64) -> Vec<DecisionResolution>;\n\n    /// Mark a pending decision as interrupted.\n    pub fn mark_interrupted(&mut self, by_key: KeyCode);\n\n    /// Get all pending decisions for debugging.\n    pub fn pending(&self) -> &[PendingDecision];\n\n    /// Clear all pending decisions.\n    pub fn clear(&mut self);\n}\n```\n\n**Dependencies:** `KeyCode`, `TimingConfig`, `HoldAction`\n**Reuses:** None (core new functionality)\n\n### Component 6: ComboRegistry\n\n**Purpose:** Store and match combo definitions\n**File:** `core/src/engine/decision/combos.rs`\n\n```rust\n/// A combo definition.\npub struct ComboDef {\n    /// Keys that must be pressed simultaneously\n    pub keys: SmallVec<[KeyCode; 4]>,\n    /// Action to execute when combo triggers\n    pub action: LayerAction,\n}\n\n/// Registry of defined combos.\npub struct ComboRegistry {\n    combos: Vec<ComboDef>,\n}\n\nimpl ComboRegistry {\n    pub fn new() -> Self;\n\n    /// Register a new combo.\n    pub fn register(&mut self, keys: &[KeyCode], action: LayerAction);\n\n    /// Find combos that could match given pressed keys.\n    pub fn find_potential(&self, pressed: &[KeyCode]) -> Vec<&ComboDef>;\n\n    /// Check if pressed keys exactly match any combo.\n    pub fn find_exact(&self, pressed: &[KeyCode]) -> Option<&ComboDef>;\n}\n```\n\n**Dependencies:** `KeyCode`, `LayerAction`\n\n### Component 7: AdvancedEngine (Extended Engine)\n\n**Purpose:** Orchestrate all components\n**File:** `core/src/engine/advanced.rs`\n\n```rust\n/// Extended engine with timing-based decisions.\npub struct AdvancedEngine<I, S>\nwhere\n    I: InputSource,\n    S: ScriptRuntime,\n{\n    input: I,\n    script: S,\n\n    // State (Layer 1)\n    key_state: KeyStateTracker,\n    modifiers: ModifierState,\n    layers: LayerStack,\n\n    // Decisions (Layer 2)\n    pending: DecisionQueue,\n    combos: ComboRegistry,\n\n    // Config\n    timing: TimingConfig,\n    safe_mode: bool,\n    running: bool,\n}\n\nimpl<I, S> AdvancedEngine<I, S> {\n    pub fn new(input: I, script: S, timing: TimingConfig) -> Self;\n\n    /// Process a single event through all layers.\n    pub fn process_event(&mut self, event: InputEvent) -> Vec<OutputAction>;\n\n    /// Check for timeout-based resolutions (call periodically).\n    pub fn tick(&mut self, now_us: u64) -> Vec<OutputAction>;\n\n    // State access for GUI/debugging\n    pub fn key_state(&self) -> &KeyStateTracker;\n    pub fn modifiers(&self) -> &ModifierState;\n    pub fn layers(&self) -> &LayerStack;\n    pub fn pending(&self) -> &[PendingDecision];\n    pub fn timing_config(&self) -> &TimingConfig;\n}\n```\n\n## Data Models\n\n### TimingConfig (serializable)\n\n```rust\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct TimingConfig {\n    pub tap_timeout_ms: u32,\n    pub combo_timeout_ms: u32,\n    pub hold_delay_ms: u32,\n    pub eager_tap: bool,\n    pub permissive_hold: bool,\n    pub retro_tap: bool,\n}\n```\n\n### EngineState (for GUI/FFI)\n\n```rust\n#[derive(Debug, Serialize)]\npub struct EngineState {\n    pub pending_decisions: Vec<PendingDecisionInfo>,\n    pub active_layers: Vec<String>,\n    pub active_modifiers: Vec<u8>,\n    pub pressed_keys: Vec<KeyCode>,\n    pub safe_mode: bool,\n    pub timing_config: TimingConfig,\n}\n\n#[derive(Debug, Serialize)]\npub struct PendingDecisionInfo {\n    pub key: KeyCode,\n    pub decision_type: String,  // \"tap_hold\", \"combo\"\n    pub elapsed_ms: u32,\n    pub deadline_ms: u32,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Layer not found**\n   - **Handling:** Return error from `layer_push()`, log warning\n   - **User Impact:** Script error with layer name\n\n2. **Combo conflict (overlapping key sets)**\n   - **Handling:** Log warning, first-registered wins\n   - **User Impact:** Warning in debug output\n\n3. **Timer overflow**\n   - **Handling:** Use wrapping arithmetic, resolve all pending as timeout\n   - **User Impact:** None (transparent recovery)\n\n4. **Too many pending decisions (DoS protection)**\n   - **Handling:** Cap at 32, oldest dropped\n   - **User Impact:** Warning logged, oldest decisions resolved\n\n## Testing Strategy\n\n### Unit Testing\n\n**KeyStateTracker:**\n- Press/release tracking\n- Duplicate press handling\n- Hold duration calculation\n\n**ModifierState:**\n- Virtual modifier activate/deactivate\n- One-shot arm/consume/lock cycle\n- Standard modifier tracking\n\n**LayerStack:**\n- Push/pop/toggle\n- Transparent layer fallthrough\n- Lookup priority order\n\n**DecisionQueue:**\n- Tap resolution (release before timeout)\n- Hold resolution (timeout expires)\n- Interrupt handling (permissive_hold)\n- Eager tap + correction\n\n**ComboRegistry:**\n- Exact match\n- Partial match\n- Order-independent matching\n\n### Integration Testing\n\n```rust\n#[tokio::test]\nasync fn tap_hold_tap_scenario() {\n    let mut engine = test_engine();\n    engine.register_tap_hold(KeyCode::CapsLock, KeyCode::Escape, HoldAction::Modifier(CTRL_ID));\n\n    // Press and quick release = tap\n    let actions = engine.process_event(key_down(KeyCode::CapsLock, 0));\n    assert!(actions.is_empty()); // Pending\n\n    let actions = engine.process_event(key_up(KeyCode::CapsLock, 100_000)); // 100ms\n    assert_eq!(actions, vec![\n        OutputAction::KeyDown(KeyCode::Escape),\n        OutputAction::KeyUp(KeyCode::Escape),\n    ]);\n}\n\n#[tokio::test]\nasync fn tap_hold_hold_scenario() {\n    let mut engine = test_engine();\n    engine.register_tap_hold(KeyCode::CapsLock, KeyCode::Escape, HoldAction::Modifier(CTRL_ID));\n\n    // Press and hold past timeout = hold\n    let _ = engine.process_event(key_down(KeyCode::CapsLock, 0));\n    let actions = engine.tick(250_000); // 250ms > 200ms timeout\n\n    assert!(engine.modifiers().is_active(CTRL_ID));\n}\n```\n\n### Benchmark Testing\n\n```rust\n#[bench]\nfn bench_process_event_with_pending(b: &mut Bencher) {\n    let mut engine = test_engine();\n    engine.add_pending_tap_hold(KeyCode::A, 0, KeyCode::B, HoldAction::Key(KeyCode::C));\n\n    b.iter(|| {\n        engine.process_event(key_down(KeyCode::X, 100_000))\n    });\n}\n// Target: < 1 microsecond per event\n```\n",
  "fileStats": {
    "size": 20996,
    "lines": 632,
    "lastModified": "2025-11-30T04:41:46.461Z"
  },
  "comments": []
}