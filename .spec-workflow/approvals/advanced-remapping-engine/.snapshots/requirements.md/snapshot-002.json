{
  "id": "snapshot_1764478056482_obeuctv7u",
  "approvalId": "approval_1764477820839_a2lkz2z5b",
  "approvalTitle": "Requirements: Advanced Remapping Engine",
  "version": 2,
  "timestamp": "2025-11-30T04:47:36.482Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document: advanced-remapping-engine\n\n## Introduction\n\nPhase 2.5 \"The Brain\" - the advanced remapping engine that transforms KeyRx from a simple key swapper into a QMK/KMonad-class keyboard customization powerhouse. This spec implements the timing-based decision system, virtual modifiers, layer stack, and composed behaviors that enable tap-hold, combos, one-shot modifiers, and more.\n\n**Core differentiator**: All timing parameters are configurable and exposed to users, with the future GUI visualizing trade-offs in real-time.\n\n## Alignment with Product Vision\n\nFrom `product.md`:\n> \"Unlike traditional remappers that simply map key A to key B, KeyRx treats input as a programmable stream of events, enabling complex behaviors, layer systems, and context-aware remapping.\"\n\nFrom `tech.md`:\n> \"Input latency: < 1ms processing overhead (hard requirement)\"\n\nThis spec implements the 4-layer engine architecture defined in `tech.md`:\n- Layer 1: State Management\n- Layer 2: Decision Primitives\n- Layer 3: Action Primitives\n- Layer 4: Composed Behaviors\n\n## Requirements\n\n### REQ-1: Key State Tracking\n\n**User Story:** As a power user, I want the engine to track which physical keys are currently held, so that timing-based decisions can be made accurately.\n\n#### Acceptance Criteria\n\n1. WHEN a key is pressed THEN the engine SHALL record the key and timestamp in the key state tracker\n2. WHEN a key is released THEN the engine SHALL remove the key from the tracker and calculate hold duration\n3. WHEN querying key state THEN the engine SHALL return all currently held keys with their press timestamps\n4. IF the key state tracker receives duplicate key-down events THEN it SHALL ignore them (is_repeat handling)\n\n### REQ-2: Timer System\n\n**User Story:** As a power user, I want the engine to support timing-based decisions, so that tap-hold and other time-sensitive behaviors work accurately.\n\n#### Acceptance Criteria\n\n1. WHEN a timing decision is needed THEN the engine SHALL use microsecond-precision timestamps from InputEvent\n2. WHEN creating a pending decision THEN the engine SHALL associate it with a deadline (press_time + timeout)\n3. WHEN the deadline expires THEN the engine SHALL resolve the pending decision as \"hold\"\n4. IF another key is pressed during a pending decision THEN the engine SHALL optionally resolve early (permissive_hold)\n\n### REQ-3: Virtual Modifier System\n\n**User Story:** As a power user, I want to define custom modifiers like \"Mod_Thumb\" that exist only in KeyRx, so that I can create behaviors beyond what the OS supports.\n\n#### Acceptance Criteria\n\n1. WHEN defining a virtual modifier THEN the engine SHALL support up to 255 custom modifier IDs\n2. WHEN activating a virtual modifier THEN the engine SHALL set the corresponding bit in the modifier state\n3. WHEN checking modifier state THEN scripts SHALL be able to query any combination of virtual modifiers\n4. IF a virtual modifier is activated THEN it SHALL NOT be sent to the OS (engine-internal only)\n5. WHEN the engine state is queried THEN it SHALL report both standard and virtual modifier states\n\n### REQ-4: Layer Stack System\n\n**User Story:** As a power user, I want multiple keyboard layers that I can switch between, so that I can have navigation, symbol, and gaming modes on one keyboard.\n\n#### Acceptance Criteria\n\n1. WHEN creating a layer THEN the engine SHALL store it with a unique name and keymap\n2. WHEN pushing a layer THEN the engine SHALL add it to the top of the stack (highest priority)\n3. WHEN popping a layer THEN the engine SHALL remove it from the stack\n4. WHEN processing a key THEN the engine SHALL check layers from top to bottom until a mapping is found\n5. IF a layer is marked transparent THEN the engine SHALL fall through to lower layers for unmapped keys\n6. WHEN the base layer is reached THEN unmapped keys SHALL pass through unchanged\n\n### REQ-5: Tap-Hold Detection\n\n**User Story:** As a power user, I want a key to do one thing on tap and another on hold (e.g., CapsLock = Escape/Ctrl), so that I can maximize efficiency of each key.\n\n#### Acceptance Criteria\n\n1. WHEN a tap-hold key is pressed THEN the engine SHALL create a pending decision with the configured timeout\n2. WHEN the key is released before timeout THEN the engine SHALL emit the tap action\n3. WHEN the timeout expires while key is held THEN the engine SHALL activate the hold action\n4. IF `eager_tap` is enabled THEN the engine SHALL emit tap immediately and cancel if becomes hold\n5. IF `permissive_hold` is enabled THEN interrupting key SHALL resolve pending decision as hold\n6. IF `retro_tap` is enabled THEN releasing after hold SHALL still emit tap\n\n### REQ-6: Combo Detection\n\n**User Story:** As a power user, I want to press two keys simultaneously to produce a different output (e.g., J+K = Escape), so that I can access more functions without extra keys.\n\n#### Acceptance Criteria\n\n1. WHEN defining a combo THEN the engine SHALL accept a set of 2+ keys and an action\n2. WHEN keys are pressed within `combo_timeout_ms` THEN the engine SHALL check for matching combos\n3. WHEN a combo matches THEN the engine SHALL block the original keys and execute the combo action\n4. IF combo keys are released in different order THEN the combo SHALL still trigger\n5. IF only some combo keys are pressed THEN the engine SHALL pass them through after timeout\n\n### REQ-7: One-Shot Modifiers\n\n**User Story:** As a power user, I want a \"sticky\" modifier that applies only to the next key, so that I don't have to hold modifier keys.\n\n#### Acceptance Criteria\n\n1. WHEN a one-shot modifier is activated THEN the engine SHALL mark it as \"armed\"\n2. WHEN the next non-modifier key is pressed THEN the engine SHALL apply the modifier and deactivate it\n3. IF the one-shot modifier is pressed again THEN it SHALL become \"locked\" (persistent)\n4. IF a third press occurs THEN it SHALL be deactivated completely\n5. WHEN reporting state THEN the engine SHALL distinguish between armed, locked, and inactive\n\n### REQ-8: Timing Configuration\n\n**User Story:** As a power user, I want to configure timing thresholds to match my typing speed, so that behaviors feel natural to me.\n\n#### Acceptance Criteria\n\n1. WHEN configuring the engine THEN users SHALL be able to set:\n   - `tap_timeout_ms` (default: 200) - tap vs hold threshold\n   - `combo_timeout_ms` (default: 50) - simultaneous key window\n   - `hold_delay_ms` (default: 0) - prevent accidental holds\n   - `eager_tap` (default: false) - emit tap immediately\n   - `permissive_hold` (default: true) - interrupt = hold\n   - `retro_tap` (default: false) - tap on release after hold\n2. WHEN timing config is changed THEN it SHALL take effect immediately\n3. WHEN timing config is queried THEN the current values SHALL be returned for GUI visualization\n\n### REQ-9: Rhai Script Integration\n\n**User Story:** As a power user, I want to define advanced behaviors in Rhai scripts, so that I have full programmable control.\n\n#### Acceptance Criteria\n\n1. WHEN registering tap-hold in Rhai THEN the function `tap_hold(key, tap, hold)` SHALL be available\n2. WHEN registering combos in Rhai THEN the function `combo([keys], action)` SHALL be available\n3. WHEN registering one-shot in Rhai THEN the function `one_shot(modifier)` SHALL be available\n4. WHEN activating layers in Rhai THEN functions `layer_push(name)`, `layer_pop()`, `layer_toggle(name)` SHALL be available\n5. WHEN querying state in Rhai THEN functions `is_layer_active(name)`, `is_modifier_active(mod)` SHALL be available\n\n### REQ-10: Pending Decision Queue\n\n**User Story:** As a developer, I want the engine to track multiple pending timing decisions, so that complex overlapping behaviors work correctly.\n\n#### Acceptance Criteria\n\n1. WHEN multiple tap-hold keys are pressed THEN each SHALL have its own pending decision\n2. WHEN processing events THEN the engine SHALL check all pending decisions for resolution\n3. WHEN a decision resolves THEN it SHALL be removed from the queue\n4. IF decisions conflict THEN the engine SHALL resolve in order of creation (FIFO)\n5. WHEN reporting state THEN all pending decisions SHALL be visible for debugging\n\n### REQ-11: Emergency Exit (Safe Mode)\n\n**User Story:** As a user, I want an always-working escape hatch, so that I can never be locked out by a bad config.\n\n#### Acceptance Criteria\n\n1. WHEN Ctrl+Alt+Shift+Escape is pressed THEN the engine SHALL immediately disable all remapping\n2. WHEN safe mode is active THEN all keys SHALL pass through unchanged\n3. WHEN the same combo is pressed again THEN the engine SHALL re-enable remapping\n4. IF the engine crashes THEN the keyboard SHALL automatically return to normal (OS handles this)\n\n## Non-Functional Requirements\n\n### Performance\n- All timing decisions must be < 100 microseconds\n- Pending decision queue lookup must be O(1) or O(log n)\n- No heap allocations in hot path (event processing)\n- Timer checks must not block event processing\n\n### Latency Budget\n```\nTotal budget: 1000 microseconds\n├── Event receive:     ~100 us (OS + channel)\n├── State lookup:       ~10 us (key state, modifiers)\n├── Decision check:     ~50 us (pending queue)\n├── Script lookup:      ~50 us (remap registry)\n├── Action execute:     ~10 us (emit/block)\n├── Output send:       ~100 us (uinput/SendInput)\n└── Margin:            ~680 us (safety buffer)\n```\n\n### Testability\n- All timing logic must be testable with mock clocks\n- Pending decision queue must be inspectable\n- Layer stack must be queryable\n- Virtual modifier state must be readable\n\n### Reliability\n- No panics in timing code paths\n- Graceful handling of timer overflow\n- Safe mode must never fail\n\n### Code Quality\n- Functions < 50 lines\n- Files < 500 lines\n- 80% test coverage on decision logic\n",
  "fileStats": {
    "size": 9756,
    "lines": 195,
    "lastModified": "2025-11-30T04:40:04.315Z"
  },
  "comments": []
}