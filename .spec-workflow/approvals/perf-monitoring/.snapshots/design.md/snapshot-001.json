{
  "id": "snapshot_1764768818914_r30tqqlhy",
  "approvalId": "approval_1764768818897_qeau30sjv",
  "approvalTitle": "Performance Monitoring Design",
  "version": 1,
  "timestamp": "2025-12-03T13:33:38.914Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design adds a zero-allocation metrics system using HDR histograms for latency tracking and bounded buffers for memory stats. The core innovation is the `MetricsCollector` trait that allows pluggable implementations - from no-op in release builds to full profiling in debug. All hot-path metrics use pre-allocated storage.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Performance First**: Sub-microsecond overhead\n- **No Allocations**: Pre-allocated metric storage\n- **Debug Mode**: Full profiling when enabled\n\n### Project Structure (structure.md)\n- Metrics in `core/src/metrics/`\n- FFI exports in `core/src/ffi/exports_metrics.rs`\n- Flutter display in `ui/lib/widgets/metrics/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **hdrhistogram**: Industry-standard latency histograms\n- **parking_lot**: Fast synchronization\n- **serde**: Metric serialization\n\n### Integration Points\n- **Engine**: Records latency per event\n- **FFI**: Exports metric snapshots\n- **Flutter**: Displays real-time metrics\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Recording Layer\"\n        ENG[Engine] --> |record| MC[MetricsCollector]\n        DRV[Drivers] --> |record| MC\n    end\n\n    subgraph \"MetricsCollector\"\n        MC --> LH[LatencyHistogram]\n        MC --> MM[MemoryMonitor]\n        MC --> PP[ProfilePoints]\n    end\n\n    subgraph \"Export Layer\"\n        MC --> |snapshot| SNAP[MetricsSnapshot]\n        SNAP --> FFI[FFI Export]\n        SNAP --> JSON[JSON Export]\n    end\n\n    subgraph \"Display Layer\"\n        FFI --> FL[Flutter UI]\n        JSON --> LOG[Log Files]\n    end\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each metric type isolated\n- **Component Isolation**: Metrics don't depend on engine internals\n- **Zero Allocation**: Hot path uses pre-allocated storage\n- **Pluggable Implementation**: NoOp vs Full collectors\n\n## Components and Interfaces\n\n### Component 1: MetricsCollector Trait\n\n- **Purpose:** Abstract interface for metrics collection\n- **Interfaces:**\n  ```rust\n  pub trait MetricsCollector: Send + Sync {\n      fn record_latency(&self, operation: Operation, micros: u64);\n      fn record_memory(&self, bytes: usize);\n      fn start_profile(&self, name: &'static str) -> ProfileGuard;\n      fn snapshot(&self) -> MetricsSnapshot;\n      fn reset(&self);\n  }\n\n  #[derive(Debug, Clone, Copy)]\n  pub enum Operation {\n      EventProcess,\n      RuleMatch,\n      ActionExecute,\n      DriverRead,\n      DriverWrite,\n  }\n\n  pub struct ProfileGuard<'a> {\n      collector: &'a dyn MetricsCollector,\n      name: &'static str,\n      start: Instant,\n  }\n\n  impl Drop for ProfileGuard<'_> {\n      fn drop(&mut self) {\n          let elapsed = self.start.elapsed().as_micros() as u64;\n          self.collector.record_profile(self.name, elapsed);\n      }\n  }\n  ```\n- **Dependencies:** std::time\n- **Reuses:** RAII guard pattern\n\n### Component 2: LatencyHistogram\n\n- **Purpose:** Track latency percentiles with bounded memory\n- **Interfaces:**\n  ```rust\n  pub struct LatencyHistogram {\n      histogram: Histogram<u64>,\n      thresholds: LatencyThresholds,\n  }\n\n  impl LatencyHistogram {\n      pub fn new(max_value: u64, precision: u8) -> Self;\n      pub fn record(&self, micros: u64);\n      pub fn percentile(&self, p: f64) -> u64;\n      pub fn stats(&self) -> LatencyStats;\n      pub fn reset(&self);\n  }\n\n  #[derive(Debug, Clone, Serialize)]\n  pub struct LatencyStats {\n      pub count: u64,\n      pub min: u64,\n      pub max: u64,\n      pub mean: f64,\n      pub p50: u64,\n      pub p95: u64,\n      pub p99: u64,\n      pub p999: u64,\n  }\n\n  pub struct LatencyThresholds {\n      pub warn_micros: u64,\n      pub error_micros: u64,\n  }\n  ```\n- **Dependencies:** hdrhistogram crate\n- **Reuses:** HDR histogram algorithm\n\n### Component 3: MemoryMonitor\n\n- **Purpose:** Track memory usage and detect leaks\n- **Interfaces:**\n  ```rust\n  pub struct MemoryMonitor {\n      samples: RingBuffer<MemorySample>,\n      baseline: AtomicUsize,\n      peak: AtomicUsize,\n  }\n\n  impl MemoryMonitor {\n      pub fn new(sample_capacity: usize) -> Self;\n      pub fn record(&self, bytes: usize);\n      pub fn set_baseline(&self);\n      pub fn stats(&self) -> MemoryStats;\n      pub fn detect_leak(&self, growth_threshold: f64) -> Option<LeakInfo>;\n  }\n\n  #[derive(Debug, Clone, Serialize)]\n  pub struct MemoryStats {\n      pub current: usize,\n      pub peak: usize,\n      pub baseline: usize,\n      pub growth_rate: f64,\n  }\n\n  #[derive(Debug, Clone, Serialize)]\n  pub struct LeakInfo {\n      pub bytes_leaked: usize,\n      pub duration_secs: f64,\n      pub rate_per_sec: f64,\n  }\n  ```\n- **Dependencies:** std::sync::atomic\n- **Reuses:** Ring buffer pattern\n\n### Component 4: ProfilePoints\n\n- **Purpose:** Function-level timing for profiling\n- **Interfaces:**\n  ```rust\n  pub struct ProfilePoints {\n      points: DashMap<&'static str, ProfileStats>,\n      enabled: AtomicBool,\n  }\n\n  impl ProfilePoints {\n      pub fn new() -> Self;\n      pub fn record(&self, name: &'static str, micros: u64);\n      pub fn enable(&self, enabled: bool);\n      pub fn hot_spots(&self, top_n: usize) -> Vec<HotSpot>;\n      pub fn flamegraph_data(&self) -> FlamegraphData;\n  }\n\n  #[derive(Debug, Clone, Serialize)]\n  pub struct HotSpot {\n      pub name: &'static str,\n      pub total_micros: u64,\n      pub call_count: u64,\n      pub avg_micros: f64,\n      pub max_micros: u64,\n  }\n  ```\n- **Dependencies:** dashmap\n- **Reuses:** Profiling patterns\n\n### Component 5: MetricsSnapshot\n\n- **Purpose:** Serializable metrics export\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, Clone, Serialize)]\n  pub struct MetricsSnapshot {\n      pub timestamp: u64,\n      pub uptime_secs: f64,\n      pub latency: HashMap<Operation, LatencyStats>,\n      pub memory: MemoryStats,\n      pub hot_spots: Vec<HotSpot>,\n  }\n\n  impl MetricsSnapshot {\n      pub fn to_json(&self) -> String;\n      pub fn to_ffi(&self) -> FfiMetrics;\n  }\n  ```\n- **Dependencies:** serde\n- **Reuses:** Snapshot pattern\n\n### Component 6: NoOpCollector\n\n- **Purpose:** Zero-overhead collector for release builds\n- **Interfaces:**\n  ```rust\n  pub struct NoOpCollector;\n\n  impl MetricsCollector for NoOpCollector {\n      fn record_latency(&self, _: Operation, _: u64) {}\n      fn record_memory(&self, _: usize) {}\n      fn start_profile(&self, _: &'static str) -> ProfileGuard { ... }\n      fn snapshot(&self) -> MetricsSnapshot { MetricsSnapshot::empty() }\n      fn reset(&self) {}\n  }\n  ```\n- **Dependencies:** None\n- **Reuses:** Null object pattern\n\n## Data Models\n\n### RingBuffer\n```rust\npub struct RingBuffer<T> {\n    data: Box<[T]>,\n    head: AtomicUsize,\n    len: AtomicUsize,\n}\n```\n\n### FfiMetrics\n```rust\n#[repr(C)]\npub struct FfiMetrics {\n    pub event_latency_p99: u64,\n    pub memory_current: u64,\n    pub memory_peak: u64,\n    pub uptime_secs: f64,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Histogram overflow**\n   - **Handling:** Clamp to max value, log warning\n   - **User Impact:** Extreme values capped\n\n2. **Memory read failure**\n   - **Handling:** Skip sample, use last known\n   - **User Impact:** Slight accuracy loss\n\n3. **Export serialization failure**\n   - **Handling:** Return error with partial data\n   - **User Impact:** Degraded but functional\n\n## Testing Strategy\n\n### Unit Testing\n- Test histogram accuracy\n- Verify percentile calculations\n- Test memory tracking\n\n### Performance Testing\n- Benchmark recording overhead\n- Verify no allocations in hot path\n- Test under high load\n\n### Integration Testing\n- Test FFI export\n- Verify Flutter display\n- Test metric persistence\n",
  "fileStats": {
    "size": 7616,
    "lines": 303,
    "lastModified": "2025-12-03T13:33:11.401Z"
  },
  "comments": []
}