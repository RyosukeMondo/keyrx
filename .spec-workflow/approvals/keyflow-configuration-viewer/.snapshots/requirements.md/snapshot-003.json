{
  "id": "snapshot_1765699922545_cxzvrtw1g",
  "approvalId": "approval_1765699382687_wqyii7fas",
  "approvalTitle": "Re-approve requirements (added autonomous dev alignment) for keyflow-configuration-viewer",
  "version": 3,
  "timestamp": "2025-12-14T08:12:02.545Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nKeyFlow is a new UI-first concept for visualizing how physical devices flow through virtual layouts and mappings inside KeyRx. Today it exists only as UI scaffolding. This spec wires it to real data so users can see actual devices, wiring, layouts, and resulting mappings sourced from the Rust engine/FFI, with live status and error visibility. The outcome is a trustworthy, read-only configuration viewer that reflects the real runtime and configuration state.\n\n## Alignment with Product Vision\n\n- Makes the “Visual > Abstract” pillar concrete by exposing the real mapping pipeline (device → wiring → layout → mapping) instead of static mock data.\n- Supports the “Blank Slate” model by visualizing hardware profiles and virtual layouts without assuming QWERTY defaults, helping users verify custom modifiers and layers.\n- Reinforces reliability goals (Tier-0 software) by surfacing engine/FFI status, wiring gaps, and validation errors before users deploy mappings.\n- Improves developer autonomy by providing telemetry hooks for the KeyFlow data path so automated agents can catch regressions early (per AUTONOMOUS-DEV-GUIDE).\n\n## Requirements\n\n### Requirement 1\n\n**User Story:** As a user with connected keyboards, I want KeyFlow to load real devices, hardware profiles, and virtual layouts from the Rust core so I can see my current setup instead of placeholder UI data.\n\n#### Acceptance Criteria\n\n1. WHEN the KeyFlow screen opens THEN it SHALL fetch devices (including virtual) via DeviceRegistryService and show connection/remap status with last-refresh timestamp.\n2. IF the FFI bridge is unavailable or returns an error THEN the UI SHALL display a non-blocking error banner and retry affordance without crashing.\n3. WHEN devices connect/disconnect or remap toggles fire via bridge events THEN the KeyFlow list SHALL update within 1s and maintain scroll/selection state.\n\n### Requirement 2\n\n**User Story:** As a mapper, I want KeyFlow to visualize the wiring from physical keys to virtual layout keys and their mapped actions so I can validate completeness and spot conflicts.\n\n#### Acceptance Criteria\n\n1. WHEN a device/hardware profile is selected THEN KeyFlow SHALL show its wiring map (physical scancode → virtual layout key) using saved profile wiring from HardwareService/LayoutService.\n2. IF a physical key has no wiring OR multiple virtual targets THEN the view SHALL flag it with a clear badge and include a count of unresolved items.\n3. WHEN a virtual key is selected THEN the details panel SHALL display the mapped action(s) from the active keymap/profile, including layer/context info where available.\n\n### Requirement 3\n\n**User Story:** As a user debugging live behavior, I want KeyFlow to reflect runtime state from the engine so I can correlate active layers and recent events with the configuration graph.\n\n#### Acceptance Criteria\n\n1. WHEN runtime state snapshots/deltas arrive via BridgeStateUpdate THEN KeyFlow SHALL highlight active layers/modifiers and the last N input events in the viewer.\n2. IF runtime data is stale for >5s or missing required fields THEN the UI SHALL show a “runtime paused” indicator and expose a manual refresh.\n3. WHEN bypass/remap mode is toggled in the engine THEN KeyFlow SHALL show the mode within 1s and disable runtime overlays when bypassed.\n\n### Requirement 4\n\n**User Story:** As a developer/operator, I want KeyFlow to expose telemetry for its data pipeline so autonomous agents can detect regressions and track latency.\n\n#### Acceptance Criteria\n\n1. WHEN FFI-backed fetches (devices, layouts, wiring, keymaps) occur THEN metrics SHALL record success/failure counts and p95 latency, reported through ObservabilityService/OTEL if enabled.\n2. IF data parsing fails (JSON/schema mismatch) THEN KeyFlow SHALL capture a structured error (with source call and payload size only) and surface a user-safe message.\n3. WHEN the viewer renders more than 150 keys or 5+ layers THEN render timing SHALL be measured and logged for perf regression alerts.\n\n### Requirement 5\n\n**User Story:** As a developer, I want the KeyFlow workflow to support the fastest possible iteration (hot reload/UI mocks plus Rust dev tooling) so I can ship changes quickly without waiting on full rebuilds.\n\n#### Acceptance Criteria\n\n1. WHEN developing the KeyFlow UI THEN I SHALL be able to run hot reload with a mock bridge (no native lib) via a documented `just`/script target and see the screen render with stub data.\n2. WHEN switching to real FFI THEN I SHALL be able to rebuild only the needed Rust artifacts with sccache/incremental builds and reuse bindings; no full clean required for UI-only changes.\n3. WHEN running tests in dev loop THEN a “fast lane” (nextest or filtered widget/unit sets) SHALL be documented and runnable from CLI, with the full suite reserved for CI/main.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: KeyFlow UI is read-only and delegates data access to existing services (DeviceRegistryService, HardwareService, LayoutService, KeymapService, RuntimeService).\n- **Modular Design**: Data adapters translate FFI models into view models; rendering widgets are split into list, graph, and detail components.\n- **Dependency Management**: All FFI interactions go through the KeyrxBridge-backed services; no direct native calls from widgets.\n- **Clear Interfaces**: Define a KeyFlowRepository/view-model contract so UI can be previewed with mocked data for tests.\n\n### Performance\n- Initial KeyFlow load ≤ 1.0s with warm bridge; ≤ 2.0s cold. Incremental updates (device event, runtime delta) reflected ≤ 1s.\n- Rendering must stay ≥ 55fps for 120-key layouts; avoid blocking the UI thread during FFI fetches (use isolates/futures as needed).\n\n### Security\n- No direct execution of user scripts; data is read-only. Guard against malformed FFI payloads with schema validation and size limits.\n- Ensure no PII is logged when capturing telemetry; redact device serials in logs/metrics.\n\n### Reliability\n- Graceful degradation when the bridge is missing or mismatched protocol: informative banner + retry.\n- Offline/bridge-down mode falls back to cached last-known data with a freshness indicator.\n- Errors in one data fetch (e.g., layout) must not blank the entire view; partial render allowed with inline errors.\n\n### Usability\n- Clear empty/error states for “no devices”, “no wiring”, and “runtime paused”.\n- Keyboard-first navigation for selection, with accessible labels on badges/alerts.\n- Visual legend explaining color/badge meanings for wiring gaps and runtime status.\n- Autonomous Dev Alignment: All telemetry and error surfaces must be consumable by the automation loop defined in `docs/AUTONOMOUS-DEV-GUIDE.md`, including CLI-friendly summaries for offline agents.\n\n### Iteration Speed\n- Provide a documented hot-reload loop using a mock bridge (no native lib) for UI-only work.\n- Enable Rust-side fast rebuilds with sccache and incremental builds; avoid unnecessary binding regeneration.\n- Supply CLI commands for “fast tests” (nextest/unit/widget subset) and full CI commands; prefer filtered runs during dev.\n",
  "fileStats": {
    "size": 7221,
    "lines": 97,
    "lastModified": "2025-12-14T08:08:57.771Z"
  },
  "comments": []
}